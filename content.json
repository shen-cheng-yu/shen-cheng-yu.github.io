{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"κԭ","url":"http://yoursite.com","root":"/"},"posts":[{"title":"网络命令","date":"2019-07-24T07:08:11.485Z","path":"2019/07/24/网络命令/","raw":"---\ntitle: 网络命令\ntags:\n- 网络\n- 命令\n---\n# ping\nPING通127.0.0.1代表本机TCP/IP协议正常。 不通 则表示协议没有装好。\n能PING通本机IP地址代表本机网卡通信正常。不通网卡通信不正常。\n能PING通网关代表计算机能够连通代理服务器或者internet ，不通则无法连接互联网。\n能PING通DNS代表计算机能够通过DNS解析域名，无法打开网页。\n\n`ping 192.168.2.166 -c 3` 指定ping的次数\n","comments":true,"permalink":"http://yoursite.com/2019/07/24/网络命令/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"视频核心安全网关","date":"2019-07-24T07:08:11.485Z","path":"2019/07/24/视频核心安全网关/","raw":"---\ntitle: 视频核心安全网关\ntags:\n- smart\n- 网络\n- 命令\n---\n# 母盘部署\n继昨天的数据库测试连接与初始化之后，今天继续部署母盘。\n`./shutdown.sh`关闭Tomcat服务，`./catalina.sh start`和`./startup.sh`开启Tomcat服务。\n杀java进程。\n追踪日志文件，`tail -f /SPG/Tomcat-JKD/bin/logs/catalina.out`，如有`org.apache.catalina.startup.catalina.start server start in ...ms`则表示服务已经启动了。\n\n进入那个数据库初始化网站，在管理员界面新建三个管理员账号。\n进入密钥管理界面，自动生成一个密钥种子。\n进入版本控制界面，配置一些信息。这里我是2口，即除了MGT口之外的ETH0，ETH1两个网口。\n之后\t`reboot`重启设备。\n然后取获取license ，这里选择专业版，SPG-CSG260，因为我是两个口填上SN数据，获取到license数据。下载下来，不要解压，上传license进入部署主路的界面。\n\n\n# 修改设备的默认网关\n之前KNI0口是1网段，而MGT口不能和KNI0口冲突，所以当时把MGT口设置成了2网段。所以设备上网的默认网关理应是`192.168.2.1`，但是它实际的默认网关却是KNI0口下的`192.168.1.1`，这个地址不具有路由转发的功能，所以设备ping不通`192.168.1.1`，`8.8.8.8`，`www.baidu.com`，`114.114.114.114`。\n`route -n`查看设备的默认网关。\n删除掉`192.168.1.1`这个默认网关即可。`route del default gw 192.168.1.1`，然后默认网关，外网ip，域名，dns服务器地址就都可以ping的通了。","comments":true,"permalink":"http://yoursite.com/2019/07/24/视频核心安全网关/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"smart","slug":"smart","permalink":"http://yoursite.com/tags/smart/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"电脑软件相关","date":"2019-07-24T07:08:11.376Z","path":"2019/07/24/电脑软件相关/","raw":"---\ntitle: 电脑软件相关\ntags:\n- 软件\n- 电脑\n---\n\n# IE浏览器\n这两天部署设备，很多网页都是要在IE浏览器里面打开。安装了防泄密软件之后，小娜搜索有时候就搜不出来ie浏览器了。在C盘里的`Program Files`里的`Interner Explorer `里面可以找到IE浏览器。","comments":true,"permalink":"http://yoursite.com/2019/07/24/电脑软件相关/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"网络协议","date":"2019-07-24T07:08:11.376Z","path":"2019/07/24/网络协议/","raw":"---\ntitle: 网络协议\ntags:\n- 网络\n---\n<font color=\"red\">2019-07-24</font>\n# SSH\nSSH（Secure Shell）为建立在应用层基础上的安全协议。SSH 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。传统的网络服务程序，如：ftp、pop和telnet在本质上都是不安全的，因为它们在网络上用明文传送口令和数据，别有用心的人非常容易就可以截获这些口令和数据。而且，这些服务程序的安全验证方式也是有其弱点的， 就是很容易受到“中间人”（man-in-the-middle）这种方式的攻击。所谓“中间人”的攻击方式， 就是“中间人”冒充真正的服务器接收你传给服务器的数据，然后再冒充你把数据传给真正的服务器。服务器和你之间的数据传送被“中间人”一转手做了手脚之后，就会出现很严重的问题。使用SSH，还有一个额外的好处就是传输的数据是经过压缩的，所以可以加快传输的速度。","comments":true,"permalink":"http://yoursite.com/2019/07/24/网络协议/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"Markdown","date":"2019-07-24T07:08:11.376Z","path":"2019/07/24/Markdown/","raw":"---\ntitle: Markdown\ntags:\n- 电脑\n---\n\n# hexo 报错\n刚刚上传`shell编程基础`一文，`hexo g -d`部署之后，报错`Template render error: Error: expected end of comment, got end of file`。\n\n经百度，这是因为，hexo在解析markdown时，`#`与`{`或`}`不能挨在一块。这个错误发生在：\n1. 提取字符串长度，`echo ${ #hello}`其中hello 是一个字符串。\n2. 提取字符串的子串`echo ${ #hello:start_pos:length}`。\n3. 获取数组长度`echo ${ #num[*]}`与`echo ${ #word[@]}`。\n这三种情况下。\n\n最简单的就是在`#`与`{`之间空一格。\n在有的地方看到，将`#`符号用它的html编码代替`&#35`或`&#35;`，但是均不行，hexo解析之后就会原样显示为`&#35`或`&#35;`。况且百度`#`的html编码，并没有百度到。\n[Hexo错误”expected end of comment, got end of file”](http://xuejiangtao.com/posts/11a14c34/)\n\n# hexo编写表格\n正文部分要和表格部分之间有空格，否则解析不出来。","comments":true,"permalink":"http://yoursite.com/2019/07/24/Markdown/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"}]},{"title":"XShell","date":"2019-07-24T07:08:11.329Z","path":"2019/07/24/XShell/","raw":"---\ntitle: XShell\ntags:\n- 软件\n---\n<font color=\"red\">2019-07-24</font>\n# Vim小键盘设置\n在xshell上用vi/vim的时候，开NumLock时按小键盘上的数字键并不能输入数字，而是出现一个字母然后换行。\n\nxshell：文件--->选择当前使用的连接，属性--->终端--->键盘--->功能键仿真，修改为linux 就可以正常使用小键盘了。\n[xshell连接linux中vim不能正常使用小键盘的问题](https://blog.csdn.net/weixin_37998647/article/details/78622300)","comments":true,"permalink":"http://yoursite.com/2019/07/24/XShell/","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"网络端口","date":"2019-07-24T06:04:12.589Z","path":"2019/07/24/网络端口/","raw":"---\ntitle: 网络端口\ntags:\n- 网络\n---\n# 物理端口与逻辑端口\n所谓的端口，就好像是门牌号一样，客户端可以通过ip地址找到对应的服务器端，但是服务器端是有很多端口的，每个应用程序对应一个端口号，通过类似门牌号的端口号，客户端才能真正的访问到该服务器。 为了对端口进行区分，将每个端口进行了编号，这就是端口号。\n\n在网络技术中，端口包括逻辑端口和物理端口两种类型。\n1. 物理端口是用于连接物理设备之间的接口，如ADSL Modem、集线器、交换机、路由器上用于连接其他网络设备的接口。\n2. 逻辑端口是指逻辑意义上用于区分服务的端口，一台拥有IP地址的主机可以提供许多服务，比如Web服务、FTP服务、SMTP服务等，这些服务完全可以通过1个IP地址来实现。一个IP地址的端口通过16bit进行编号，最多可以有65536个端口。端口是通过端口号来标记的，端口号只有整数，范围是从0 到65535。\n\n[端口号](https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7/10883658?fr=aladdin)\n\n# 端口号划分\n## 按照协议类型划分\n在Internet上，按照协议类型分类，端口被分为TCP端口和UDP端口两类，虽然他们都用正整数标识，但这并不会引起歧义，比如TCP的80端口和UDP的80端口，因为数据报在标明端口的同时，还将标明端口的类型。\n### TCP端口\n即传输控制协议端口，需要在客户端和服务器之间建立连接，这样可以提供可靠的数据传输。常见的包括FTP的21端口，Telnet的23端口，SMTP的25端口，HTTP的80端口。\n### UDP端口\n即用户数据报协议端口，无需在客户端和服务器端建立连接，安全性得不到保障。常见的DNS的53端口，SNMP（简单网络管理协议）的161端口，QQ使用的8000和4000端口。\n\n##  按照端口号划分\n端口被分为固定端口和动态端口两大类（一些教程还将极少被用到的高端口划分为第三类：私有端口）。\n### 固定端口（0－1023）\n由于这些端口紧绑于一些服务，所以我们会经常扫描这些端口来判断对方是否开启了这些服务，如TCP的21（ftp），80（http），等等一些大家熟知的端口。\n### 动态端口（1024－49151）\n这些端口并不被固定的捆绑于某一服务，操作系统将这些端口动态的分配给各个进程，同一进程两次分配有可能分配到不同的端口。不过一些应用程序并不愿意使用操作系统分配的动态端口，他们有其自己的‘商标性’端口，如oicq客户端的4000端口，木马冰河的7626端口等都是固定而出名的。\n[网络协议中端口类型及分类](https://blog.csdn.net/qq_35409955/article/details/72598327)","comments":true,"permalink":"http://yoursite.com/2019/07/24/网络端口/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"netstat","date":"2019-07-24T03:44:22.145Z","path":"2019/07/24/netstat/","raw":"---\ntitle: netstat\ntags:\n- 命令\n- 网络\n---\n# 参数解释\n\n|选项|含义|\n|:----:|:-----:|\n|-t |  指明显示TCP端口|\n|-u  |指明显示UDP端口|\n|-x  |指明显示unix端口|\n|-p  |显示进程标识符和程序名称，每一个套接字/端口都属于一个程序|\n|-n  |不进行DNS轮询，端口号和ip都显示数字，不显示域名或名称（加快命令执行速度）|\n|-c |每隔一个固定时间，执行该netstat命令。|\n```\n\nProto RefCnt Flags       Type       State         I-Node   Path\nunix  2      [ ]         DGRAM                    1055760  /var/run/dpdk/rte/mp_socket\n\nProto Recv-Q Send-Q Local Address           Foreign Address         State      \ntcp        0    236 192.168.2.166:22        192.168.2.24:4342       ESTABLISHED\n\n[root@SmartSPG6300 ~]# netstat -nt -c 2 |grep 80  //每隔2秒查询一次\n```\n[Linux netstat命令详解](http://makaidong.com/w-20150101/12783_3567823.html)\n\n# cmd下的netstat命令\nwindows下用netstat好像与linux有些不一样。\n\n|选项|含义|\n|:----:|:-----:|\n|-o |  显示拥有的与每个连接关联的进程 ID|\n|-t |显示当前连接卸载状态|\n | -n |           以数字形式显示地址和端口号|\n |-a|显示所有连接，不加则只显示tcp连接|\n```\n  //netstat -nt\n  协议  本地地址          外部地址        状态           卸载状态\n  TCP    127.0.0.1:1703         127.0.0.1:1704         ESTABLISHED     InHost\n\n  //netstat -no\n  协议  本地地址          外部地址        状态           PID\n  TCP    127.0.0.1:1703         127.0.0.1:1704         ESTABLISHED     5884\n\n  //netstat   不加选项n的情景\n  TCP    192.168.2.24:4342      192.168.2.166:ssh      ESTABLISHED\n```\n\n\n\n    \n     \n\n\n\n\n\n\n\n\n\n\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/24/netstat/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"DPDK模块开发指南","date":"2019-07-24T03:44:22.107Z","path":"2019/07/24/DPDP模块开发指南/","raw":"---\ntitle: DPDK模块开发指南\ntags:\n- smart\n---\n\n# 整体流程\n1. 初始化\n2. 包处理\n3. 配置下发\njava组下发信息（包）给linuxC组，我们对于这些包做出解析处理，完成功能。\n\n# 如何增加模块\n## 添加模块ID的枚举定义\n在`vpg_module.def.h `文件的`module_id_e`中，增加模块ID的枚举定义。\n```cpp\ntypedef enum tag_module_id_e\n{\n    MODULE_ID_SND       = 0,  \n    MODULE_ID_BLC,\n    MODULE_ID_WLM,\n    MODULE_ID_EXAMPLE,\n    MODULE_ID_DAC,\n    MODULE_ID_DDI,\n    MODULE_ID_TID,\t\n    MODULE_ID_API,\n\tMODULE_ID_DSM,\n\tMODULE_ID_ECM,\t\n\tMODULE_ID_NAC,\n\tMODULE_ID_LIC,\n    MODULE_ID_MAX\n}module_id_e;\n```\n## 包含模块的头文件\n在`vpg_module.def.c `文件中，增加包含模块的头文件。一般头文件中包含自身模块的初始化函数即可，可参考`packet_balance.h`。\n```cpp\n//包含各个模块的头文件\n/*include modules*/\n//#include \"module_example.h\"\n#include \"packet_routing.h\"\n#include \"packet_balance.h\"\n#include \"dac.h\"\n#include \"device_discovery.h\"\n#include \"tid_business_entry.h\"\n#include \"api_extern.h\"\n#include \"dsm.h\"\n#include \"lic.h\"\n#include \"ecm.h\"\n```\n## 完成模块的头文件\n```cpp\n//头文件里面包含有该模块自身的初始化函数的声明即可\n#ifndef _INCLUDE_MODULE_PACKET_BALANCE_H_\n#define _INCLUDE_MODULE_PACKET_BALANCE_H_\n\n#include \"vos_typedef.h\"\n#include \"vos_str.h\"\n\nVOS_INT32 packet_balance_init(VOS_VOID);\n#endif\n```\n## 函数指针指向模块的初始化函数\n在`vpg_module.def.c` 文件的`vgp_module_init_register`函数中，将模块自身的初始化函数复制到`g_astModuleInfo`数组对应的元素中。\n```cpp\ntypedef struct tag_module_info_t\n{\n    //在module_info_t结构体中定义了很多的函数指针\n    rte_pipeline_table_action_handler_hit pfPktProcess;\n    vgp_module_init_fun pfModuleInit;\n    vgp_module_cfg_handle_fun pfModuleCfgHandle;\n    vgp_module_action_handle_fun pfModuleActionHandle;\n    vgp_module_msg_handle_fun pfModuleMsgHandle;\n    vgp_module_local_init_fun pfModuleLocalInit;\n    vgp_module_global_init_fun pfModuleGlobalInit;\n    vgp_module_dbg_handle_fun pfModuleDbgHandle;\n    vgp_module_cfg_get_fun pfModuleCfgGet;\n    VOS_CHAR pcModuleName[VGP_MODULE_NAME_LEN];\n    VOS_VOID *pGlobalData;\n    vgp_module_aging_handle_fun pfModuleAgingHandle;\n}module_info_t;\n```\n```cpp\n//定义一个结构体数组，数组中的每一个元素代表一个模块来用\nmodule_info_t g_astModuleInfo[MODULE_ID_MAX];\nmodule_device_info_t g_stDeviceInfo;\n\nVOS_INT32 vgp_module_init_register(VOS_VOID)\n{\n \t/*filled by modules*/\n\t//g_astModuleInfo[MODULE_ID_EXAMPLE].pfModuleInit = exp_init; \n//将每个模块中用来指向初始化函数的函数指针，指向他们的初始化函数\n\tg_astModuleInfo[MODULE_ID_SND].pfModuleInit = packet_routing_init; \n\tg_astModuleInfo[MODULE_ID_BLC].pfModuleInit = packet_balance_init; \n\tg_astModuleInfo[MODULE_ID_DDI].pfModuleInit = ddi_init;\n    g_astModuleInfo[MODULE_ID_DAC].pfModuleInit = dac_init; \n    g_astModuleInfo[MODULE_ID_API].pfModuleInit = api_init; \n    g_astModuleInfo[MODULE_ID_TID].pfModuleInit = tid_init; \n    g_astModuleInfo[MODULE_ID_DSM].pfModuleInit = dsm_init;\n    g_astModuleInfo[MODULE_ID_LIC].pfModuleInit = lic_module_init;\n    g_astModuleInfo[MODULE_ID_ECM].pfModuleInit = ecm_init; \n\t\n    return 0;\n}\n```\n## 实现模块的初始化函数\n主要内容为填充`module_register_info_t`结构体并且调用`vgp_module_register`函数，可参考`packet_balance.c `文件的`packet_balance_init`函数。\n```cpp\n//实现该模块的初始化函数\nVOS_INT32 packet_balance_init(VOS_VOID)\n{\n\t//int i = 0;\n\t//VOS_UINT32 uiRet;\n\tmodule_register_info_t stMyModuleRegisterInfo = {0};\n\t\n\t//填充 module_register_info_t 结构体 \n\tstMyModuleRegisterInfo.pfPktProcess = vgp_packet_balance_process;\n\tstMyModuleRegisterInfo.pfModuleLocalInit = VOS_NULL_PTR;\n\tstMyModuleRegisterInfo.pfModuleCfgHandle = VOS_NULL_PTR;\n\tstMyModuleRegisterInfo.pfModuleMsgHandle = VOS_NULL_PTR;\n\tVOS_StrNCpy(stMyModuleRegisterInfo.pcModuleName, \"BLC\", VGP_MODULE_NAME_LEN);\n\t\n//调用 vgp_module_register 函数\n\tvgp_module_register(&stMyModuleRegisterInfo, MODULE_ID_BLC);\n\t\n\treturn 0;\n}\n```\n`module_register_info_t`结构体具体内容为：\n```cpp\ntypedef struct tag_module_register_info_t\n{\n    vgp_module_global_init_fun pfModuleGlobalInit;  //全局数据取初始化 \n    vgp_module_local_init_fun pfModuleLocalInit;    //本地数据取初始化\n    rte_pipeline_table_action_handler_hit pfPktProcess;  //报文处理回调\n    vgp_module_cfg_handle_fun pfModuleCfgHandle;    //配置下发回调\n    vgp_module_action_handle_fun pfModuleActionHandle;  //命令下发回调\n    vgp_module_msg_handle_fun pfModuleMsgHandle;   //消息处理回调\n    vgp_module_dbg_handle_fun pfModuleDbgHandle;  \n    vgp_module_aging_handle_fun pfModuleAgingHandle;\n    vgp_module_cfg_get_fun pfModuleCfgGet;    \n    \n    VOS_CHAR pcModuleName[VGP_MODULE_NAME_LEN];     //模块名称\n}module_register_info_t;\n```\n`vgp_module_register`函数如下：\n```cpp\nVOS_INT32 vgp_module_register(const module_register_info_t* pstModuleRegisterInfo, VOS_UINT32 uiModuleId)\n{\n    const module_register_info_t *pstSrcInfo = pstModuleRegisterInfo;\n    module_info_t *pstDstInfo = &(g_astModuleInfo[uiModuleId]);;\n\n    ASSERT_RETURN_RET((uiModuleId < MODULE_ID_MAX), VOS_ERR);\n\n\n    /* set field*/\n    VOS_StrNCpy(pstDstInfo->pcModuleName, pstSrcInfo->pcModuleName, VGP_MODULE_NAME_LEN);\n    pstDstInfo->pfPktProcess        = pstSrcInfo->pfPktProcess;\n    pstDstInfo->pfModuleGlobalInit   = pstSrcInfo->pfModuleGlobalInit;\n    pstDstInfo->pfModuleLocalInit   = pstSrcInfo->pfModuleLocalInit;\n    pstDstInfo->pfModuleCfgHandle   = pstSrcInfo->pfModuleCfgHandle;\n    pstDstInfo->pfModuleActionHandle   = pstSrcInfo->pfModuleActionHandle;\n    pstDstInfo->pfModuleMsgHandle   = pstSrcInfo->pfModuleMsgHandle;\n    pstDstInfo->pfModuleDbgHandle   = pstSrcInfo->pfModuleDbgHandle;\n\tpstDstInfo->pfModuleAgingHandle   = pstSrcInfo->pfModuleAgingHandle;\n    pstDstInfo->pfModuleCfgGet   = pstSrcInfo->pfModuleCfgGet;\n\n\tprintf(\"=========vgp_module_register===module_id:%d==\\r\\n\", uiModuleId);\n    return VOS_OK;\n}\n```\n## 适配新增加文件的makefile\n如果在平台代码里fwd目录下新增加一个example目录，适配makefile步骤如下：\n1. 在新增加的example目录里创建一个makefile，内容如下：\n```\n# 获取当前目录的绝对路径，命名方式为“模块名_PATH”\nEXAMPLE_PATH = $(FWD_DIR)/example\n\n# all source are stored in SRCS-y\nSRCS-y += $( EXAMPLE _PATH)/module_example.c\n\n# add the dbg code path\nINCPATH += -I$( EXAMPLE _PATH)\n```\n2. 修改example的上级目录的makefile，即fwd目录下的makefile，增加对example目录下makefile的引用，即增加一行：\n```cpp\ninclude $(FWD_DIR)/example/Makefile\n```\n\n# 模块向框架注册的回调函数\n## 全局数据区初始化\n```cpp\ntypedef VOS_VOID* (*vgp_module_global_init_fun)(VOS_VOID* arg);\n```\n模块使用的全局数据区初始化。\n返回指向全局数据区的指针，0（VOS_NULL_PTR）失败。\n模块自行分配的数据区，供模块内部使用，全局（所有pipeline，控制线程）可见，通过（待补充接口）获取。\n\n## 本地数据取初始化\n```cpp\ntypedef VOS_VOID* (*vgp_module_local_init_fun)(struct pipeline *p,VOS_VOID* arg);\n```\n模块使用的本地数据区初始化。\n返回指向本地数据区的指针， 0（VOS_NULL_PTR）失败。\n模块自行分配的数据区，供模块内部使用，可见范围为当前pipeline，通过（待补充接口）获取。\n\n## 配置下发回调\n```cpp\ntypedef VOS_INT32 (*vgp_module_cfg_handle_fun)(cJSON* pCfg);\n```\ndpdk控制线程在收到对应模块的配置下发后回调。\npCfg是配置内容，cJSON结构体指针。\n返回VOS_OK则成功，VOS_ERR\t失败。\n\n收到对应模块的配置消息后在DPDK控制线程中调用。若需要下发到各个pipeline的本地数据区，需要模块在此函数中自行发送到pipeline的消息，pipeline收到后调用消息处理回调实现。\n\n## 命令下发回调\n```cpp\ntypedef VOS_INT32 (*vgp_module_action_handle_fun)( cJSON* pstJsonAction, cJSON* pstJsonReply);\n```\ndpdk控制线程在收到对应模块的命令下发后回调。\npstJsonAction是配置内容的cJSON结构体指针，pstJsonReply是应答内容的cJSON结构体指针，已由框架分配，供模块在其中加入应答内容。\nVOS_OK成功，VOS_ERR失败。\n\n收到对应模块的命令消息后在DPDK控制线程中调用。由模块自行构造应答消息。\n\n返回VOS_OK表示成功生成应答内容，框架会将应答内容返回给网管平台。VOS_ERR表示无法生成应答内容，框架会自行应答ERR，不会使用pstJsonReply内容。\n\n## 消息处理回调\n```cpp\ntypedef VOS_INT32 (*vgp_module_msg_handle_fun)(\n\tstruct rte_pipeline *p,\n\tvoid *req_data,\n\tuint32_t req_len,\n\tvoid *rsp_data,\n\tuint32_t *rsp_len);\n```\npipeline在收到对应模块的消息后回调。VOS_OK成功，VOS_ERR失败。收到对应模块的消息后在pipeline所属的线程中调用。\n\n# 增加新模块test\n## 修改`vgp_module_def.h`\n主要是增加新模块的枚举定义，将`MODULE_ID_TEST`放到`MODULE_ID_MAX`前面就好。\n## 修改`vgp_module_def.c`\n主要是添加新模块的头文件 `#include \"test.h\"`，以及添加初始化函数的函数指针`g_astModuleInfo[MODULE_ID_TEST].pfModuleInit = test_init;`。\n## 完成`test.h`\n头文件里面主要就是添加初始化函数的声明即可。\n```cpp\n#ifndef _INCLUDE_MODULE_TEST_H_\n#define _INCLUDE_MODULE_TEST_H_\n\n#include \"vos_typedef.h\"\n#include \"vos_str.h\"\nVOS_INT32 test_init(VOS_VOID);\n#endif\n```\n## 完成`test.c`\n源程序里面主要就是实现刚刚声明的初始化函数。\n```cpp\n#include <rte_pipeline.h>\n#include <rte_ether.h>\n#include <rte_ip.h>\n#include \"test.h\"\n#include \"vgp_module.h\"\n#include <rte_mbuf_ptype.h>\n#include \"pipeline.h\"\n#include <stdio.h>\n\n\nVOS_INT32 test_init(VOS_VOID)\n{\n\t//int i = 0;\n\t//VOS_UINT32 uiRet;\n\tmodule_register_info_t stMyModuleRegisterInfo = {0};\n\t\n\tstMyModuleRegisterInfo.pfPktProcess = VOS_NULL_PTR;\n\tstMyModuleRegisterInfo.pfModuleLocalInit = VOS_NULL_PTR;\n\tstMyModuleRegisterInfo.pfModuleCfgHandle = VOS_NULL_PTR;\n\tstMyModuleRegisterInfo.pfModuleMsgHandle = VOS_NULL_PTR;\n\tVOS_StrNCpy(stMyModuleRegisterInfo.pcModuleName, \"TEST\", VGP_MODULE_NAME_LEN);\n    printf(\"test_init has been inited!\\n\");\n\n\tvgp_module_register(&stMyModuleRegisterInfo, MODULE_ID_TEST);\n\t\n\treturn 0;\n}\n```\n初始化函数里面，只有一行打印输出，用来调试。\n## 编写模块的Makefile\n```makefile\nTEST_PATH  = $(IOT_SRC_DIR)/test\nSRCS-y += $(TEST_PATH)/test.c\nINCPATH += -I$(TEST_PATH)\n```\n这个`makefile`与`test.c`，`test.h`一起放在`test`文件夹下。`test`目录放在`dpdk`目录下。\n## 修改dpdk的Makefile\ndpdk目录下有一个大的Makefile，嵌套引用各个下级模块的Makefile，在这个文件里面添加一行对于test模块Makefile的引用。\n```makefile\nSRCS-y += $(IOT_SRC_DIR)/main.c\nCFLAGS += -I$(IOT_SRC_DIR)\n\ninclude $(IOT_SRC_DIR)/nac/Makefile\ninclude $(IOT_SRC_DIR)/dac/Makefile\ninclude $(IOT_SRC_DIR)/ecm/Makefile\ninclude $(IOT_SRC_DIR)/ddm/Makefile\ninclude $(IOT_SRC_DIR)/tid/Makefile\ninclude $(IOT_SRC_DIR)/api/Makefile\ninclude $(IOT_SRC_DIR)/dsm/Makefile\ninclude $(IOT_SRC_DIR)/lic/Makefile\ninclude $(IOT_SRC_DIR)/test/Makefile\ninclude $(SRC_FWD_DIR)/Makefile\n```\n## 拷贝test目录\n执行`quick.sh`编译的时候，报错`/opt/iot/SmartSecuri-Platform/trunk/app/src/fwd/test/Makefile`出错。因为之前将test目录放在dpdk下面，而platform里面的fwd没有test目录，所以需要执行一次拷贝工作。`cp -r test /opt/iot/SmartSecuri-Platform/trunk/app/src/fwd/`。\n\n## 修改`module.info`\n`vim /SPG/bin/fwd/module.info`添加自己增加的新模块。\n```\n1 tid\n2 api\n3 ddi\n4 dac\n5 test\n```\n注意，这里模块前面的序号并不是之前`module_id_e`中的模块ID。\n## 修改start_fwd.sh\n这个脚本里面有个函数`start_fwd`，决定程序运行的结果是输出到哪里。\n默认情况下是将输出重定向到一个文件中去了，所以运行时在终端看不到信息输出。将这个函数的第五行修改为`./$APP_NAME -c $mask -- -s $FWD_CLI_FILE_NAME  &`，这样就是将运行结果重定向到标准输出中，即电脑屏幕。\n这样，就能在屏幕上看到新模块输出语句的输出了。\n\n\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/24/DPDP模块开发指南/","categories":[],"tags":[{"name":"smart","slug":"smart","permalink":"http://yoursite.com/tags/smart/"}]},{"title":"Json","date":"2019-07-23T02:04:37.023Z","path":"2019/07/23/json/","raw":"---\ntitle: Json\ntags:\n- json\n- 库函数\n---\n<font color=\"red\">2019-07-23</font>\n\nC语言没有字典这样的结构，所以对于解析`json`格式的数据来说不是那么好解析，但是有时候又需要处理这样的数据格式。有一个解析`json`的函数库可以使用，就是`cJSON`。\n\n[点此下载后可以直接使用](https://files.cnblogs.com/files/piaoyang/cJSONFiles.rar)\n\n自己使用时只需要其中的`cJSON.c`和`cJSON.h`文件就可以了，只需要将cJSON和自己的main文件一起编译即可。\n# cJSON 结构体：\n```cpp\ntypedef struct cJSON {\n　　struct cJSON *next,*prev;      /* 遍历数组或对象链的前向或后向链表指针*/\n　　struct cJSON *child;                   /*数组或对象的孩子节点*/\n　　int type;                              /* key的类型*/\n　　char *valuestring;                     /*字符串值*/\n　　int valueint;                          /* 整数值*/\n　　double valuedouble;                    /* 浮点数值*/\n　　char *string;                          /* key的名字*/\n} cJSON;\n```\n`cJSON`是使用链表来存储数据的，每一个节点可以有兄弟节点，通过`next/prev`指针来查找，它类似双向链表。每个节点也可以有孩子节点，通过`child`指针来访问，进入下一层。只有节点是对象或数组时才可以有孩子节点。\n\n`type`是键（key）的类型，一共有7种取值，分别是：`False，Ture，NULL，Number，String，Array，Object`。\n\n若是Number类型，则`valueint`或`valuedouble`中存储着值。若期望的是int，则访问`valueint`，若期望的是double，则访问`valuedouble`，可以得到值。\n\n若是String类型的，则`valuestring`中存储着值，可以访问`valuestring`得到值。\n\n`string`字符串中存放的是这个节点的名字，可理解为key的名称。\n\n# 重要的接口函数\n\n`cJSON *cJSON_Parse(const char *value);`\n解析JSON数据包，并按照cJSON结构体的结构序列化整个数据包。可以看做是获取一个`cJson`结构体的句柄。\n\n`cJSON *cJSON_GetObjectItem(cJSON *object,const char *string);`\n获取`json`指定的对象成员。`*object`是第一个函数中获取的句柄。`string`是需要获取的对象。\n\n`cJSON *cJSON_GetArrayItem(cJSON *array,int item);`\n有可能第二个函数中获取到的是成员对象值是一个数组，那么就需要用到这个函数。用来获取这个数组指定的下标对象。`*array`是传入第二步中返回的值，`item`是想要获取这个数组的下标元素。返回值是这个数组中指定下标的对象。然后在对这个返回值重复使用第二步函数就可以获取到各个成员的值了。\n\n`cJSON_Delete()`\n用来释放你第一步获取的结构体句柄，来释放整个内存。用在解析完后调用。\n# 实例\n```json\n{\"syslog_db:[{\"db_user\":\"xxx\",\n\"db_password\":\"yyy\",\n\"db_type\":\"ORACLE\",\n\"db_ip\":\"172.16.1.248\",\n\"db_port\":\"1521\",\n\"db_name\":\"orcl\",\n\"sql\":\"select * from syslog\"}]，\n\"syslog_source\":[{\"send_ip\":\"172.0.0.8\",\n\"send_port\":\"8\",\n\"send_protocal\":\"TCP\"}],\n\"syslog_enable\":\"1\"\n}\n```\n该`json`数据中共有三个键值对，`syslog_db`对应的值是一个数组，数组中只有一个元素（小`json`数据）,`yslog_source`对应的也是只有一个小`json`素的数组。\n\n```cpp\n#include <stdio.h>\n#include \"cJSON.h\"\n\nint main() {\n    FILE            *fp = NULL;\n    cJSON           *json;\n    char            *out;\n    char            line[1024] = {0};\n\n    if(NULL != (fp = fopen(\"./test.ply\", \"r\"))) {\n        while (NULL != fgets(line, sizeof(line), fp)) {\n            json=cJSON_Parse(line); //获取整个大的句柄\n            \n            out=cJSON_Print(json);  //这个是可以输出的。为获取的整个json的值\n            printf(\"%s\\n\",*out);\n            free(out);\n            \n            cJSON *arrayItem = cJSON_GetObjectItem(json,\"syslog_db\"); //获取这个对象成员\n            cJSON *object = cJSON_GetArrayItem(arrayItem,0);   //因为这个对象是个数组获取，且只有一个元素所以写下标为0获取\n            \n　　　　　　　 /*下面就是可以重复使用cJSON_GetObjectItem来获取每个成员的值了*/\n            cJSON *item = cJSON_GetObjectItem(object,\"db_user\");  //\n            printf(\"db_user:%s\\n\",item->valuestring);\n\n            item = cJSON_GetObjectItem(object,\"db_password\");\n            printf(\"db_password:%s\\n\",item->valuestring);\n\n            item = cJSON_GetObjectItem(object,\"db_type\");\n            printf(\"db_type:%s\\n\",item->valuestring);\n\n            item = cJSON_GetObjectItem(object,\"db_ip\");\n            printf(\"db_ip:%s\\n\",item->valuestring);\n\n            item = cJSON_GetObjectItem(object,\"db_port\");\n            printf(\"db_port:%s\\n\",item->valuestring);\n\n            item = cJSON_GetObjectItem(object,\"db_name\");\n            printf(\"db_name:%s\\n\",item->valuestring);\n\n            item = cJSON_GetObjectItem(object,\"sql\");\n            printf(\"db_sql:%s\\n\",item->valuestring);\n        \n\n　　　　　　　/*这里这个是直接可以获取值的*/\n            arrayItem = cJSON_GetObjectItem(json,\"syslog_enable\");\n            printf(\"%s\\n\",arrayItem->valuestring);\n        }\n    }\n        cJSON_Delete(json)；\n    close(fp);\n}\n```\n [C语言cJSON库的使用，解析json数据格式](https://www.cnblogs.com/piaoyang/p/9274925.html)\n\n注意：\n1. `cJSON_Parse`生成的`cJSON`对象，由调用者使用`cJSON_Delete`来释放。\n生成`cSJON`对象后，使用了`cJSON_AddItemToObject`/ `cJSON_AddItemToArray`等函数将其加入了另一个更大的`cJSON`对象，那么在释放这个更大的对象时会递归释放。\n2. `cJSON_Print`/ `cJSON_PrintUnformatted`返回的char指针，由调用者使用`free`释放。\n","comments":true,"permalink":"http://yoursite.com/2019/07/23/json/","categories":[],"tags":[{"name":"库函数","slug":"库函数","permalink":"http://yoursite.com/tags/库函数/"},{"name":"json","slug":"json","permalink":"http://yoursite.com/tags/json/"}]},{"title":"Smart","date":"2019-07-23T02:04:36.902Z","path":"2019/07/23/smart/","raw":"---\ntitle: Smart\ntags:\n- smart\n- dpdk\n- Makefile\n---\n<font color=\"red\">2019-07-22</font>\n# 代码存放目录\n公司的代码文件的存放目录，一个是在`E:\\iot\\SmartSecuri-Platform\\trunk\\app\\src`下，其中`E:\\iot\\SmartSecuri-Platform\\trunk\\app\\src\\fwd\\mmu`下有`module_example.c`和`module_example.h`，可以按照这两个文件的样式，自己在写一些模块进去。\n\n# 代码加解密\n因为电脑上安装的防泄密客户端软件，所以从SVN上面下载的代码都是加密过的代码。加密过的代码，用记事本打不开，而用source insight和notepad++可以打开。将这样的加密过的代码，通过winSCP放到设备上，用vim命令打开也是乱码。\n\n本地用source insight新建的代码文件，用记事本也是打不开，应该是自动被加密了。\n\n第一次在设备上执行`quick.sh`搭建编译环境没有问题，是因为那时设备上的代码不是从SVN上面下载的。\n之后从SVN上面下载的代码存放在本地，修改过后放到设备上，把设备上同名的非SVN代码替换掉了。因此，现在设备上的该文件来源于SVN，是加密的，所以这一次执行`quick.sh`失败了。\n\n# dpdk编译打包\n在`E:\\iot\\SmartSecuri-IoT\\trunk\\gateway\\src\\dpdk`目录下保存有项目程序文件和各个功能模块的代码。\n## 包的构建\n采用一键编译打包方式来编译dpdk项目程序，执行quick.sh去调用相应的makefile就能进行编译，并将编译好的二进制文件压缩打包成linux.tar.gz。\n\n在每个功能模块的目录下都写一个makefile，采用大makefile嵌套小makefile的模式去做编译。\n\n因为dpdk库与设备的硬件有关系（cpu指令集），不同的硬件就需要单独编译一套dpdk库，因为我们不会更改dpdk的库，所以同一种硬件型号的设备只需编译一次，不会出现每次出版本时都去各种型号单独编译出包的问题。\n\nquick.sh在每次编译业务程序时会去链接相应硬件型号下编译的dpdk库生成相应硬件型号的二进制程序，所以用一台机器就能编译出所有不同硬件型号的二进制可执行文件。同样在安装部署时也会根据当前的设备型号去启动相应型号的二进制程序。\n\n根据脚本的入参去编译对应型号的dpdk二进制文件，不带参数则是编译所有型号的dpdk二进制文件，参数是某个版本型号（比如：:mini、CSG600）则就去编译基于该硬件型号的版本及管理模块。\n\n## 一键编译quick.sh\nquick.sh编译的具体流程：\n（1）做编译入参检查\n（2）清理相关目标文件\n（3）拷贝adaptor目录下的对应文件到opensource目录下\n（4）然后去嵌套调用其他各个模块里的makefile编译业务代码，比如fwd模块、smm模块。\n（5）将生成的二进制可执行文件进行压缩打包。\n\n可以通过执行`./quick.sh help`打印编译帮助信息，编译入参输入错误也会有错误提示信息，后期可以直接在`quick.sh`中扩充。\n\n```\n# dpdk安装\n## install_dpdk.sh\n适配`install_Smartsecuri.sh`脚本，调用dpdk的`install_dpdk.sh`启动脚本去实现dpdk的部署安装。\nDpdk的安装脚本`install_dpdk.sh`主要包含解析网络配置、做绑dpdk驱动、分配大页缓存、生成cli配置文件、启动二进制、配网络。\n## cli配置\nPipeline可以理解为管道，从收包到发包都是在一个链中，我们的业务（黑白名单、准入、威胁识别、应用识别等）就相当于管道中的一道道滤网，滤网按照优先级顺序串行在管道中，管道中的的数据包会依次经过各个滤网。而pipeline的启动依赖于cli配置文件。\n\ncli配置文件里主要是内存池初始化配置信息、端口初始化配置信息（队列数、混杂模式配置等）、pipeline之间通信用的SWQ初始化信息、pipeline核绑定信息、pipeline与网口的绑定信息、pipeline规则匹配信息。\n","comments":true,"permalink":"http://yoursite.com/2019/07/23/smart/","categories":[],"tags":[{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"},{"name":"smart","slug":"smart","permalink":"http://yoursite.com/tags/smart/"},{"name":"dpdk","slug":"dpdk","permalink":"http://yoursite.com/tags/dpdk/"}]},{"title":"DPDK","date":"2019-07-23T02:04:36.839Z","path":"2019/07/23/dpdk/","raw":"---\ntitle: DPDK\ntags:\n- dpdk\n---\n<font color=\"red\">2019-07-22</font>\nIntel® DPDK 全称 __Intel Data Plane Development Kit__，是intel提供的数据平面开发工具集，为Intel architecture（IA）处理器架构下用户空间高效的数据包处理提供库函数和驱动的支持，它不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理。其工作在用户层，取代传统Linux系统中的网络数据报文处理。\n\n因此，任何基于DPDK的应用开发都需要自建协议栈，或者使用基于DPDK的协议栈。目前比较有名的基于DPDK的协议栈有MTCP，DPDK-ANS等。\n\n![enter image description here](https://upload-images.jianshu.io/upload_images/5127279-87fce06587da7a7f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)\n\n但是，海量数据下中断是否真的有效吗？我们真的需要所有的协议栈吗？内核态用户态的内存拷贝是否可以避免，epoll模型是否有更好的替代？\n\n# 中断与轮询\n随着网络接口带宽从千兆到万兆，每一个报文都会触发一次中断的开销是巨大的。NAPI机制是一种解决这个问题的方法之一，它的核心概念就是不采用中断的方式读取数据，而代之以首先采用中断唤醒数据接收的服务程序，然后在使用轮询的方式一次性处理多个数据，直到网卡接收队列为空才继续打开中断。DAPI有一个极大的缺陷，它只适合大量的小数据，在数据大小过大时（即使使用DMA），会退化成中断模式。\n\nDPDK 则使用纯轮询模式去解决这个问题，收发包不使用任何中断，但这不意味着DPDK不支持中断，毕竟实际应用中，存在网络的潮汐效应，低潮期轮询势必产生内核空转。因此DPDK同时也支持类似NAPI的机制，用户可以配置何时关闭中断，何时轮询结束等等。例如，在2张网卡的机器上，一般推荐，DPDK独占4个逻辑核。如果这不能接受，就可以考虑混合中断轮询的机制。\n\n# 用户态驱动\nLinux 中传统的 I/O 操作是一种缓冲 I/O，I/O 过程中产生的数据传输通常需要在用户态和内核态之间进行多次的拷贝操作。在某些情况下，这些数据拷贝操作会极大地降低数据传输的性能。应运而生的是一种叫做零拷贝的技术，采用直接IO，mmap／sendfile，写时复制等一系列策略，尽量避免 CPU 将数据从一块存储拷贝到另外一块存储，篇幅有限，这里不做过多阐述。\n\n我们注意到，尽管DPDK实现的是Linux内核的功能，但是DPDK依旧是工作在用户态中的。应用数据通过DPDK传输是完全可以避免相互拷贝的。DPDK的包全部在用户空间，使用mbuf内存池管理。DPDK空间与应用层空间的内存交换不需要拷贝，只需要做控制权转移。\n\n# Pipeline 模型\nPipe Line模型主要思想是将不同的工作交给不同的模块，每一个模块只处理特定的事务。每个模块都有输入输出，通过这些输入输出将这些模块连接起来。特别的，这些模块可以位于同一个逻辑核上，也可以处于不同的逻辑核上，这依赖不同的业务实现逻辑了。这样，我们基于DPDK可以实现更复杂的业务逻辑。但尽管不同的逻辑核之间使用无锁队列来交换数据，多核之间依然存在Cache一致性的问题。但是相对的，这个模型可以充分利用物理机器的计算资源。\n\n[绝对干货！初学者也能看懂的DPDK解析](https://www.jianshu.com/p/f62108e41c7f)\n\n[简单的DPDK介绍与分析](https://yq.aliyun.com/articles/594703)\n","comments":true,"permalink":"http://yoursite.com/2019/07/23/dpdk/","categories":[],"tags":[{"name":"dpdk","slug":"dpdk","permalink":"http://yoursite.com/tags/dpdk/"}]},{"title":"编码命名风格规范","date":"2019-07-23T02:04:36.206Z","path":"2019/07/23/编码命名风格规范/","raw":"---\ntitle: 编码命名风格规范\ntags:\n- smart\n---\n<font color=\"red\">2019-07-22</font>\n# 变量命名\n变量 (包括函数参数)使用驼峰命名法，以变量的属性开头。\n属性部分: \n|含义|英文缩写|\n|:------:|:--------:|\n|全局变量 |g_ |\n|常量 |c_ |\n|静态变量 |s_|\n\n类型部分:\n|含义|英文缩写|\n|:------:|:--------:|\n|指针 |p| \n|函数 |fn| \n|函数指针|pf|\n|结构体 |st |\n|数组|a|\n|长整型| l| \n|布尔 |b |\n|浮点型（有时也指文件） |f|\n|双字 |dw|\n|字符串 |sz| \n|短整型 |n |\n|双精度浮点 |d |\n|计数 |c|\n|字符 |ch|\n|整型 |i| \n|字节 |by| \n|字 |w |\n|实型 |r |\n|无符号 |u|\n\n# 文件命名\n```cpp\nvgp_module_def.h\n```\n# 类型命名\n所有类型命名 —— 结构体, 类型定义 (typedef), 枚举，均使用相同约定, 即以全部使用小写字母, 可以包含下划线，并以下划线加类型（结构体\"\\_t\"，枚举\"\\_e\"）结尾。\n结构体：\n```cpp\ntypedef struct tag_module_info_t\n{\n    \n}module_info_t;\n```\n\n# 函数命名\n常规函数使用小写与下划线组合，\"模块名_\"开头。\n```cpp\nVOS_INT32 vgp_module_init_register(VOS_VOID)\n{\n}\n```\n\n# 枚举命名\n```cpp\ntypedef enum tag_module_id_e\n{\n    MODULE_ID_SND       = 0,   \n    MODULE_ID_BLC,\n    MODULE_ID_WLM,\n    MODULE_ID_EXAMPLE,\n    MODULE_ID_DAC,\n    MODULE_ID_DDI,\n    MODULE_ID_TID,\t\n    MODULE_ID_API,\n\tMODULE_ID_DSM,\n\tMODULE_ID_ECM,\t\n\tMODULE_ID_NAC,\n\tMODULE_ID_LIC,\n    MODULE_ID_MAX\n}module_id_e;\n```\n枚举的名称采用大写。\n\n# 宏命名\n宏命名采用大写与下划线组合的方式。\n```cpp\n#define VGP_MODULE_NAME_LEN 8\n#define VGP_MODULE_SN_LEN_MAX 32\n```\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/23/编码命名风格规范/","categories":[],"tags":[{"name":"smart","slug":"smart","permalink":"http://yoursite.com/tags/smart/"}]},{"title":"C/C++基础","date":"2019-07-19T13:27:06.908Z","path":"2019/07/19/CC++基础/","raw":"---\ntitle: C/C++基础\ntags:\n- C/C++\n- 库函数\n- 指针\n---\n==2019-07-18更新==\n# typedef\n## typedef 为结构体类型起别名\n![enter image description here](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=1015753163,2288355968&fm=173&app=49&f=JPEG?w=306&h=109&s=C11280398F706C0346CC58DE0000D0B0)\n![enter image description here](https://ss2.baidu.com/6ONYsjip0QIZ8tyhnq/it/u=2212358588,2513211965&fm=173&app=49&f=JPEG?w=294&h=117&s=CB40C0189FE04D0344455CDC020050B0)\n\n## typedef 为变量类型起别名\n```cpp\ntypedef unsigned char VOS_UINT8;\ntypedef unsigned short VOS_UINT16;\ntypedef unsigned int VOS_UINT32;\ntypedef unsigned long VOS_UINT64; \n```\n[C语言之类型定义（typedef）](https://baijiahao.baidu.com/s?id=1623094778202042724&wfr=spider&for=pc)\n\n# union 测试系统大小端\n大端模式(Big_endian):数据的高字节存储在低地址中,数据的低字节存放在高地址中。\n小端模式(Little_endian):数据的高字节存储在高地址中,数据的低字节存放在低地址中。\n\nUnion 的特性是同一时刻只有一个成员有效，且所有的成员有一个相同的开始地址。联合体的访问不论对哪个变量的存取都是从 union 的首地址位置开始，所以可以用union来测试系统的大小端。\n\n当`test.i＝1`时，数据是00000000，00000000，00000000，00000001\n大端模式的话，00000001是数据的低位，存储在高位字节中，存储如下，00000000，00000000，00000000，00000001，此时读取`test.c`，读取存储空间的第一个字节就是0，所以test.c＝0说明是大端。\n\n小端模式的存储如下，00000001，00000000，00000000，00000000，读取第一个字节就是1。所以`test.c＝1`就是小端存储。\n```cpp\nint main()\n{\n\tunion\n\t{\n\t\tint i;\n\t\tchar c;\n\t}test;\n\ttest.i=1;\n\tif(test.c)  cout<<\"小端\\n\";\n\telse cout<<\"大端\\n\";\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n[union 判断系统大小端存储方式](https://blog.csdn.net/AH20180324/article/details/89006055)\n\n# 结构体中为成员指定占用空间大小\n```cpp\ntypedef struct tagIpHdr {\n\n\tVOS_UINT8 bitIpHdrLen:4;\n\tVOS_UINT8 bitIpVer:4;\n\tVOS_UINT8 ucTos;\n\tVOS_UINT16 usTotLen;\n    \n\tVOS_UINT16 usId;\n\tVOS_UINT16 usFragOff;\n    \n\tVOS_UINT8 ucTtl;\n\tVOS_UINT8 ucProtocol;\n\tVOS_UINT16 usCheckSum;\n    \n\tVOS_UINT32 uiSrcAddr;\n\tVOS_UINT32 uiDstAddr;\n}IP_HDR_S;\n```\n`VOS_UINT8 bitIpVer:4;`这个语句表示变量`bitIpVer`占用的空间为4bit。`VOS_UINT8`实际上是`unsigned int`占用4字节，32位，而该类型的变量`bitIpVer`实际所用的空间不用这么大，只需要4bit就够了。\n[定义结构体时变量名后的冒号和数字](https://blog.csdn.net/chrisniu1984/article/details/6620566)\n\n# 动态内存分配\n## C\n[隐式声明与内建函数malloc不兼容](https://blog.csdn.net/u014062332/article/details/48490377)\n```cpp\nvoid *malloc(unsigned int size)  //malloc函数原型\nchar* p=(char*)malloc(10)  //分配10个字节大小的内存空间\n\nvoid *calloc(unsigned int num, unsigned int size)  //calloc函数原型\nint* p=(int*)calloc(5,sizeof(int));  //分配5个int大小的内存空间\n\nvoid free(void *ptr)  //释放函数的原型\nfree(p)   //由编译器自动对指针类型进行强转\n```\nC语言申请了一块动态分配的内存之后，可以和`memcpy`连用来将一些东西拷贝到这个内存里面来。\n## C++\n```cpp\nint* p=new int;     //申请单个变量\nint* q=new int[5]   //申请动态数组\ndelete p;\ndelete []q;\n\nTest* p=new Test;    //申请单个对象\ndelete p;\n\nTest* f[3] = {new Test(2),new Test}; //指针数组，多出的一个是空指针\nTest* g[3] = {new Test(2),new Test,NULL};\ndelete f[1];     //数组中的每一个指针都要delete掉\ndelete f[2];\ndelete f[3];\n\nTest* h = new Test[2]{4,6}; //数组指针\ndelete []h;\n```\n[C和C++动态内存分配和释放的区别](https://blog.csdn.net/everestrs/article/details/83314811)\n\n# Memcpy内存拷贝\n`void *memcpy(void *dest, const void *src, size_t n);`从src的开始位置拷贝n个字节的数据到dest。如果dest存在数据，将会被覆盖。memcpy函数定义在string.h头文件里。\n## 将数据拷贝到内存\n```cpp\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define N 10\nint main()\n{\n    char str[15]=\"shen cheng yu\";\n    char* p=(char*)malloc(sizeof(char)*N);\n    memcpy(p,str,8);\n    puts(p);\n    printf(\"123\");\n    printf(\"   456\");\n    free(p);\n    return 0;\n}\n```\n程序输出：\n```cpp\nshen che\n123   456[root@SmartSPG6300 xtncsg]# \n```\n## 将数据拷贝到内存中的指定位置\n```cpp\n#define N 10\nint main()\n{\n    char* p=(char*)malloc(sizeof(char)*N);\n    for (int i=0;i<10;i++){\n        memcpy(p+i,\"a\",strlen(\"a\"));\n    }\n    puts(p);\n    free(p);\n    return 0;\n}\n```\n## 覆盖原有的内存内容\n```cpp\n#define N 10\nint main()\n{\n    char* p=(char*)malloc(sizeof(char)*N);\n    for (int i=0;i<10;i++){\n        memcpy(p+i,\"a\",strlen(\"a\"));\n    }\n    puts(p);\n    memcpy(p,\"12345\",strlen(\"12345\"));\n    puts(p);\n\n    memcpy(p+5,\"67890\",strlen(\"67890\"));\n    puts(p);\n    free(p);\n    return 0;\n}\n```\n输出：\n```cpp\naaaaaaaaaa\n12345aaaaa\n1234567890\n```\n[C语言memcpy函数的用法](https://blog.csdn.net/e_one/article/details/80676166)\n\n# puts()与gets()\n## puts()\nputs()函数只能输出字符串, 不能输出数值或进行格式变换，里面的参数可以直接是字符串或者是存放字符串的字符数组名。puts在输出字符串后会自动输出一个回车符。以`将数据拷贝到内存`为例，可以看出。\n[c语言中，puts和printf函数有什么区别？](https://zhidao.baidu.com/question/1894679339010427020.html)\n\n## gets()与puts()区别\ngets()是输出一个字符串指针所指向的字符串。用来读入一行字符，包括空格，遇到回车结束输入。\nputs()是用来输出一个字符串指针所指向的字符串。\n```cpp\nint main(){\n    const char* s=\"hello world\";\n\n    char tmp[100];\n    gets(tmp);\n\n    puts(s+5);   //puts()从该指针的位置开始向后输出\n    puts(tmp);\n\n    return 0;\n}\n```\ngets()要接收字符数组名，或者有明确指向的字符数组指针。不能`char* s;  gets(s);`这样的话，s没有明确的指向，是一个野指针。可以`char* s;  char t[100];  s=t;  gets(s);`这样s就有明确的指向了。\n[C语言高手求助char *s;gets(s);这样是对还是](https://zhidao.baidu.com/question/226027657.html)\n\n\n==2019-07-19更新==\n# 基于范围的for循环\n编译时注意要使g++包含C++11的标准。即`g++ 11.cpp -o 11.exe -std=c++11`。对于内置数组以及包含方法begin()和end()的类（如std::string)和STL容器，基于范围的for循环可以简化为他们编写循环的工作。\n```cpp\nint main(){\n    vector<int>v(6);\n    for(auto &x:v){  \n        x=rand()%10;\n    }\n    for(int i:v){\n        cout<<i<<\" \";\n    }\n    return 0;\n}\n```\n如上例，在循环中修改数组或容器中的每个元素，要使用引用类型。x是容器v中某个元素的引用，`int& x=v[i]`，因此对x进行修改也就是修改了容器v中的值。\n\n# 随机函数\n## rand()函数\n```cpp\n//rand()函数返回0~RAND_MAX之间的一个整数。\nint a = rand();  //产生一个随机数\nint b = rand() % 10;   //产生一个0-9之间的随机数\nint c = rand() % 10 + 1   //产生一个1-10之间的随机数\ndouble=(rand() % 10) / 10;  //产生一个一位小数\nsrand((int)time(0))  //以系统时间作为随机数种子，包含在ctime头文件下面  \n```\n不设随机数种子的话，当前执行程序与下一次运行程序时得到的随机数会是一样的。\n\n# sizeof()与strlen()\n```cpp\nint fun(const char* str){\n\treturn sizeof(str);\n}\n\nint main(){\n\tchar s[20]=\"hello world\";\n\tcout<<strlen(s)<<\" \"<<sizeof(s)<<endl;   //11  20\n\n\tconst char* t=\"hello\";\n\tcout<<sizeof(t)<<\" \"<<fun(t)<<endl;   //8 8\n\n\tchar m[]=\"hello?\";\n\tcout<<strlen(m)<<\" \"<<sizeof(m)<<endl;   //6  7\n\t\n    //字符数组的初始化一次性赋值，也可以逐个赋值。可以指定数组的大小，也可以不指定数组长度。\n\tchar str1[]={'h','e','l','l','o'};    \n\tchar str2[]={'h','e','l','l','o','\\0'};\n\tputs(str1);                     //hello\n\tputs(str2);                     //hello\n\tcout<<strlen(str1)<<\" \"<<strlen(str2)<<endl;   //5  5\n\tcout<<sizeof(str1)<<\" \"<<sizeof(str2)<<endl;   //5  6\n\n\treturn 0;\n}\n```\n`strlen`是函数，在运行时确定字符数组的长度。`sizeof()`是运算符，在编译时确定变量或者数据类型的字节大小。\n[sizeof与strlen的区别](https://zhidao.baidu.com/question/530532720.html?word=strlen%E4%B8%8Esizeof%E5%8C%BA%E5%88%AB)\n`strlen()`碰到`'\\0'`就结束，所以`tsr1[]`和`str2[]`都是5。\n字符数组逐个赋值之后，赋值的是什么，实际存储的就是什么，所以`str1[]`和`str2[]`分别占用了5，6个字节。\n\n# 字符数组结尾\n字符数组末尾以`'\\0'`或者`0`结束。字符'`\\0'`的ASCII码就是0。\n```cpp\nint main(){\n    char s[10];\n    memcpy(s,\"hello\",strlen(\"hello\"));\n    s[strlen(\"hello\")]=0;\n    puts(s);\n    return 0;\n}\n```\n\n# 枚举\n枚举的定义：\n```cpp\nenum nations{wei,shu,wu}; //枚举类型中第一个名字的值默认为0，后面的名字的值依次加1\n\nenum nations{wei=228,shu=229,wu=230};  //为枚举中每一个名字都赋值\n\nenum nations{wei=228,shu,wu};   //只为枚举中第一个名字赋初值 \n\nenum nations{wei=228,shu,wu=230};   //shu这个名字对应的值是229\n\nenum nations{wei=228,shu,wu=230};\nenum nations nation,country;  //先定义枚举，后定义枚举类型的变量\n\nenum nations{wei=228,shu,wu=230}nation;  //定义枚举的同时定义变量\n\nenum nations{wei=228,shu,wu=230}nation=wei,country=shu;  //定义变量的同时为变量赋初值\n```\n```cpp\nint main(){\n    enum nations{wei=225,shu,wu=6}nation;\n    scanf(\"%d\",&nation);\n    switch(nation){\n        case wei:printf(\"wei\\n\");break;\n        case shu:printf(\"shu\\n\");break;\n        case wu:printf(\"wu\\n\");break;\n        default:printf(\"error\\n\");\n    }\n    return 0;\n}\n```\n枚举列表中的名字（wei,shu,wu）的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。\n\n枚举列表中的名字都是常量，而不是变量。不能对它们赋值，只能将它们的值赋给其他的变量。\n\n枚举和宏非常类似。宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。\n\n名字都不是变量，所以不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用`&`取得它们的地址。这就是枚举的本质。\n\n`case`关键字后面必须是一个整数，或者是结果为整数的表达式，不能包含任何变量。正是由于 这些名字最终会被替换成一个整数，所以它们才能放在 `case` 后面。\n\n枚举类型占据字节大小：\n```cpp\nenum nations{wei=12,shu,wu}nation=shu;\n    cout<<sizeof(nations)<<\" \"<<sizeof(wei)<<\" \"<<sizeof(nation)<<\" \"<<sizeof(int)<<endl;\n```\n`4 4 4 4`都和int型占据相同大小的字节。\n[C语言枚举类型（C语言enum用法）详解](http://c.biancheng.net/view/2034.html)\n\n# memset\n每种类型的变量都有各自的初始化方法，memset() 函数可以说是初始化内存的“万能函数”，通常为新申请的内存进行初始化工作。\n函数原型为：\n```cpp\n# include <string.h>\nvoid *memset(void *dst_str, int avlue, unsigned long n);\n```\n指针变量 `dst_str` 所指向的前 n 字节的内存单元用一个“整数” value 替换，注意 value 是 int 型。`dst_str` 是 void* 型的指针变量，所以它可以为任何类型的数据进行初始化。\n\nmemset() 的作用是在一段内存块中填充某个给定的值。因为它只能填充一个值，所以该函数的初始化为原始初始化。用memset初始化完后，后面程序中再向该内存空间中存放需要的数据。\n\nmemset 一般使用“0”初始化内存单元，而且通常是给数组或结构体进行初始化。虽然数组也可以直接进行初始化，但 memset 是对较大的数组或结构体进行清零初始化的最快方法，因为它是直接对内存进行操作的。在 memset 中初始化为 0 也具有结束标志符 '\\0' 的作用。\n\nmemset 函数的第三个参数 n 的值一般用 sizeof()  获取，这样比较专业。注意，如果是对指针变量所指向的内存单元进行清零初始化，那么一定要先对这个指针变量进行初始化，即一定要先让它指向某个有效的地址。而且用memset给指针变量如p所指向的内存单元进行初始化时，n 千万不要写成 sizeof(p)。\n```cpp\nint main(){\n    char str[10];\n    char* p=str;\n    memset(str,0,sizeof(str));\n    for(int i=0;i<10;i++){\n        printf(\"%d\\t\",str[i]);\n    }\n    return 0;\n}\n```\n不同的memset()参数，得到的结果也不同。\n```cpp\n memset(str,0,sizeof(str));  \n 0 0 0 0 0 0 0 0 0 0\n\nmemset(str,0,sizeof(p));\n0 0 0 0 0 0 0 0 80 5\n\nmemset(str,0,sizeof(*p));  //*p 是一个char型的字符。\n0 6 64 0 0 0 0 0 0 5\n```\n其中，目标字符串中写`str`和`p`效果是等价的。\n[memset函数及其用法，C语言memset函数详解](http://c.biancheng.net/view/231.html)\n\n# snprintf()函数\n这个函数与输出无关，它实际上起着字符串拷贝的作用。\n函数原型为：\n```cpp\n#include<stdio.h>\nint snprintf(char* dest_str,size,const char* format,...);\n```\n先将可变参数 “…” 按照format的格式格式化为字符串，然后再将其拷贝至dest_str中。最多只能拷贝过去size个字节。\n如果格式化后的字符串长度小于size，则将字符串全部拷贝至dest_str中，并在字符串结尾处加上‘\\0’；。\n如果格式化后的字符串长度大于或等于size，则将字符串的(size-1)拷贝至dest_str中，然后在字符串结尾处加上’\\0’.。\n成功返回源串的长度，失败则返回负值。\n\n因为最多只能拷贝size个字节过去，所以将`dst_str`的大小设置为size就不会有越界问题。如`dst_str`的大小是10个字节，则最多只能拷贝9个字节过来，留一个用来拷贝完成之后放`'\\0'`。\n\n```cpp\nint main(){\n\n    char dest_str[1024];\n    memset(dest_str,0,sizeof(dest_str));\n\n    const char *src = \"Linux C程序设计\";\n    int size = strlen(src);\n    int year = 2019;\n    int month = 7;\n    int day = 19;\n\n    int nReturn = snprintf(dest_str,sizeof(dest_str),\"字符串:%s\\n长度是:%d\\n今天是:%d年%d月%d日\\n\",src,size,year,month\n,day);\n\n    printf(\"%d\\n\",nReturn);\n    printf(\"%s\",dest_str);  \n\n    return 0;  \n}  \n```\n[C中 snprintf()函数的作用](https://blog.csdn.net/qq_34707315/article/details/77895735)\n\n# 函数指针与typedef\n\n```cpp\n#include<iostream>\nusing namespace std;\nvoid add(int a,int b){cout<<a+b<<endl;}\nint main(){\n    void (*pAdd)(int,int);\n    pAdd=add;\n    (*pAdd)(2,2);\n    pAdd(3,3);\n\n    typedef void (*pAdd_1)(int,int);\n    pAdd_1 tmp;\n    tmp=add;\n    tmp(4,4);\n    (*tmp)(5,5);\n    return 0;\n}\n```\n`void (*pAdd)(int,int);`函数指针的写法。\n`(*pAdd)(2,2);`显式地调用，*Add就是该函数指针所指向的那个函数。\n`pAdd(3,3);`隐式的调用。\n\n` typedef void (*pAdd_1)(int,int);`typedef后面接函数指针的写法。\n定义了一个 数据类型，叫做pAdd_1，这个数据类型是一种函数指针。`pAdd_1 tmp;`通过数据类型定义变量，tmp是一个函数指针，然后将已经写好的函数赋值给这个函数指针。\n[typedef函数指针用法](https://blog.csdn.net/qll125596718/article/details/6891881)\n\n# strncpy()函数\n## strncpy()的使用\n函数原型：\n```cpp\nchar * strncpy ( char * destination, const char * source, size_t num );\n```\nstrcpy (dst,src): 从源串的开始到结尾（'\\0')完全拷贝到目标串地址，而strncpy()则可以指定拷贝的长度。\n\n从src串中拷贝num个字符到dst所指向的一串内存空间。\n如果src不够num个字符，则在目标串最后再追加`'\\0'`，使得正好拷贝了num个字符。\n如果src大于num个字符，则拷贝完成之后不会在最后追加隐式的`'\\0'`，这时dst就不是真正的C字符串了。读取这个字符串会导致溢出。\n官方文档的说明程序：\n```cpp\n#include <stdio.h>\n#include <string.h>\n\nint main ()\n{\n  char str1[]= \"To be or not to be\";\n  char str2[40];\n  char str3[40];\n\n  /* copy to sized buffer (overflow safe): */\n  strncpy ( str2, str1, sizeof(str2) );\n\n  /* partial copy (only 5 chars): */\n  strncpy ( str3, str2, 5 );\n  str3[5] = '\\0';   /* null character manually added */\n\n  puts (str1);\n  puts (str2);\n  puts (str3);\n\n  return 0;\n}\n```\n```cpp\nTo be or not to be\nTo be or not to be\nTo be\n```\n因为不会在目标串后面自动添加`'\\0'`，所以需要自己想办法在后面手动添加，防止读取的时候内存溢出。\n[官方strncpy](http://www.cplusplus.com/reference/cstring/strncpy/?kw=strncpy)\n```cpp\nint main ()\n{\n    char* s=(char*)malloc(5);\n    strncpy(s,\"hello world\",8);\n    puts(s);\n    return 0;\n}\n```\n输出该字符串时会在o字符后面一直找到‘\\0’才结束，因此就会出现乱码。但是这里拷贝5个字符过去却不会出现乱码？？\n## strncpy()的实现\n```cpp\nchar *strncpy(char *dest, const char *src, size_t len)  \n{  \n    assert(dest != NULL && src != NULL);  \n    char *res = dest;  \n    int offset = 0;  \n    if (strlen(src) < len)//src长度小于len  \n    {  \n        offset = len - strlen(src);  \n        len = strlen(src);  \n    }  \n  \n    while (len--)  \n    {  \n        *dest++ = *src++;  \n    }  \n    while (offset--)  \n    {  \n        *dest++ = '\\0';  \n    }  \n    return res;  \n}  \n```\n## strncpy()的内存重叠\n![enter image description here](https://img-blog.csdn.net/20170526171857016)\n如图所示，红色表示src，黄色表示dst时，正常拷贝的话，就会造成内存重叠现象。\n```cpp\nchar *strncpy(char *dst, const char *src, size_t len)  \n{  \n    assert(dst != NULL && src != NULL);  \n    char *res = dst;  \n    int offset = 0;  \n    char *tmp;  \n    if (strlen(src) < len)//src长度小于len  \n    {  \n        offset = len - strlen(src);  \n        len = strlen(src);  \n    }  \n  \n    if (dst >= src && dst <= src + len - 1)//重叠,从后向前复制  \n    {  \n        dst = dst + len - 1;  \n        src = src + len - 1;  \n        tmp = dst;  \n        while (len--)  \n            *dst-- = *src--;  \n    }  \n    else  \n    {  \n        while (len--)  \n            *dst++ = *src++;  \n        tmp = dst;  \n    }  \n    while (offset--)  \n    {  \n        *tmp++ = '\\0';  \n    }  \n    return res;  \n}  \n```\n[深入理解strncpy这个函数](https://blog.csdn.net/weibo1230123/article/details/80382614)\n\n# assert\n大多数编程语言也都有断言这一特性。断言就是对某种假设条件进行检查。在 C 语言中，断言被定义为宏的形式`（assert(expression)）`，而不是函数，其原型定义在`<assert.h>`文件中。其中，assert 将通过检查表达式 expression 的值来决定是否需要终止执行程序。也就是说，如果表达式 expression 的值为假（即为 0），那么它将首先向标准错误流 stderr 打印一条出错信息，然后再通过调用 abort 函数终止程序运行；否则，assert 无任何作用。只有当assert后面的表达式为真时，才会继续执行后面的语句。\n[C语言assert()函数用法总结](https://www.cnblogs.com/cpoint/p/3367326.html)","comments":true,"permalink":"http://yoursite.com/2019/07/19/CC++基础/","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"},{"name":"库函数","slug":"库函数","permalink":"http://yoursite.com/tags/库函数/"}]},{"title":"C/C++预处理指令","date":"2019-07-19T13:27:06.908Z","path":"2019/07/19/CC++预处理指令/","raw":"---\ntitle: C/C++预处理指令\ntags:\n- 编程\n- C/C++\n---\n==2019-07-18更新：==\n# 预处理指令\n1. \\#include包含一个源代码文件\n2. \\#define定义宏\n3. \\#undef取消已定义的宏\n4. \\#if如果给定条件为真，则编译下面代码\n5. \\#else如果#if的给定条件为假，则编译下面代码\n6. \\#ifdef如果宏已经定义，则编译下面代码\n7. \\#ifndef如果宏没有定义，则编译下面代码\n8. \\#elif如果前面的#if给定条件不为真，当前条件为真，则编译下面代码\n9. \\#endif结束一个#if……#else条件编译块\n10. \\#error停止编译并显示错误信息\n\n预处理指令是以#号开头的代码行。#后是指令关键字，整行语句构成了一条预处理指令。该指令将在编译器进行编译之前对源代码做某些转换。预处理过程还会删除程序中的注释和多余的空白字符。\n\n\\#include指令有两种方法包含头文件。第一种是用尖括号把头文件括起来。这种格式告诉预处理程序在编译器自带的或外部库的头文件中搜索被包含的头文件。第二种方法是用双引号把头文件括起来。这种格式告诉预处理程序在当前被编译的应用程序的源代码文件中搜索被包含的头文件，如果找不到，再搜索编译器自带的头文件。\n\n# 工程中使用宏来调试代码\n```cpp\n#if 0\n///< 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)\n#else\n///< 新的代码(或函数)\n#endif\n \n#ifndef JOE_DEBUG\n///< 新的代码(或函数)\n#else\n///< 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)\n#endif\n \n#ifdef Q_DEBUG\n///< 新的代码(或函数)\n#else\n///< 旧的代码(或函数) (旧的代码, 将会被预处理的时候,屏蔽掉, 不进行编译)\n#endif\n```\n通过以上类似的方法, 可以防止由于过多的修改代码, 而把代码修改的一塌糊涂. 建议修改代码的时候, 做到保护好以前的代码, 尽量不进行代码的删除操作，要养成使用宏和注释代码的习惯.。\n\n# 工程中使用宏来跨平台\n很多时候, 代码是需要跨系统平台编译和运行的. 比如: 一个小功能代码, 需要既可以在Win下面运行,  还要可以在Max, linux上面运行. 可是, 因为系统的不一样, 有些时候, 头文件的包含的名字是不一样的，比如在win下叫windows.h，在linux下叫linux.h。所以,这时候, 就是用到了宏. 因为我们使用的编程工具分不同的系统平台, 编程工具自身的环境就会包含不同平台的系统宏, 假设OS\\_Win, OS\\_Mac, OS\\_Linux 分别daibiao 三种不同的系统宏. 而且,Win版本的编程工具中已经定义了OS\\_Win, 类似同理。\n```cpp\n#ifdef OS_Win\n#include <windows.h>\n#endif\n \n#ifdef OS_Mac\n#include <mac.h>\n#endif\n \n#ifdef OS_Linux\n#include <linux.h>\n#endif\n \n/** 不仅使用在头文件的包含. 而且,对于不同的系统平台. 也可以使用不同的代码结构. */\n```\n\n# #error停止编译并显示错误信息\n一个项目的模块儿之多,源文件之大,代码之多,那么其中的宏, 也会很多. 免不了冲突定义.这时候, 我们就需要编译器能及早的告诉我们。\n```cpp\n/** 如果JOE宏没有定义,那么编译就此结束, 编译器就会显示红色的错误 */\n#ifndef JOE\n#error \"JOE is not exits\"\n#endif\n```\n[/C++预处理指令#define,#ifdef,#ifndef,#endif…](https://www.cnblogs.com/zi-xing/p/4550246.html)","comments":true,"permalink":"http://yoursite.com/2019/07/19/CC++预处理指令/","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"专业英语","date":"2019-07-19T13:27:06.908Z","path":"2019/07/19/专业英语/","raw":"---\ntitle: 专业英语\ntags: \n- 英语\n---\n\n# 英语缩略词\n\n\n|缩略词|全称|中文|\n|:-----:|:------------:|:-------------:|              \n|req|   reqiure |请求|\n|rsp|   response| 应答|\n|exp  |example | 示例|\n|prev|previous|之前的|\n|recv|recieve|获得|\n|smm|system management modual|系统管理模块|\n|nac|Network access control|网络准入控制|\n|ddi|Device discovery identification|设备发现识别|\n|fml||黑名单|\n|wlm||白名单|\n|tid|threat identification|威胁识别|\n|api|Application identification|应用识别|\n|aim||行为识别|\n|ecm|Encrypted |加密传输|\n|sst||可靠性|\n|dac|Device access control|设备准入|\n|dsm|Device|设备扫描|\n|fwd|forward||\n|pkt|packet|报文|\n|vgp|gateway platform|通用网关平台|\n|blc|balance|\n|dev|device|设备|\n|rte|Run time environment|运行环境|\n|proto|protocal|协议类型|\n","comments":true,"permalink":"http://yoursite.com/2019/07/19/专业英语/","categories":[],"tags":[{"name":"英语","slug":"英语","permalink":"http://yoursite.com/tags/英语/"}]},{"title":"static","date":"2019-07-19T13:27:06.908Z","path":"2019/07/19/static/","raw":"---\ntitle: static\ntags:\n- C/C++\n- 编程\n---\n==2019-07-18更新==\n# static 修饰函数\n## 类的静态成员函数\n静态成员（变量，函数）本质上是全局变量/函数。普通成员变量每个对象都有自己的，静态成员变量只有一份，所有对象共享。静态成员函数不作用于某个具体的对象。 静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数，因为不知道这个非静态作用在哪个对象上。引入静态机制，将一些和类紧密相关的全局变量或者全局函数，封装到类里面去，便于管理和维护。\n```cpp\n#include<iostream>\nusing namespace std;\nclass Rectangle{\n    int w;\n    int h;\n    int area;\n    static int totalNumber;\n    static int totalArea;\npublic:\n    Rectangle(int x,int y);\n    ~Rectangle();\n    static void printTotal();\n};\n\nRectangle::Rectangle(int x,int y){\n    w = x;\n    h = y;\n    area  = x*y;\n    totalNumber ++;\n    totalArea += area;\n}\n\nRectangle::~Rectangle(){\n    totalNumber --;\n    totalArea -= area;\n}\n\n//静态成员定义的时候，就不要写static 了\nvoid Rectangle::printTotal(){\n    // cout<<w<<\" \"<<h<<\" \"<<area<<endl;\n    cout<<totalNumber<<\" \"<<totalArea<<endl;\n}\n\n//必须在类的定义文件中，对静态成员变量进行一次说明或者初始化\n//相当于全局变量的初始化\nint Rectangle::totalNumber = 0;\nint Rectangle::totalArea = 0;\n\nint main(){\n    Rectangle r1(1,2),r2(3,3);\n    Rectangle::printTotal();  //通过类名来访问静态成员\n    r1.printTotal();    //也可以通过某个对象来访问静态成员函数\n    r2.printTotal();\n    cout<<sizeof(Rectangle);  //sizeof() 运算符不会计算静态成员\n    return 0;\n}\n```\n## 全局静态函数\n用static修饰的函数，限定在本源码文件中，不能被本源码文件以外的代码文件调用。而普通的函数，默认是extern的，也就是说它可以被其它代码文件调用。\n在函数的返回类型前加上关键字static，函数就被定义成为静态函数。普通函数的定义和声明默认情况下是extern的，但静态函数只是在声明他的文件当中可见，不能被其他文件所用。因此定义静态函数有以下好处：\n1.  其他文件中可以定义相同名字的函数，不会发生冲突。\n2. 静态函数不能被其他文件所用。\n```cpp\n//test.h\nvoid funb();\n```\n```cpp\n//test.cpp\n#include \"stdafx.h\"\n#include \"test.h\"\n#include<iostream>\n\nusing namespace std;\n\nstatic void funa(){\n\tcout<<\"hello funa\"<<endl;\n}\n\nvoid funb(){\n\tcout<<\"++++++\"<<endl;\n\tfuna();\n\tcout<<\"-----\"<<endl;\n}\n```\n```cpp\n//static.cpp\n#include \"stdafx.h\"\n#include<iostream>\n#include \"test.h\"\n\nusing namespace std;\n\nvoid funa(){\n\tcout<<\"hello\"<<endl;\n}\n\nint main()\n{\n\tfuna();\n\tfunb();\n\tcout<<\"hello static\"<<endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n在`main`中，`funa()`调用的是`static.cpp`中的函数，但是`funb()`可以调用`test.cpp`中的`funa()`函数。也就是说，不能直接调用其他文件中的静态函数，但是可以通过调用其他文件中的非静态函数来间接调用该文件中的静态函数。","comments":true,"permalink":"http://yoursite.com/2019/07/19/static/","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"}]},{"title":"VS 2012","date":"2019-07-19T13:27:06.908Z","path":"2019/07/19/VS 2012/","raw":"---\ntitle: VS 2012\ntags:\n- 软件使用\n---\n==2019-07-18更新==\n## VS2012 的启动目录\n`D:\\Visual Studio 2012\\Common7\\IDE\\devene.exe`\n\n## 解决方案资源管理器\n快捷键<kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>L</kbd>打开。\n\n## 建立项目\n所有的`.cpp`文件都要有`include \"stdafx.h\"`，且要放在文件第一行。\n\n在主程序中，使用`include xxx.h`而不是`include xxx.cpp`。\n在其他文件中，将函数的声明放在`.h`文件中，然后将函数的定义放在`.cpp`文件中。\n[C++LNK2005 某函数已经在.obj中定义](https://blog.csdn.net/qq_37395889/article/details/80265816)\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/19/VS 2012/","categories":[],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"http://yoursite.com/tags/软件使用/"}]},{"title":"计算机组成原理","date":"2019-07-19T13:27:06.861Z","path":"2019/07/19/计算机组成原理/","raw":"---\ntitle: 计算机组成原理\ntags:\n- 电脑\n- 计算机组成原理\n---\n==2019-07-18更新==\n# CPU与操作系统\n命令行执行`systeminfo`，可以看到系统类型`x64-based PC`代表操作系统位数，处理器`Intel64 Family 6 Model 94 Stepping 3 GenuineIntel ~2304 Mhz`代表电脑CPU位数。\n其中X86说明是32位的，X64说明是64位的。可以看出，我的电脑的操作系统和CPU的位数都是64位的。\n\nCPU位数 = CPU中寄存器的位数 = CPU能够一次并行处理的数据宽度（位数）= 数据总线宽度 = 机器字长。\n\nCPU代表着电脑的硬件，而操作系统则代表着电脑的软件。\n\n硬件对软件是向下兼容的，高位数的CPU可以装低位数的操作系统，如64位的CPU，可以装32位系统。但是64位操作系统是专门为64位CPU设计的，不能用于32位CPU。\n\n# 数据类型的位数\n在标准c++中，`int`的长度取决于机器字长（CPU位数）。32位CPU上面`int`是32位，64位CPU上面`int`就是64位。 但是在32位机器和64机器中`int`类型都占用4个字节，这是因为一般编译器可以根据自身硬件来选择合适的大小。但是需要满足约束：\n1. `short`和`int`型至少为16位\n2. `long`型至少为32位\n3. `short`型长度不能超过`int`型，\n4. `int`型不能超过`long`型\nC++没有规定每个类型必须要占多少字节，而是规定了最少占多少。这即是说各个类型的变量长度是由编译器和硬件来决定的，而当前主流的编译器中，一般是32位机器和64位机器中`int`型都是4个字节（例如，GCC）。\n[CPU位数、操作系统位数、机器字长、C/C++基本数据类型长度](https://www.cnblogs.com/chakyu/p/7405275.html)","comments":true,"permalink":"http://yoursite.com/2019/07/19/计算机组成原理/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yoursite.com/tags/计算机组成原理/"}]},{"title":"Linux网络基础","date":"2019-07-17T13:05:13.215Z","path":"2019/07/17/Linux网络基础/","raw":"---\ntitle: Linux网络基础\ntags:\n- 网络\n- Linux\n---\n\n## ifconfig命令\n```bash\n[root@SmartSPG6300 xtncsg]# ifconfig MGT\nMGT: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\n        inet 192.168.2.166  netmask 255.255.255.0  broadcast 192.168.2.255\n        inet6 fe80::329c:23ff:fe95:6b9b  prefixlen 64  scopeid 0x20<link>\n        ether 30:9c:23:95:6b:9b  txqueuelen 1000  (Ethernet)\n        RX packets 784998  bytes 88295990 (84.2 MiB)\n        RX errors 0  dropped 16947  overruns 0  frame 0\n        TX packets 40889  bytes 4533363 (4.3 MiB)\n        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0\n        device memory 0xc8800000-c881ffff  \n```\nether是MAC地址，网卡自出厂起，就带有一个全球唯一的MAC地址。\nflags中的 UP 表示网卡处于启动的状态；BROADCAST 表示这个网卡有广播地址，可以发送广播包；MULTICAST 表示网卡可以发送多播包。\n```bash\nifconfig eth0 up\nifconfig eth0 down  关闭和启动网卡\n```\nRX和TX是启动到目前为止的数据包接收与发送情况。packets是数据包数量，errors是数据包发生错误的数量，drops 是数据包丢失的数量。collisions是数据包发生冲突的情况。txqueuelen指传输数据的缓冲区的存储长度。\n\n## CIDR\n无类型域间选路，简称CIDR。将网络地址划分为网络号和主机号。伴随着 CIDR 存在的，一个是广播地址，10.100.122.255。如果发送这个地址，所有 10.100.122 网络里面的机器都可以收到。另一个是子网掩码，255.255.255.0。\n\n## Ping中的TTL\n```bash\n[root@SmartSPG6300 /]# ping 192.168.2.24\nPING 192.168.2.24 (192.168.2.24) 56(84) bytes of data.\n64 bytes from 192.168.2.24: icmp_seq=1 ttl=64 time=0.792 ms\n```\n如果主机与待检测主机在同一个网络内，则TTL是64，如果不在同一个网络内，则TTL默认是255。\n\n## host\n`host www.baidu.com`命令使用DNS来获取IP地址。\n\n## tcpdump抓包\n安装tcpdump  `yum install -y tcpdump`\n### tcpdump抓取DNS包\nXShell连接设备，开两个窗口，一个运行`tcpdump -n -i any port 53`命令，监听53号端口。另一个运行`ping -c 3 www.baidu.com`。这个命令向DNS所在的53号端口，发出将域名解析成IP地址的命令。这样第一个命令就能抓取到53号端口的数据包。\n其中，-n是指不要将（包里面的）ip地址解析成域名，-i表示所要抓取的网卡名称，因为设备是用MGT口连接集线器，故可以`-i MGT`。\n[Linux下抓包工具tcpdump详解](https://www.linuxidc.com/Linux/2018-08/153826.htm)\n\n\n\n\n\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/17/Linux网络基础/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"设备调试","date":"2019-07-17T13:04:08.380Z","path":"2019/07/17/设备调试/","raw":"---\ntitle: 设备调试\ntags:\n- 设备调试\n---\n## 主路部署\n登录网页部署主路，这样输入：\n防泄密网关LAN1地址：`192.168.3.194`\nLAN1网络掩码：`255.255.255.0`\n网络网关1地址：`192.168.3.1`\nETH0：`192.168.3.10`\nETH2：`192.168.3.11`\nETH4：`192.168.3.12`\n\n这里全部是填3网段，因为设备是2网段，不要一样。\n防泄密网关LAN1地址不要和设备的地址重复。\nETH0这几个连接数字录像设备的，填写NVR的地址，ETH1这几个连接交换机的不需要输入。\n填写完毕之后提交，确认白名单已经备份，重启网关设备。之后需要等待一段时间，才能重新登录设备。\n主路网卡的代号是br01。\n\n\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/17/设备调试/","categories":[],"tags":[{"name":"设备调试","slug":"设备调试","permalink":"http://yoursite.com/tags/设备调试/"}]},{"title":"编译环境","date":"2019-07-17T13:04:08.364Z","path":"2019/07/17/编译环境/","raw":"---\ntitle: 编译环境\ntags:\n- Linux\n- Makefile\n- 设备调试\n---\n# Makefile\n在 Linux（unix ）环境下使用GNU 的make工具能够比较容易的构建一个属于自己的工程，整个工程的编译只需要一个命令就可以完成编译、连接以至于最后的执行。不过这需要投入一些时间去完成一个或者多个称之Makefile 文件的编写。所要完成的Makefile 文件描述了整个工程的编译、连接等规则。其中包括：工程中的哪些源文件需要编译以及如何编译、需要创建哪些库文件以及如何创建这些库文件、如何最后产生我们想要的可执行文件。Makefile 就像一门编程语言一样，有自己的书写格式、关键字、函数。\n\nmake是一个命令工具，它解释Makefile 中的指令。一般来说，大多数的IDE都有这个命令，比如：Delphi的make，Visual C++的nmake，Linux下GNU的make。makefile一旦写好，只需要一个make命令，整个工程完全自动编译，极大的提高了软件开发的效率。\n\n在 UNIX 系统中，习惯使用 Makefile 作为 makefile 文件。如果要使用其他文件作为 makefile，则可利用类似下面的 make 命令选项指定 makefile 文件：`$ make -f Makefile.debug`。\n\n一个名为prog的程序由三个C源文件filea.c、fileb.c和filec.c以及库文件LS编译生成，这三个文件还分别包含自己的头文件a.h 、b.h和c.h。通常情况下，C编译器将会输出三个目标文件filea.o、fileb.o和filec.o。假设filea.c和fileb.c在声明用到一个名为defs的文件，但filec.c不用。即在filea.c和fileb.c里都有这样的声明：`#include \"defs\"`。\n则Makefile文件的写法可以参考如下：\n```\n0 #It is a example for describing makefile 注释行\n1 prog : filea.o fileb.o filec.o #指定prog由三个目标文件filea.o、fileb.o和filec.o链接生成\n2 cc filea.o fileb.o filec.o -LS -o prog #如何从prog所依赖的文件建立可执行文件\n3 filea.o : filea.c a.h defs #指定filea.o目标文件，以及它们所依赖的.c和.h文件以及defs文件\n4 cc -c filea.c #如何从目标所依赖的文件建立目标，即如何从filea.c建立filea.o\n5 fileb.o : fileb.c b.h defs #指定fileb.o目标文件，以及它们所依赖的.c和.h文件以及defs文件\n6 cc -c fileb.c #如何从目标所依赖的文件建立目标,即如何从fileb.c建立fileb.o\n7 filec.o : filec.c c.h #指定filec.o目标文件，以及它们所依赖的.c和.h文件\n8 cc -c filec.c #如何从目标所依赖的文件建立目标,即如何从filec.c建立filec.o\n```\nCC 是一个全局变量，它指定Makefile所用的编译器，一般默认是gcc。`.o`文件是unix下的中间代码目标文件，就如同在windows下的`.obj`文件一样，在unix下生成`.o`文件的过程叫编译（compile），将无数`.o`文件集合生成可执行文件的过程叫链接（link）。有时会在unix界面下看到`.a`文件，那是Archive File，`.a`文件作用是：由于源文件太多（上例是指`.c`和`.h`文件过多），编译生成的中间目标文件（`.o`文件）太多，而在链接时又需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，这个包就是`.a`文件。\n\n当filea.c或a.h文件在编译之后又被修改，则 make 工具可自动重新编译filea.o，如果在前后两次编译之间，filea.c 和a.h 均没有被修改，而且filea.o还存在的话，就没有必要重新编译。通过这种依赖关系的定义，make 工具可避免许多不必要的编译工作。当然，利用Shell脚本也可以达到自动编译的效果，但是，Shell 脚本将全部编译任何源文件，包括哪些不必要重新编译的源文件，而 make 工具则可根据目标上一次编译的时间和目标所依赖的源文件的更新时间而自动判断应当编译哪个源文件。\n\nMakefile文件准备好之后，接着在Makefile文件所在的目录下敲入make这个命令就可以了。\n[百度百科Makefile](https://baike.baidu.com/item/Makefile/4619787?fr=aladdin#reference-%5b1%5d-974566-wrap)\n\n# 执行`quick.sh`\n执行这个文件的时候会报错，形如：\n```\nStart to Copy file from adaptor to opensource\nNot found obj dirctory: /opt/iot/SmartSecuri-IoT/trunk/gateway/build/fwd/obj\nFail Compile x86_64-native-linuxapp-gcc_J1800_igb\n```\n## 修改`quick.sh`\n查看该文件，发现COMPILE_MODULE这个参数写错了。应将其修改为：`COMPILE_MODULE=(\"J1800_igb\")`。\n\n## 添加库文件J1800_igb\n首先还是将`SmartSecuri-IoT`和`SmartSecuri-Platform`这两个文件给放到`/opt/iot`目录下。\n在`/opt/iot/Smartsecuri-Platform/trunk/adaptor/f-stack/dpdk`目录下，少了J1800_igb这个库文件，拷贝过来。然后再执行`quick.sh`。\n\n## 添加权限\n`/bin/sh: /opt/iot/SmartSecuri-Platform/trunk/opensource/f-stack/dpdk/buildtools/check-experimental-syms.sh: 权限不够`执行的时候，出现了这一句报错，索性就给/iot目录下的所有文件对所有用户都添加最多的权限，所以要用到`-r` 递归赋予权限的选项。\n`[root@SmartSPG6300 opt]# chmod 777 -R iot/`。\n\n# 部署安装\n以上三步之后，`quick.sh`终于能够正常执行了。然后在相同的目录下，执行\n```\npkill fwd;cp fwd/release/J1800_igb/fwd_J1800_igb /SPG/bin/fwd/pkg/J1800_igb/ && /SPG/bin/fw\nd/start_fwd.sh J1800_igb\n```\n首先是杀死这个进程，然后是拷贝文件，再然后是运行`start_fwd.sh`，后面的J1800_igb是运行时的参数，即$1位置参数。出现`Successfully Start Fwd, Start Mode:mr`即表示整个编译环境的搭建的工作已经完成了。\n\n环境搭建完成的意思应该就是说，这个时候就可以用Makefile来编译连接整个项目文件了。\n\n<font color=\"red\">2019-07-23</font>\n# 搭建编译环境\n在设备里重新拷贝了一份不是从svn里下载的代码，然后重新部署编译环境。\n1. 修改`quick.sh`\n2. 将J1800的库拷贝到adaptor。这个时候要注意，库放的位置一定要正确，执行`quick.sh`的时候，需要在adaptor里面找到J1800，将adaptor里面的东西拷贝到opensource，之后是嵌套式的调用各个makefile，编译dpdk下面的所有模块。编译完成之后，在`quick.sh`的同级目录下的fwd目录下，生成release目录，里面有待会执行cp命令时所需的J1800_igb文件。\n3. 执行命令运行。\n\n之所以已经在adaptor里面存放了J1800，但还是会`Fail Compile x86_64-native-linuxapp-gcc_J1800_igb`，是因为目录放的不对。`ls J1800`之后看到的还是J1800文件夹，再次ls之后才看到J1800下面的几个子文件夹。这就是说，J1800放置的目录深了一层。向上提取一层，之后执行`quick`就可以找到J1800了。\n\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/17/编译环境/","categories":[],"tags":[{"name":"设备调试","slug":"设备调试","permalink":"http://yoursite.com/tags/设备调试/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"Makefile","slug":"Makefile","permalink":"http://yoursite.com/tags/Makefile/"}]},{"title":"Source Insight","date":"2019-07-17T13:01:28.695Z","path":"2019/07/17/Source Insight/","raw":"---\ntitle: Source Insight\ntags:\n- 软件使用\n---\n\n# 破解安装\n1. 运行`sourceinsight4096-setup.exe`进行软件安装。\n2. 将`sourceinsight4.exe`这个破解文件替换掉安装目录下的同名文件。\n3. 打开软件，按照提示上传license。\n如果不进行第二步的破解，则license无法生效。\n[Source Insight 4.0 最简单的破解安装](https://blog.csdn.net/biubiuibiu/article/details/78044232)\n\n# 项目操作\n<kbd>Ctrl</kbd>+<kbd>O</kbd>：打开项目文件列表\n项目的存放位置：`C:\\Users\\14311\\Documents\\Source Insight 4.0\\Projects`\n\n删除项目，先在项目的存放位置处删除项目文件夹，然后删除`project_list.sidb`文件下的`?C:\\Users\\14311\\Documents\\Source Insight 4.0\\Projects\\you\\you                                                                                         `字段。只删除文件夹的话，在软件里面使用`open project`，仍然可以看到这个项目继续存在着。\n\n为项目导入文件时，只能导入C盘里的文件。在`file name`这个搜索框里面，输入`D:`即可导入别的盘的文件。\n\n# 中文乱码\n可以在`file->reload as encoding`里面或者`options->preference->files->default encoding`里面修改编码格式。可以在`utf-8`，`system default(ANSI)`，`Chinese Simplified(GB2312)`等里面试试看。\n\n# 只能在项目中打开文件\n直接双击打开文件，或者在软件里面使用`browse files`都打不开文件，只能新建一个项目，将要打开的文件添加到项目里面去才能打开。奇怪！！！\n\n# 修改tabs\noptions -> preference -> language -> file types -> expands tabs to space -> tabs width=4\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/17/Source Insight/","categories":[],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"http://yoursite.com/tags/软件使用/"}]},{"title":"TortoiseSVN","date":"2019-07-17T13:01:28.679Z","path":"2019/07/17/TortoiseSVN/","raw":"---\ntitle: TortoiseSVN\ntags:\n- 软件使用\n- 版本控制\n---\n# checkout\n`working copies `工作副本\n`checkout` 检出\n`Revision` 版本\n`HEAD Revision` 最新版本\n`Show log` 显示日志\n`Omit externals` 省略外部\n\nSVN的四种检出深度: \n1、`Fully recursive`（全递归）检出完整的目录树，包含所有的文件或子目录。 \n2、`Immediate children,including folders`（直接子节点，包含文件夹）检出目录，包含其中的文件或子目录，但是不递归展开子目录。 \n3、`Only file chlidren`（仅文件子节点）检出指定目录，包含所有文件，但是不检出任何子目录。\n4、`Only this item`(仅此项:只检出目录。不包含其中的文件或子目录。\n\n# 红色感叹号\n红色感叹号说明该本地文件与库里面的不一致。\n在该文件所在目录下，执行`update`命令，将库里面的新版本下载到本地上。没有用。\n执行`revert`命令，将本地修还过的文件回复到最后一次保存时的样子。成功回复绿色对号了。\n\n[svn红色感叹号如何解决](https://blog.csdn.net/pdsuxueyuan/article/details/86544139)\n\n# commit与add\n在 SVN工作目录下，对于文件修改，完成后只需要commit就ok了，但对于新增文件，或者从其它目录复制进来的文件或文件夹，需要在commit之前需要做一步add操作。","comments":true,"permalink":"http://yoursite.com/2019/07/17/TortoiseSVN/","categories":[],"tags":[{"name":"软件使用","slug":"软件使用","permalink":"http://yoursite.com/tags/软件使用/"},{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"}]},{"title":"Linux进程管理","date":"2019-07-17T13:00:02.186Z","path":"2019/07/17/Linux进程管理/","raw":"---\ntitle: Linux进程管理\ntags:\n- Linux\n- 操作系统\n---\n\n## kill 与 killall\nLinux系统中的`killall`命令用于杀死指定名字的进程（kill processes by name），而kill命令需要先查找到进程的PID，然后根据PID杀死指定的进程。\n\n通常，终止一个前台进程可以使用Ctrl+C键，但是，对于一个后台进程就须用kill命令来终止，我们就需要先使用 ps 等工具获取进程PID，然后使用kill命令来杀掉该进程。kill命令是通过向进程发送指定的信号来结束相应进程的。在默认情况下，采用编号为15的TERM信号。TERM信号将终止所有不能捕获该信号的进程。对于那些可以捕获该信号的进程就要用编号为9的kill信号，强行杀掉该进程。","comments":true,"permalink":"http://yoursite.com/2019/07/17/Linux进程管理/","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"限流","date":"2019-07-17T12:56:39.055Z","path":"2019/07/17/限流处理/","raw":"---\ntitle: 限流\ntags:\n- 并发\n- 算法\n---\n\n# 高并发的处理\n比如这里的很多主机连接设备，请求量很高，或者设备转发的数据量很大，会导致设备负载很高，当超过设备承载极限的时候，设备可能会崩溃。为了应用服务的高可用，一个常用的办法是对大流量的请求（秒杀/抢购）进行限流，拦截掉大部分请求，只允许一部分请求真正进入后端服务器，这样就可以防止大量请求造成系统压力过大导致的系统崩溃，从而保护服务正常可用。\n\n处理高并发的三板斧: 缓存、降级和限流！\n\n1. 缓存的目的是提升系统访问速度和增大系统能处理的容量。\n2. 降级是当服务出问题或者影响到核心流程的性能时，需要暂时屏蔽掉一些服务，待高峰或者问题解决后再打开。高峰时或者cpu、内存占用较高时，减少日志记录、主动拒绝一些请求等等。\n3. 限流的目的是通过对并发访问/请求进行限制或者一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务或者排队等待。\n\n设备是在数据传输的过程中，起着中转的作用，数据从设备的入口流入，再从出口流出。可能有多个入口或者出口。这里的限速指的是全局的限速，就是在单位时间内，这些口流入和流出的数据总和不能超过一个阈值。\n\n一个时间窗口内的请求即是指一个时间单位，比如1min之内的请求数量做一个限制。\n\n# 限流算法\n令牌桶(Token Bucket)、漏桶(leaky bucket)和计数器算法是最常用的三种限流的算法。\n## 计数器\n计数器限流主要用来限制**总并发数**，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。统计当前正在并发执行的次数，如果超过域值就简单粗暴的直接响应给用户，说明系统繁忙，请稍后再试或其它信息。\n弊端是简单粗暴超过域值就拒绝请求，可能只是瞬时的请求量高，也会拒绝请求。当请求量降下来之后，需要用户手动再次建立连接。\n## 令牌桶\n令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。先有一个木桶，系统按照固定速度，往桶里加入Token，如果桶已经满了就不再添加。当有请求到来时，会各自拿走一个Token，取到Token 才能继续进行请求处理，没有Token 就拒绝服务。这里如果一段时间没有请求时，桶内就会积累一些Token，下次一旦有突发流量，只要Token 足够，也能一次处理，所以令牌桶算法的特点是允许突发流量。\n\n假如令牌则按照每秒5 个的速度放入令牌桶，桶中最多存放20 个令牌，那系统可以支持两种类型的请求流量，一种是允许持续的每秒处理5 个请求，第二种是每隔4 秒，等桶中20 个令牌攒满后，就可以处理一次有20 个请求的突发情况。\n\n## 漏桶\n想象有一个木桶，新请求就像水滴一样，不断地滴进来，水滴进来的速度是不确定的，有时会快一点，有时会慢一点，同时桶底下有个洞，可以按照固定的速度把水漏走，如果水进来的速度比漏走的快，桶就会满了，桶满了水就会漫出来，对应的就是拒绝请求。\n请求就像水滴一样以不固定的速度流进来，但是系统处理请求的速度是固定的，水桶就像一个先进先出的请求缓冲队列，当请求进来的速度比处理请求的速度快，缓冲队列就会渐渐的满，队列满时就会拒绝新的请求进来。\n\n漏桶算法的主要特点是可以平滑网络上的突发流量，请求可以被整形成稳定的流量。\n[聊聊互联网限流方案](http://www.dczou.com/viemall/852.html)\n\n令牌桶限制的是单位时间内的平均流入速率，令牌流入的速度是固定的。但是允许突发请求。\n漏桶限制的是流出速度，也就是处理速度，碰到突发请求，也是按固定速率处理这些请求，平滑突发流入速率。\n[服务器端限流保护](https://www.cnblogs.com/xianzhedeyu/p/5868024.html)\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/17/限流处理/","categories":[],"tags":[{"name":"并发","slug":"并发","permalink":"http://yoursite.com/tags/并发/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"公司问题集锦","date":"2019-07-17T12:56:39.055Z","path":"2019/07/17/问题集锦/","raw":"---\ntitle: 公司问题集锦\ntags:\n- smart\n- 电脑\n- 软件\n---\n# 更新 StFilter 驱动\n从SVN上面下载的代码，直接用source insight打开和在sourcr insight 的工程中打开，报错`there are errors opening .....`，用notepad++ 打开，报错说文件不存在。在source insight中直接打开文件，则报错该命令指定了与设备粒度/对齐不相符合的数据偏移。\n\n解决方法是更新StFilter驱动，首先将拷贝过来的新驱动替换`C:\\ProgramData\\Gfa\\Drm\\Config\\drivers`目录下的驱动，然后再替换`C:\\Windows\\System32\\drivers`目录下的驱动。\n\n当对替换操作不太有信心时，可以先将原来的东西重命名一下，然后再将新的文件拷贝过来。这样就将替换操作转换为复制操作了。\n\n这个驱动好像是负责解密的，因为驱动老旧，无法对文件进行有效的解密，所以文件打不开。\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/17/问题集锦/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"},{"name":"smart","slug":"smart","permalink":"http://yoursite.com/tags/smart/"},{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"TCP/UDP 协议","date":"2019-07-14T07:27:25.091Z","path":"2019/07/14/TCP与UDP 协议/","raw":"---\ntitle: TCP/UDP 协议\ntags:\n- 网络\n- 网络协议\n- TCP/IP\n---\n\n## TCP\nTCP 首部格式如下：\n![enter image description here](https://s1.51cto.com/images/20180821/1534845641472393.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\nTCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。\n\n### 确认号\n只有在ACK位置1时才有效。指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。\n\n### 数据偏移\n数据部分在整个报文段中的偏移量，也就是首部长度。4位，以4字节为单位，最大60个字节，至少20个字节，同IP一样。\n\n### 保留位\n6位，一般是取0，留作以后用。\n\n### 标志位\n总共6个标志位，都很重要。\n1. URG。该位置1时，紧急指针才有效。\n2. ACK。该位置1时，确认号ack才有效。\n3. PSH。该位置1时，说明接收方应该立刻将该报文交付给应用程序（应用层），而不是留在缓冲队列中。\n4. RST。用以重建连接。\n5. SYN。连接建立时用于同步序号。当SYN=1，ACK=0时表示这是一个连接请求报文段。若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。\n6. FIN。该位置1时用以结束一个TCP会话。为1时表示发送方已经没有数据发送了，即关闭本方数据流。\n\n### 窗口\n用于TCP的流量控制。\n\n### 检验和\n对整个报文进行检验，由发送端计算和存储，到接收端后，由接收端进行验证。\n\n### 紧急指针\n紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。\n\n### 选项\n必须是4字节的整数倍，不足时可以用0填充。最常见的可选字段是最长报文大小，又称为MSS（Maximum Segment Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。\n\n## 三次握手\n![enter image description here](https://img-blog.csdn.net/20180717202520531?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n1. 建立连接时，客户端发送(SYN=1,seq=x)报文到服务器，并进入SYN_SENT状态，等待服务器确认。\n\n2. 服务器收到后发送回去一个SYN+ACK包(SYN=1,ACK=1,seq=y,ack=x+1)，此时服务器进入SYN_RECV状态。\n\n3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ACK=1,seq=x+1,ack=y+1），之后客户端进入ESTABLISHED（TCP连接成功）状态，服务器收到这个确认包之后也进入ESTABLISHED状态。\n\n## 为什么两次握手不行？\n主要是考虑到服务器发出的SYN+ACK包可能会丢失。\n\n若是两次握手即可，那么当服务器发回SYN+ACK包之后，服务器即认为连接已经建立，觉得自己可以向客户端发送数据了。\n\n但是如果这个SYN+ACK包没有到达客户端的话，客户端不知道服务器到底准备好了没有，甚至服务器到底有没有收到自己发给他的连接请求。这些都不知道，客户端就会认为连接还没有成功建立，将忽略服务器发来的任何数据分组，只等待连接确认应答分组。而服务器在发出的分组超时后，重复发送同样的分组。服务器一直发，客户端一直在拒绝，这样就形成了死锁。\n\n## 四次挥手\n![enter image description here](https://img-blog.csdn.net/20180717204202563?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4OTUwMzE2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n1. 客户端进程发出连接释放报文（FIN=1，seq=u），并且停止发送数据。此时，客户端进入FIN-WAIT-1状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。\n\n2. 服务器收到连接释放报文，发出确认报文（ACK=1，ack=u+1，seq=v），此时，服务端就进入了CLOSE-WAIT（等待关闭）状态。客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，在这期间服务器可以继续向客户端发送数据。\n而收到这个报文的客户端进入FIN-WAIT-2状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的一些数据）。\n\n3. 服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，由于在半关闭状态，服务器之前很可能又发送了一些数据，假定此时的序列号为seq=w，所以服务器发送的是（FIN=1，seq=w，ack=u+1）此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。\n\n4. 客户端收到服务器的连接释放报文后，发出确认（ACK=1，ack=w+1，seq=u+1）。此时，客户端就进入了TIME-WAIT状态。服务端收到这个确认报文之后就会关闭。而此时客户端的TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，才进入CLOSED状态。\n\n## 为什么客户端需要经过2MSL？\n为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？\n\n主要是考虑到客户端最后发出的那个ACK确认包可能会丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果服务器没有收到这个ACK确认，就会再次重发连接请求释放报文。所以客户端不能立即关闭，它必须确认服务器接收到了该ACK。\n\n客户端会在发送出ACK之后进入到TIME_WAIT，并会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么它会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，客户端都没有再次收到FIN，那么就可以推断ACK已经被成功接收，则结束TCP连接。\n\n## 如果已经建立了连接，但是客户端突然出现故障了怎么办？\n\nTCP设有一个保活计时器，每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接，不再继续等待。\n\n## UDP\n![enter image description here](https://s1.51cto.com/images/20180821/1534845652351546.jpeg?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=)\n首部只有8个字节，16位UDP长度指的是整个报文的长度。\n\n[TCP/IP 数据包报文格式（IP包、TCP报头、UDP报头）](https://blog.51cto.com/lyhbwwk/2162568)\n[TCP报文格式详解](https://www.cnblogs.com/feng9exe/p/8058891.html)\n[TCP的三次握手与四次挥手理解及面试题（很全面）](https://blog.csdn.net/qq_38950316/article/details/81087809)","comments":true,"permalink":"http://yoursite.com/2019/07/14/TCP与UDP 协议/","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"},{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"IP/ICMP 协议","date":"2019-07-14T07:26:08.309Z","path":"2019/07/14/IP与ICMP 协议/","raw":"---\ntitle: IP/ICMP 协议\ntags:\n- 网络\n---\n# IP协议\nIP数据包头部的格式如下：\n![enter image description here](http://hi.csdn.net/attachment/201007/15/5573582_1279195143KN73.png)\n## 版本号\nIPv4就是4，IPv6就是6。\n\n## 头部长度\n整个数据报头部的长度（包括选项），以32位为一个单位（一行是32位，4个字节），接收端通过此域可以计算出报头在何处结束及从何处开始读数据。IP数据报头部至少是20个字节。\n\n## 服务类型\n服务类型（TOS、type of service）用于规定本数据报的处理方式。\n![enter image description here](http://hi.csdn.net/attachment/201007/15/5573582_1279195143SDCz.png)\n1. 前面三位是优先权，数值越大代表优先权越高，当网络拥塞时，可以根据优先权来决定数据报的取舍。\n2. D（Delay，短延迟位），当该位置1时，数据报请求以短延迟信道传输。\n3. T（Throughput，高吞吐量位），当该位置1时，数据报请求以高吞吐量信道传输。\n4. R（Reliability，高可靠位），当该位置1时，数据报请求以高可靠性信道传输。\n当这些位上是0时，即表示以普通信道传输。\nTOS只表示用户的请求，不具有强制性，实际应用中很少用，路由器通常忽略TOS字段。但在实际编程时，有专门的函数来设置该字段的各域。\n在各种网际应用协议中，如果与用户直接交互的话，建议使用短延迟。如果有大量数据需要传输，建议使用高吞吐量。如果数据包传输的是控制信息，则应该使用高可靠性信道。\n\n## 总长度\nIP数据报包括头部和数据部分在内的长度，以字节为单位（头部长度的单位是4个字节）。占用16位，所以IP数据报的最大长度理论是65535个字节，但是实际上要受到MTU的限制。\n\n## 生存时间\nTTL，time to live。指定了数据报可以在网络中传输的最长时间。实际应用中的生存时间的意思是数据报可以经过的最大路由器数。TTL的初始值由源主机设置（通常为32、64、128或256），一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，数据报就丢弃，并发送ICMP报文通知源主机，这是为了防止数据报进入循环回路时无休止地传输下去。\n\n## 上层协议标识\nIP协议可以承载各种上层协议，目标端根据协议标识就可以把收到的IP数据报送到TCP或UDP等处理此报文的上层协议了。\n![enter image description here](http://hi.csdn.net/attachment/201007/15/5573582_1279195145NPrA.png)\n\n## 校验和\nIP数据报只校验头部，不校验后面的数据部分。数据包每经过一个中间节点都要重新计算首部校验和。\n\n## 分片与重组\n不同的物理网络有不同的MTU，比如以太网1500。当当前传输的数据包的长度大于该网络的MTU时，就需要对该数据包分片。\n### 分片\n被路由器分片后的各个IP数据包可能经过不同的路径到达目标主机。\n![enter image description here](http://hi.csdn.net/attachment/201007/16/5573582_127924946840lL.png)\n分片后的IP数据报，数据区是原IP数据报数据区的一个连续部分，头部是原IP数据报头部的复制。\n#### 标志\nIP数据包头部中的标志字段共有3位。\n![enter image description here](http://hi.csdn.net/attachment/201007/16/5573582_1279249468x0XZ.png)\n1. 不分片DF（Do not Fragment）如果该位置1，则数据包在传输过程中不能被分片，但这样当数据不能通过MTU较小的网络时，将产生数据不可达的错误。\n2. 片未完MF（More Fragment）如果该位置1，说明该数据报不是分片后的最后一个数据包，最后一个数据包的该位被置0。\n\n#### 片偏移\nIP数据包被分片后，各片数据区在原来IP数据区中的位置用13位的片偏移来表示。上图中分片1的偏移为0，分片2的偏移为600，分片3的偏移为1200。\n实际在IP地址中，由于偏移是以8个字节为单位进行计算的。因而在IP数据包中分片1的偏移是0，分片2的偏移是75，分片3的偏移是150。\n\n### 重组\n当分了片的IP数据包到达最终目标主机时，目标主机对各分片进行组装，恢复成源主机发送时的IP数据包。\nIP数据包头部中的标识，它唯一地标识主机发送的每一份数据包。在一个数据包被分片时，每个分片都把数据包“标识”字段的值原样复制一份，所以一个数据包的所有分片具有相同的标识。\n目标主机根据收到的每个数据包的标识，标志中的MF位，以及片偏移进行重组。\n\n## 选项\nIP数据包的选项由三个部分组成：选项码、选项长度和选项数据。选项码和选项长度各占一个字节。选项长度用于确定整个选项部分的长度；选项码又分为复制、选项类和选项号。\n![enter image description here](http://hi.csdn.net/attachment/201007/16/5573582_1279249469gz2m.png)\n复制：占一位，用来控制一个带有选项的IP数据包被分片后对选项的处理方式。该位置1时将选项复制到所有分片中，置0时仅将选项复制到第一个分片中。这样第一个分片的头部长度就会比后面的分片大。\n选项类和选项号用于确定该选项是哪类选项中的哪个选项，其实就是确定该选项的功能。\n![enter image description here](http://hi.csdn.net/attachment/201007/16/5573582_1279249468JD8J.png)\n\n### 源路由选择\n是指IP数据包在互联网中传输时，所经过的路由是由源主机指定的，以区别于数据包在互联网中传输时由路由器的IP层自动寻径所得到的路由。\n通过设置源路由选择选项，可以测试网络中指定路由的连通性，以使数据包绕开出错的网络，也可用于测试特定网络的吞吐量。\n\n####严格源路由选择\n发送端规定IP数据包必须经过的路径上的每一个路由器，相邻路由器之间不得有中间路由器，并且所经过的路由器的顺序不可更改。严格源路由选择选项格式如下：\n![enter image description here](http://hi.csdn.net/attachment/201007/16/5573582_1279249469yXj5.png)\n选项码是`10001001`，因为IP协议的头部长度占4位，且头部长度以4个字节为单位，则头部最多有60个字节。又头部至少有20个字节，所以选项最多只有40个字节。这里去掉选项码，选项长度和指针的3个字节，还剩37个字节可以写源主机规定的每一站路由器的IP地址，所以最多可以写9个IP地址。\n\n#### 宽松源路由选择\n源主机指定的两个IP地址之间可以有其他IP地址的路由器。格式与严格的相同，只是选项码字段值为`10000011`。\n\n### 记录路由\n记录路由选项的数据格式同上，选项码字段值为`10000111`。IP数据包可以记录数据包从源主机传输到目标主机时，所经过路径上的各个路由器的IP地址。指针初值为4，指向存放第一个IP地址的位置（数据包还没有离开源主机时就已经知道的）。将每个经过的路由器的IP地址存入选项的数据区中，指针字段的值也随着增加（每次加4），它始终指向下一个存放IP地址的位置。当记录了9个IP地址后，指针字段的值为40，表示数据区已满。\n\n[IP数据报格式详解](https://blog.csdn.net/wangzhen209/article/details/74453548)\n\n# ip地址\nA类地址最开始是0，B类地址最开始是10，C类地址最开始是110..........\nA类地址的范围是0.0.0.0~127.255.255.255，其中127.0.0.0~127.255.255.255都是单独拿出来用作保留地址的。\n其中，127.0.0.1是回环地址，用来测试时使用，能ping通回环地址表示本机的TCP/IP协议安装正常。\n```\n[root@SmartSPG6300 etc]# cat hosts\n192.168.1.188   192.168.1.188\n127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4\n```\nLinux中将127.0.0.1与localhost是绑定起来的。\n三类地址的私有地址是：\nA类地址：10.0.0.0～10.255.255.255 \nB类地址：172.16.0.0～172.31.255.255 \nC类地址：192.168.0.0～192.168.255.255\n\n# ICMP协议\nICMP是基于IP协议工作的，是IP协议的上层协议，但仍然把它归结为网络层协议 。ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6。\n\n## ICMP报头\n一个ICMP报文包括IP报头（至少20字节）、ICMP报头（至少8字节）和ICMP报文的数据部分。当IP报头中的上层协议标识字段值为1时，就说明这是一个ICMP报文。\n![enter image description here](https://img-blog.csdn.net/201805301801365?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM3OTY0MDcx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n1. 类型。占一字节，标识ICMP报文的类型，从类型值来看ICMP报文可以分为两大类。第一类是取值为1~127的差错报文，第2类是取值128以上的信息报文。\n2. 代码。占一字节，与类型字段一起共同标识了ICMP报文的详细类型。\n3. 校验和。对ICMP报文总体，包括数据部分在内进行校验。方法同IP数据包的校验。\n\n|类型（十进制）|含义|\n|:-------:|:----------:|\n|0|回送应答|\n|3|目标不可达|\n|4|源点抑制|\n|5|重定向或改变路由|\n|8|回送请求|\n|11|超时|\n|13|时间戳请求|\n|14|时间戳应答|\n\n## Ping\n向目标主机发送一个类型字段值为8的ICMP回送请求报文，如果途中没有异常，则目标返回类型字段值为0的ICMP回送应答报文，说明这台主机存在。\n### 目标不可到达报文\n类型值为3，不同的代码字段值标识了不同的报文类型。\n\n|代码字段值（十进制）|报文类型|\n|:---------:|:-------:|\n|0|网络不可到达|\n|1|主机不可到达|\n|2|协议不可到达|\n|3|端口不可到达|\n### 源抑制报文\n类型字段值为4，代码字段值为0。充当一个控制流量的角色，通知对向主机减少数据报流量。由于ICMP没有回复传输的报文，所以只要停止该报文，对方主机就会逐渐恢复传输速率。 \n### 超时报文\n类型字段值为11。代码字段值为0表示传输超时，代码字段值为1表示目标主机在进行分段重组时超时。\n### 时间戳请求\n 发送方主机填充原始时间戳，以类型值字段为13的时间戳请求报文发送出去。接收方收到请求后填充接受时间戳后以类型值字段为14的时间戳应答报文返回，发送方计算这个时间差， 作为两台主机之间数据报来回一次的传输时间。\n\n## Traceroute\n打印出可执行程序主机，一直到目标主机之前经历多少路由器。 \n`traceroute www.baidu.com`\n\n[ICMP协议详解](https://blog.csdn.net/baidu_37964071/article/details/80514340)\n","comments":true,"permalink":"http://yoursite.com/2019/07/14/IP与ICMP 协议/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"}]},{"title":"shell编程","date":"2019-07-12T13:34:34.899Z","path":"2019/07/12/Shell编程/","raw":"---\ntitle: shell编程\nabstract: 本文介绍了shell编程的一些基础知识，变量，分支，循环，数组，函数以及脚本文件的运行等。\ntags:\n- Shell\n- Linux\n- 命令\n- 文件\n---\n<font color=\"red\">2019-07-24</font>\n# 运行shell文件\n```bash\n[root@SmartSPG6300 xtncsg]# touch hello_world.sh\n[root@SmartSPG6300 xtncsg]# vim hello_world.sh\n[root@SmartSPG6300 xtncsg]# hello_world.sh\nbash: hello_world.sh: 未找到命令...\n[root@SmartSPG6300 xtncsg]# ./hello_world.sh\n-bash: ./hello_world.sh: 权限不够\n[root@SmartSPG6300 xtncsg]# chmod +x hello_world.sh \n[root@SmartSPG6300 xtncsg]# hello_world.sh\nbash: hello_world.sh: 未找到命令...\n[root@SmartSPG6300 xtncsg]# ./hello_world.sh\nhello world!\n[root@SmartSPG6300 xtncsg]# /bin/csh ./hello_world.sh \nhello world!\n\n```\n为此文件赋予可执行权限，如果直接执行`hello_world.sh`，这时会默认从$PATH环境变量中去寻找，由于我们未将此文件配置在环境变量中，因此会找不到。所以，我们从当前目录找。还可以自己指定shell来执行，这时候`#!/bin/bash`将不会生效。   \n\n```bash\n[root@SmartSPG6300 xtncsg]# echo $PATH   #环境变量\n/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/java/jdk1.8.0_212-amd64/bin:/root/bin\n```\n# chmod\n改变文件的读写和执行权限。\n## 符号法\n`chmod {u|g|o|a}{+|-|=}{r|w|x} filename `\n`chmod a+rx filename  # 让所有用户可以读和执行文件filename。 `\n`chmod go-rx filename # 取消同组和其他用户的读和执行文件filename的权限。 `\n其中，u(user，用户自己)，g(group，同组用户)，o(other，其他用户)，a(all，所有用户)。\n## 八进制法\n`chmod abc file `\n其中a,b,c各为一个八进制数字，分别表示User、Group、及Other的权限。 \n\n|八进制数字|代表的权限|\n|:----:|:-------:|\n|4|可读\n|2|可写|\n|1|可执行|\n`chmod 741 filename  #让本人可读写执行、同组用户可读、其他用户可执行文件filename。 `\n其中，7=4+2+1，三种权限都有的意思。\n`chmod -r 755 /home/oracle  #递归更改目录权限，本人可读写执行、同组用户可读可执行、其他用户可读可执行`\n[chmod 权限设置](https://blog.csdn.net/qq_24230149/article/details/87254498)\n\n# shell类型\n`echo $SHELL` 查看类型\n结果是`/bin/bash`\n改变类型\t`# csh`\n只能改成这一个shell类型，这个命令是又重新启动了一个新的shell，他是最初的shell（bash）的下一级shell或者说是子shell。并且启动了之后会禁用上下键输入命令。`exit`退出这个shell。\n\n# Shell变量\n## 环境变量\n环境变量是shell在开始执行时就已经定义了的一些和系统的工作环境相关的变量，这些变量用户还可以重新定义。\n查看用户名，终端等一些环境变量的命令。\n```\n[root@SmartSPG6300 linux]# whoami\nroot\n[root@SmartSPG6300 linux]# who am  i\nroot     pts/0        2019-07-12 02:40 (192.168.2.24)\n[root@SmartSPG6300 linux]# tty\n/dev/pts/0\n[root@SmartSPG6300 linux]# who\nroot     pts/0        2019-07-12 02:40 (192.168.2.24)\n[root@SmartSPG6300 linux]# w\n 03:27:10 up  2:09,  1 user,  load average: 1.73, 1.41, 1.35\nUSER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT\nroot     pts/0    192.168.2.24     02:40    6.00s  0.19s  0.00s w\n```\n主提示符：特权用户是#，普通用户是$，每一行命令最开始的提示符。\n辅助提示符：在一行命令之后输入\\或者系统判断命令在这一行没有输入完，下一行继续输入时，下一行开头得到提示符就是>。\n## 自定义变量\n```bash\nhello=helloworld  #变量内部没有空格或者引号的情况\necho $hello\n```\n自己定义的变量，若是`hello world`这样内部含有空格的或者含有引号的，需要加上引号括起来。即`hello=\"hello world\"`。注意，只是自己定义变量的时候才这样。\n\n自己定义的变量，定义的时候不要加\\$，引用的时候要加\\$。\n`readly var=20`这样子定义的变量，定义完之后就不能再修改了。\n\nshell里面定义的变量都是这个shell程序的局部变量，只能它自己使用，不能交给其他shell程序使用。但是`export var`或者`export var=20`这样的变量就可以在其他的shell程序里面使用到。\n\n\n## 将linux命令执行结果赋值给变量\n```bash\n#!/bin/bash\npath=$(pwd)  #将结果保存到变量的两种方式\nfiles=`ls`\n\necho current path:$path\necho current files:$files\n```\n程序输出结果：\n```bash\n[root@SmartSPG6300 xtncsg]# ./hello_world.sh \ncurrent path:/xtncsg\ncurrent files:a.out first.sh hello_world.sh linux test.c test.exe tmp.txt\n```\n## $()命令替换\n```bash\n[root@SmartSPG6300 xtncsg]# echo date is $(date \"+%Y:%m:%d\")\ndate is 2019:07:16\n```\n###预定义变量\n也是shell一开始就定义了的变量，但是用户不能自己再次定义它。预定义变量都是以$开头，后面跟着另外一个符号。\n```\n#!/bin/bash\necho \"hello world\"\necho $1  #位置参数1\necho $2  #位置参数2\necho $#  #位置参数的个数\necho $*  #所有位置参数的内容\necho $?  #命令执行完之后返回的状态\necho $$  #当前进程（这个命令所在的进程）的进程号\necho $!  #后台运行的最后一个进程号\necho $0  #当前执行的进程名\n```\n然后执行这条命令：`sh ./first.sh 33 440`\n程序的输出结果：\n```\nhello world\n33\n440\n2\n33 440\n0\n17985\n\n./first.sh\n```\n## 参数置换的变量\n这样子在程序里面写参数置换的变量，位置参数前面不要写$，这里写1就表示第一个位置参数了。\n```\n#!/bin/bash\necho \"hello world\"\necho $1  #位置参数1\necho $2  #位置参数2\nvar1=${2-100}\nvar2=${2=200}\nvar3=${2?300}\nvar4=${2+400}\n\necho $var1\necho $var2\necho $var3\necho $var4\n```\n执行`sh ./first.sh 50 100`\n程序输出\n```\nhello world\n50\n100\n100\n100\n100\n400\n```\n如果设置了参数，那么前三种方式都是用参数来置换变量的值，而第四种方式反而是用后面的word 来置换。\n\n如果没有设置参数的值：\n- 第一种方式使用word 来置换变量的值。\n- 第二种方式不仅用word 置换变量的值，并且将参数的值设成word，但是这时的参数不能是位置参数，因为shell里面不能对位置参数赋值。\n- 第三种并不是将变量的值变成word，而是在屏幕上显示word信息，并且退出shell。\n- 第四种是设置了参数则置换，没有设置则不置换。没有设置参数的值，又不选择置换，那变量的值怎么取呢？？？不懂。\n\n\n# 输入输出重定向\n`sh ./first.sh>tmp.txt`\n将程序的输出结果重定向输入到另外一个文件里面去。\n\n# 数值运算\n## 整数运算\n整数运算的两种方式之`$[]`，这个符号起着对括号里面的算式进行运算的作用。\n```bash\nnum1=10\nnum2=3\n\necho num1+num2=$[$num1+$num2]\necho num1 - num2=$[$num1-$num2]\necho num1*num2=$[$num1*$num2]\necho num1 / num2=$[$num1/$num2]\necho \"num1 > num2=$[$num1>$num2]\"\necho \"num1 >= num2=$[$num1>=$num2]\"\necho num1 < num2=$[$num1<$num2]\necho \"num1 <= num2=$[$num1<=$num2]\"\necho hello world\nnum3=$[$num1+$num2]\necho num3=$num3\n```\n输出结果：\n```bash\nnum1+num2=13\nnum1 - num2=7\nnum1*num2=30\nnum1 / num2=3\nnum1 > num2=1\nnum1 >= num2=1\n./hello_world.sh:行12: num2=0: 没有那个文件或目录\nnum1 <= num2=0\nhello world\nnum3=13\n```\n> 涉及到大小判断的时候，要加引号。\\> 的意思是，如果大于则返回1，否则返回0。\n\n整数运算的另一种方式，expr ，不如这个方便，就不学了。\n\n## 小数运算\n```bash\nnum=$(echo \"scale=3;10/3\"|bc)\necho $num\n```\n其格式如下：\n`variable=$(echo \"options; expression\" | bc)`\n这里的选项用的是，`scale=3`，表示保留三位小数。这里的管道，是将`10/3`这个表达式，输出到bc里面，bc是bash的计算器，在这里面计算结果。\n\n# 分支控制\n## if\nshell脚本的if其实是根据紧跟后面的那个命令的退出状态码来判断是否执行then后面的语句的。\n```bash\nif command\nthen\n    commands\nelse\n    commands\nfi\n```\n若命令的状态返回码是0，则执行then后面的语句。\n比如：\n```bash\nif pwd\nthen\n    echo \"newbee\"\nelse\n    echo shabi\nfi\n```\npwd 命令是存在的，返回码肯定是0。\n\n## if test\n使用test命令判断列出的条件表达式是否成立，如果成立，就会退出并返回退出状态码0，否则返回非0。\n\n## 对数值比较的判断\n\n|指令|意义|\n|:---------------:|:--------------:|\n|-eq|等于则为真|\n|-ne|不等于则为真|\n|-gt|大于则为真|\n|-ge|大于等于则为真|\n|-lt|小于则为真|\n|-le|小于等于则为真|\n\n```bash\nnum1=100\nnum2=200\nif test $num1 -gt $num2\nthen\n    echo \"num1 大于 num2\"\nelse\n    echo num1 小于 num2\nfi\n```\n使用双括号判断表达式是否成立，双括号里面可以使用数学比较运算符了。\n```bash\nnum1=100\nnum2=200\nif  (( $num1 > $num2))\nthen\n    echo \"num1 大于 num2\"\nelse\n    echo num1 小于 num2\nfi\n```\n\n## 对字符串比较的判断\n\n|指令|意义|\n|:---------------:|:--------------:|\n|=|等于则为真|\n|!=|不相等则为真|\n|-z|字符串长度伪则为真|\n|-n|字符串长度不伪则为真|\n\n```bash\ns1=test\ns2=tets\n\nif test $s1 = $s2;then\n    echo s1=s2\nelse\n    echo s1!=s2\nfi\n```\n使用test进行字符串的大小比较时，需要将`><号`转义掉，要不然会被当成是重定向运算符。字符串比较大小，是按照ASCII来比较的。\n```bash\ns1=test\ns2=tets\n\nif test $s1 \\> $s2;then\n    echo \"s1>s2\"\nelse \n    echo \"s1<s2\"\nfi\n```\n使用双方括号`[]`进行字符串比较：\n```bash\ns1=test\ns2=tets\n\nif [[$s1>$s2]];then\n    echo \"s1>s2\"\nelse\n    echo \"s1<s2\"\nfi\n```\n## 对文件比较的判断\n\n|指令|意义|\n|:---------------:|:--------------:|\n|-e|文件存在则为真|\n|-r|文件存在且可读则为真|\n|-w|文件存在且可写则为真|\n|-x|文件存在且可执行则为真|\n|-d|文件存在且为目录则为真|\n|-f|文件存在且为普通文件则为真|\n|-c|文件存在且为字符型特殊文件则为真|\n|-b|文件存在且为块特殊文件则为真|\n用test来判断文件：\n```bash\nif test -e abc.cpp ;then\n    echo 该文件存在\nelse \n    echo 根本没有这个文件\nfi\n```\n##if - elif - else \n```bash\n#!/bin/bash\nnum=3\nif (($num==1));then\n    echo num=1\nelif (($num==2));then\n    echo num=2\nelif (($num==3));then\n    echo num=3\nelse\n    echo num=4\nfi\n```\n## case\n```bash\nnum=3\n\ncase num in\n1)\n    echo num=1;;\n2)\n    echo num=2;;\n3)\n    echo num=3;;\n4)\n    echo num=4;;\n*)\n    echo default;;\nesac\n```\n# 循环控制\n## for循环\n```bash\nlist1=\"a b c d e\" #自定义变量内部有空格，所以加引号\nlist2=a,b,c,d,e\n\nfor var1 in $list1\ndo\n    echo $var1\ndone\n\nfor var2 in $list2\ndo\n    echo $var2\ndone\n```\n程序输出结果：\n```bash\na\nb\nc\nd\ne\na,b,c,d,e\n```\n## 内部字段分隔符\nfor...in循环默认是循环一组通过空格或制表符（tab键）或换行符（Enter键）分割的值。这个是由系统环境变量IFS定义的内部字段分隔符所配置的。可以修改这个环境变量，使得for循环按照别的符号进行分割。\n```bash\nlist1=\"a b c d e\"\nlist2=a,b,c,d,e\n\noldIFS=$IFS  #先保存修改前的环境变量，用完之后还要修改回来\n\nIFS=$','  #修改IFS的值\n\nfor var1 in $list1\ndo\n    echo $var1\ndone\n\nfor var2 in $list2\ndo\n    echo $var2\ndone\n\nIFS=$oldIFS  #修改回去\n```\n程序输出结果：\n```bash\na b c d e\na\nb\nc\nd\ne\n```\n## C语言风格的for循环\n```bash\n# 使用双括号进行数值的比较\nfor((var=1;var<=10;var++))\ndo\n    echo $var\ndone\n```\n## while循环\n```bash\nflag1=0\nwhile test $flag1 -le 10\ndo\n    echo $flag1\n    flag1=$[$flag1+1]\ndone\n```\n```bash\nflag2=0\nwhile ((flag2<=10))\ndo\n    echo $flag2\n    flag2=$[$flag2+1]\ndone\n```\nwhile表“只要”，只要条件满足，就一直执行这段语句。\nuntil表“直到”，一直执行这段语句，直到条件成立就不执行了。\n\n## until循环\n```bash\nflag=0\nuntil ((flag>10))\ndo\n    echo $flag\n    flag=$[$flag+1]\ndone\n```\n## break跳出循环\n```bash\nflag=0\nwhile (( $flag < 10 ))\ndo\n    for (( innerFlag=0; innerFlag < 5; innerFlag++ ))\n    do\n        if (( $innerFlag == 2 ))\n        then\n            break 2\n        fi\n        echo \"innerFlag=$innerFlag\"\n    done\n    echo \"outerFlag=$flag\"\ndone\n```\n`break 2`指跳出两次循环，因此程序输出`innerFlag=0 innerFlag=1`之后就结束了。\n## continue 继续下一次循环\n```bash\nfor ((var=1;var<=10;var++))\ndo\n    if (($var==3));then\n        echo \"All is done\"\n        continue 2\n    fi\n    echo $var\ndone\n```\ncontinue 这里是没有`continue 2 `这样的用法的。所以程序输出仍然是：\n```bash\n1\n2\nAll is done\n4\n5\n6\n7\n8\n9\n```\n# 位置参数\n在调用一个shell程序的时候，程序名之后的各个参数就叫做位置参数，之间以空格分隔，会按顺序的替换掉程序中的\\$1，\\$2，\\$3，\\$4等。\\$0是程序的名字，程序里面不应该出现。\n## 获取指定位置参数的值\n```bash\necho file name is $0\necho clean file name is $(basename $0)\necho $1\necho $2\n```\n单纯的$0获取到的文件名是包含有路径的，所以第二行中用`basename $0`来获取纯净的文件名。\n其中，\\$var和\\${var}都是取变量var的值。不过${var}能够限定变量的范围。\n```bash\necho $10\necho ${1}0\n```\n执行\n`[root@SmartSPG6300 xtncsg]# ./parm.sh 1 2 3 4 5 6 5 4 3 2 1 2 3 4 5 6`得到的结果是两个10，说明第一行命令并没有获取第十个位置参数的值。\n因此如果位置参数超过9个，那么从第十个开始就只能通过`${}`来获取。\n[Linux—shell中\\$(( ))、\\$( )、``与${ }的区别](https://www.cnblogs.com/chengd/p/7803664.html)\n\n## 循环获取所有的位置参数\n### 通过$#获取位置参数的个数\n```bash\nfor ((index=0;index<=$#;index++))\ndo\n    echo ${!index}\ndone\n```\n将`${$index}`替换为`${!index}`是因为`${}`里面不能再加`${}`符号了。采用`${}`的方式获取位置参数的值，是因为位置参数的数量可能会多于10个。\n### 通过\\$*和\\$@\n\\$* 会将命令行上提供的所有参数当作一个单词保存, 我们得到的值也就相当于是个字符串整体。一个字符串中只有一个单词。\n\\$@ 会将命令行上提供的所有参数当作同一字符串中的多个独立的单词。一个字符串中有很多个单词。\n```bash\nfor parm in \"$*\"\ndo\n    echo $parm\ndone\n\nfor parm in \"$@\"\ndo\n    echo $parm\ndone\n```\n如果for语句中不加引号，则for默认以空格进行分割，又看不出区别。\n\n\n# ${}取文件的路径，文件名，后缀\n`${}`除了做变量替换外，还可以对文件进行操作。\n```bash\nfile=/dir1/dir2/dir3/myfile.cpp\n\necho ${file#*/}\necho ${file##*/}\necho ${file#*.}\necho ${file##*.}\necho ${file%/*}\necho ${file%%/*}\necho ${file%.*}\necho ${file%%.*}\n```\n得到的结果是\n```bash\ndir1/dir2/dir3/myfile.cpp\nmyfile.cpp\ncpp\ncpp\n/dir1/dir2/dir3\n\n/dir1/dir2/dir3/myfile\n/dir1/dir2/dir3/myfile\n```\n\\#表示左边，%表示右边。\n`*`表示不要的字符，`.*`就表示去掉`.`及其右边的字符（`*`在`.`右边）。\n%表示最小匹配，%%表示最大匹配。\n例如，最后一行命令就表示去掉第一个点号及其右边的字符。\n# 获取用户输入\n## read 变量名\n```bash\necho -n \"your choice y/n:\"\nread choice\nif test $choice = y\nthen\n    echo 任务已经完成\nelse\n    echo 任务中止\nfi\n```\n输出：\n```bash\n[root@SmartSPG6300 xtncsg]# ./tt.sh\nyour choice y/n:y\n任务已经完成\n```\n## 不指定read后面的变量名\nread命令会将它收到的任何数据都放进特殊环境变量REPLY中。\n```bash\necho -n \"your choice y/n:\"\nread\nif test $REPLY = y\nthen\n    echo 任务已经完成\nelse\n    echo 任务中止\nfi\n```\n## 多个输入与超时输入\n```bash\nread -t 15 -p \"your choice y/n:\" first_name last_name\necho Hello $last_name$first_name\n```\n-p是`echo -n read`的综合，-t 指定了等待用户输入的时间间隔。\n```bash\n[root@SmartSPG6300 xtncsg]# ./tt.sh\nyour choice y/n:三丰 张\nHello 张三丰\n```\n# 字符串\n## 获取字符串长度：\n`echo ${ #hello}`其中hello 是一个字符串。\n## 提取子串：\n`echo ${hello:1}` 从某个字符开始，提取之后的所有字符。\n`echo ${ #hello:1:4}`1是子串的起始位置，4是子串的长度。\n## 字符串中查找字符：\n``echo `expr index \"hello\" h` ``hello是要查找的字符串，h是待查找的字符。这里查找到的是从0开始的序号加1的值，即第一个字符查找到的结果是1。\n``echo `expr index \"hello\" l0` ``查找两个字符，哪个字符先出现就显示哪个结果。\n[markdown反引号内怎么转义反引号？](https://www.v2ex.com/t/57233)\n## 拼接字符串\n```bash\nhello=\"hello\"\nworld=\"world\"\nstr1=$hello$world  #不能加空格\nstr2=\"$hello $world\"\nstr3=\"$hello::$world\"\nstr4=\"${hello}script ${world}languige\" #需要限制变量范围\necho $str1 $str2 #一行输出多个变量\necho $str3 $str4\n```\nstr1不能加空格是因为遇到空格就认为字符串结束了。\n[Shell字符串拼接（连接、合并）](http://c.biancheng.net/view/1114.html)\n# 数组\n数组的定义：\n`array=(value1 value2     valuen)`\n数组的各个元素之间以空格分开。\n数组元素的修改：\n`array[index]=value`\n数组元素的读取：\n`${array[index]}`\n```bash\nnum=(a b c d)\nword=(一 二 三 四)\n\nfor ((index=0;index<4;index++))\ndo\n    echo 第${word[index]}个元素的值是：${num[$index]}。\ndone\n```\n获取数组所有元素与数组长度：\n```bash\nnum=(a b c d)\nword=(一 二 三 四)\necho ${num[*]}\necho ${word[@]} \necho ${ #3num[*]}\necho ${ #word[@]}\n```\n输出结果：\n```bash\na b c d\n一 二 三 四\n4\n4\n```\n# 函数\n```bash\nfunction func(){\n    echo 函数开始执行\n}\nfunc\necho \"函数调用执行完毕\"\n```\n函数定义时可以不写`function`，也可以没有参数，也可以没有返回值。\n函数调用完毕之后，可以用`$?`获取函数的返回值。如果函数没写`return`，则函数的返回值是最后一条命令的执行结果，执行正常则返回0，不正常则返回非0。\n`return`后面接的返回值只能是在0-255之间。\n```bash\nfunction func(){\n    echo 函数开始执行\n    pwd\n}\nfunc\necho $?\necho \"函数调用执行完毕\"\n```\n`pwd`命令执行正常，故`$?`的值是0。\n```bash\nfunction plus(){\n    echo \"第一个参数是：$1\"\n    echo \"第二个参数是：$2\"\n    return $[$1+$2]\n}\n\nplus 1 2\necho 两数相加的和是：$?\n\n\nfunction devide(){\n    echo \"第一个参数是：$1\"\n    echo \"第二个参数是：$2\"\n    return $[$1-$2]\n}\n\ndevide 10 2\necho 两数相减的差是：$?\n\ndevide 13 8\necho 哇哇哇\necho 两数相减的差是：$?\n```\n程序运行结果是：\n```bash\n第一个参数是：1\n第二个参数是：2\n两数相加的和是：3\n第一个参数是：10\n第二个参数是：2\n两数相减的差是：8\n第一个参数是：13\n第二个参数是：8\n哇哇哇\n两数相减的差是：0\n```\n如果用`$?`获取函数的返回值，则这条语句必须跟在函数调用的语句之后。上例中最后一次的`$?`会输出0，是因为它获取到的不是`devide 13 8`的`return`，而是`echo 哇哇哇`的执行结果，其值为0。\n[shell编程其实真的很简单（一）](https://www.cnblogs.com/dongying/p/6262935.html)\n[Shell 函数](https://www.runoob.com/linux/linux-shell-func.html)\n[Shell 数组](https://www.runoob.com/linux/linux-shell-array.html)","comments":true,"permalink":"http://yoursite.com/2019/07/12/Shell编程/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"文件","slug":"文件","permalink":"http://yoursite.com/tags/文件/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"},{"name":"Shell","slug":"Shell","permalink":"http://yoursite.com/tags/Shell/"}]},{"title":"设备部署","date":"2019-07-12T01:35:10.676Z","path":"2019/07/12/设备部署/","raw":"---\ntitle: 设备部署\ntags:\n- XShell\n- 网络\n- 设备调试\n- Linux命令\n---\n\n好像有点懂这个设备了。这个设备里面有一个CentOS的Linux系统，可以通过XShell将笔记本和这个Linux系统连接起来，然后就能够通过笔记本电脑操纵这个Linux系统了。这样子的话，电脑虚拟机里面的Ubuntu好像就用不上了哎。当然这个设备现在我还不懂它的商业价值，不知道它是怎么卖的。。\n\n## 排网卡\n昨天硬盘拷贝了之后，网线直连笔记本和设备，MGT口的灯就不亮了，也就是说我没法连接到这台设备了。王佬说是要排网卡。既然笔记本连不上，那就将设备和显示器连起来。将设备插上电源，连上一个键盘，再连上一个显示器，就能够通过显示器来操纵设备了。这个时候是不需要连接网线的。\n\n`ifconfig`命令可以查看系统的ip参数。\n`cat /etc/sysconfig/network-scripts/ifcfg-eth0` 可以查看`eth0`接口的一些参数。因为在`network-scripts`这个文件下只有`ifcfg-eth0`这个文件，没有`ifcfg-MGT`和`ifcfg-eth1`，所以在这里查看到了`eth0`接口的ip，掩码，网关等参数之后，后面就用eth0这个接口来连接了。\n\n在这里查看到了eth0的ip是`192.168.1.119`，而前两天的ip是`192.168.2.138`。硬盘拷贝之后，设备的ip地址也变化了。\n\n既然ip变了，那么想要通过网线直连笔记本和设备的话，笔记本的以太网的ip也要改。要改成同一个网段之内。ip由`192.168.2.110`改成`192.168.1.110`，默认网关也由`192.168.2.1`改成`192.168.1.1`。\n\n`ethtool -p eth0`这个命令执行之后，eth0接口的灯就会亮。参数改为其他的接口，则其他的接口也会亮。比如改为`eth1,MGT`。\n\n王佬说之所以插上网线之后灯不亮，是因为网卡需要重命名。网卡的名称和设备不匹配。王佬修改了SPG这个目录下的`nic_rename.sh`这个文件，这个文件执行一遍之后，灯就会亮了。\n\nnic是网卡的意思（Network Interface Controller，网络适配器），是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件。由于其拥有MAC地址，因此属于OSI模型的第1层物理层。\n\n能连上设备以后，把昨天下载好的版本包放进设备的`/root/tmp`目录下面。通过winSCP来放。\n\n## 解压版本包\n[Linux中文件的压缩和解压缩](https://blog.csdn.net/a1065712890/article/details/78877334)\nLinux中的打包后的文件一般是以`.tar`结尾，压缩后的文件一般是以`.gz`结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般`.tar.gz`。 \n`tar -zcvf xxx.tar.gz a.c b.cpp c.txt`命令将文件打包压缩。\n`tar -zxvf xxx.tar.gz `解压文件夹。\n压缩之后，原来的文件仍继续存在着，和压缩包在同一目录下。解压之后，压缩包也并不消失，和解压出来的文件在同一目录下。\n\n进入解压后的文件，运行一个名称中带有install的文件。这一步就是DPDK。\n\n## 接显示器\n上午弄好的设备，下午又连不上了。这个时候的`ifconfig`后看不到`eth0`，只能看到`KNI0`和`MGT`，是因为上午的install使得dpdk起来了之后，eth0和eth1这些靠后的接口都被接管掉了。因此这时候就只能接MGT口了。\n\n但是这时候KNI0接口的ip和上午的`192.168.1.119`在同一个网段冲突了，所以要把管理口（MGT）的ip改成2网段。\n\n这时候自己搞了一台显示器过来，用网线把笔记本和设备都连接到一个集线器hub上。找不到集线器，王佬就把一个路由器改装成了集线器。连接在集线器上面，这样电脑和设备就都在2网段之内了。好像通过网线连接这个方式的话，电脑就会自动变成DHCP分配ip的方式。显示器一端连电源，另一端通过VGA线连接设备。\n\n终于有自己的显示器了！！！！\n\n## 集线器\n集线器Hub的主要功能是对接收到的信号进行再生整形放大，以扩大网络的传输距离，同时把所有节点集中在以它为中心的节点上。它工作于OSI参考模型物理层。集线器采用CSMA/CD（带冲突检测的载波监听多路访问技术)介质访问控制机制。集线器不具备交换机所具有的MAC地址表，所以它发送数据时都是没有针对性的，而是采用广播方式发送。也就是说当它要向某节点发送数据时，不是直接把数据发送到目的节点，而是把数据包发送到与集线器相连的所有节点。HUB是一个多端口的转发器，当以HUB为中心设备时，网络中某条线路产生了故障，并不影响其它线路的工作。\n\n## 配置MGT口\n给MGT分配一个2网段下面的ip地址。将原来有的`ifcfg-eth0`这个保存`eth0`接口配置信息的文件，给改成`ifcfg-MGT`，并把后面的`divece=eth0`改成`device=MGT`。事先ping一个不通的ip即表示这个ip还没有人用，并且是在150之后，我选择了166这个ip，即`192.168.2.166`。\n\n## 修改nic_rename.sh \n这个是网卡重命名的文件，有一行是`ifconfig 40.40.40.128`这样子的，表示重启之后 MGT口的ip就会变成这样子。通过`/40`这一句就可以定位到这一行，将它注释掉。\nlinux下的文件，加一个#就是注释的意思。\n在文件的默认模式里，/xxxx就是查找的意思，查找到之后，按<kbd>n</kbd>就是查找下一个。\n\n## XShell的编码格式\nXShell执行一些指令之后，会出现乱码，这时候在上方的菜单栏，将编码格式改成`GB2312`，即简体中文。\n\n##数据库初始化\n进入`https://192.168.2.166:8443/DRMInitProject`进行数据库的测试连接与初始化。按照文档的步骤来。其中，登录密码是`Smartsecuri@6300`。\n\n## 运行Shell文件\n在XShell里面，`sh ./abc.sh`即可运行当前目录下的.sh文件。\n\n## 杀java进程\n`ps -ef|grep java`杀死java相关的进程。ps是查看进程，e是显示全部进程，f是指显示的进程以全格式显示出来。|是管道，这个符号前后的两条指令同时运行。grep(global regular expresion print，全局正则表达式版本)是一个文本搜索工具，使用正则表达式搜索文本。这一句命令就是杀死所有的java进程。\n[ps -ef|grep详解](https://www.cnblogs.com/freinds/p/8074651.html)\n\n有一个java进程杀不掉，每次kill之后再次ps查看还是存在，并且进程号还会每次都发生变化，是因为这个进程占用CPU的时间是0，相当于这个进程已经是不存在了。\n\n使用ls查看文件或者目录的时候，`ls  *.cpp`和`ls | grep .cpp`是等价的。只不过，前者的话会将结果中的`.cpp`这一部分高亮显示出来。\n\n## 设置TAB键缩进值\n在编辑文件的时候，linux的TAB键默认的缩进值是8个空格。`cd /etc`，`vim vimrc`编辑这个文件，在后面加上一行，`set ts=4`即可（ts是tabstop的意思）\n\n## 安装GCC\n公司的这个设备里还没有安装GCC。`yum install gcc libcurl-devel libevent-devel numactl-devel openssl-devel libxml2-devel`。其中`yum install gcc`是安装gcc的意思，后面还有5个模块开发包需要安装。\n\n安装完之后，可以用`gcc --version`查看版本。\n\n`gcc -o test.exe test.c`编译文件。`-o`是用来指定编译后的文件名的，如果不指定的话，就会生成`a.out`文件。\n\n注意，linux下文件的后缀名是仅仅起着标识的作用，并没有什么深层次的作用。因此linux系统判断一个文件是不是可执行文件，首先是要看文件的属性是不是可执行的。因此，可执行文件的后缀并不一定要是`.exe`哦。\n[Linux的.out是什么文件](https://zhidao.baidu.com/question/16775931.html)\n\n`yum install gcc-c++`安装g++。安装之后的版本，编译同上。\n\n编译一个cpp文件错误，我还以为是g++包安装错了，最后发现是自己程序写错了。。。。\n\n\n\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/12/设备部署/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"设备调试","slug":"设备调试","permalink":"http://yoursite.com/tags/设备调试/"},{"name":"Linux命令","slug":"Linux命令","permalink":"http://yoursite.com/tags/Linux命令/"},{"name":"XShell","slug":"XShell","permalink":"http://yoursite.com/tags/XShell/"}]},{"title":"进程管理","date":"2019-07-11T11:04:25.836Z","path":"2019/07/11/进程管理/","raw":"---\ntitle: 进程管理\ntags:\n- 操作系统\n- Linux\n---\n\n当我们运行程序时，Linux会为程序创建一个特殊的环境，该环境包含程序运行需要的所有资源，以保证程序能够独立运行，不受其他程序的干扰。这个特殊的环境就称为进程。\n每个 Linux 命令都与系统中的程序对应，输入命令，Linux 就会创建一个新的进程。例如使用 ls 命令遍历目录中的文件时，就创建了一个进程。输入一个命令，就会执行一个程序，相应地就会有进程被创建出来。\n系统通过一个五位数字跟踪程序的运行状态，这个数字称为 pid 或进程ID。每个进程都拥有唯一的 pid。理论上，五位数字是有限的，当数字被用完时，下一个 pid 就会重新开始，所以 pid 最终会重复。但是，两个 pid 一样的进程不能同时存在，因为Linux会使用 pid 来跟踪程序的运行状态。\n\n进程定义：进程是可并发执行的程序，是在一个数据集合上的运行过程。\n\n创建进程\n有两种方式来创建进程：前台进程和后台进程。\n\n前台进程\n默认情况下，用户创建的进程都是前台进程；前台进程从键盘读取数据，并把处理结果输出到显示器。我们可以看到前台进程的运行过程。例如，使用 ls 命令来遍历当前目录。这个程序就运行在前台，它会直接把结果输出到显示器。当程序运行在前台时，由于命令提示符($)还未出现，用户不能输入其他命令；即使程序需要运行很长时间，也必须等待程序运行结束才能输入其他命令。\n\n后台进程\n后台进程的优点是不必等待程序运行结束就可以输入其他命令。创建后台进程最简单的方式就是在命令的末尾加 &，例如：`$ls ch*.doc &`\n每次输入一个后台进程命令，都会即时地显示这个后台进程所分配的后台序号以及进程id。\n每次输入一个命令，不管是前台还是后台，都会在输入之后，将当前已经完成的后台进程显示出来。\n后台进程结束与被杀死是不一样的。只要它还活着，后台进程序号就会被它占用，后面来的其他后台进程的序号就要往下排。\n\nps 命令查看进程的运行状态，包括后台进程。还可以结合 -f(full) 选项查看更多信息\nUID      PID  PPID C STIME    TTY   TIME CMD\n\nUID \t进程所属用户的ID，即哪个用户创建了该进程。\nPID \t进程ID。\nPPID \t父进程ID，创建该进程的进程称为父进程。\nC \tCPU使用率。\nSTIME \t进程被创建的时间。\nTTY \t与进程有关的终端类型。\nTIME \t进程所使用的CPU时间。\nCMD \t创建该进程的命令。\n\n终止进程\n前台进程通过 Ctrl+C 杀死进程\n后台进程先通过 ps 获取进程id ，再通过 kill 命令杀死进程。\n如果进程忽略 kill 命令，那么可以通过 kill -9 来结束：$kill -9 6738\n\nkill命令向操作系统内核发送一个信号和目标进程的id，系统内核根据这个信号，对相应的进程进行操作。\n`kill -l `查看kill命令的所有信号编号及其含义。\n编号2是非强制性结束进程，Ctrl+C即是这样。\n编号9是强制性结束进程。\n编号15是kill的默认信号，正常结束进程。\n[Linux kill命令详解：终止进程](http://m.biancheng.net/view/1068.html)\n\n父进程和子进程\n每个 Linux 进程会包含两个进程ID：当前进程ID(pid)和父进程ID(ppid)。\n\n僵尸进程和孤儿进程\n正常情况下，子进程被终止时会通过 `IGCHLD `信号通知父进程，父进程可以做一些清理工作或者重新启动一个新的进程。但在某些情况下，父进程会在子进程之前被终止，那么这些子进程就没有了“父亲”，被称为孤儿进程。这时init 进程会成为所有孤儿进程的父进程。init 的 pid 为1，是Linux系统的第一个进程，也是所有进程的父进程。\n\n如果一个进程被终止了，但是使用 ps 命令仍然可以查看该进程，并且状态为 Z，那么这就是一个僵尸进程。僵尸进程虽然被终止了，但是仍然存在于进程列表中。一般僵尸进程很难杀掉，你可以先杀死他们的父进程，让他们变成孤儿进程，init 进程会自动清理僵尸进程。\n\n常驻进程\n常驻进程一般是系统级进程，以 root 权限运行在后台，可以处理其他进程的请求。常驻进程没有终端，不能访问 `/dev/tty `文件，如果使用 `ps -f `查看该进程，tty 这一列会显示问号(?)。更确切地说，常驻进程通常运行在后台，等待指定事件发生，例如打印进程是一个常驻进程，它会等待用户输入打印相关的命令并进行处理。\n\n\n任务和进程\n任务(task)指的是一系列共同达到某一目的的操作。例如，读取数据并将数据放入内存中。这个任务可以由一个进程来实现，也可以由多个进程来实现。  每个任务都有一个数字表示的任务号。\n进程(process)常常被定义为程序的执行。可以把一个进程看成是一个独立的程序，在内存中有其完备的数据空间和代码空间。一个进程所拥有的数据和变量只属于它自己。\njobs 命令可以用来查看系统中正在运行的任务，包括后台运行的任务。该命令可以显示任务号及其对应的进程ID。一个任务可以对应于一个或者多个进程号。\njobs 命令的 -l 选项可以查看当前任务包含的进程ID。\n\n\nfg 命令可以将后台任务调到前台，·`$fg %jobnumber`。\nbg 命令可以将前台暂停的任务，调到后台继续运行，`$bg %jobnumber`。\n如果希望将当前任务转移到后台，可以先 Ctrl+z 暂停任务，再使用 bg 命令。任务转移到后台可以空出终端，继续输入其他命令。\n转移的时候，如果前台或者后台只有一个任务，那么可以不指定任务号。\n\n","comments":true,"permalink":"http://yoursite.com/2019/07/11/进程管理/","categories":[],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"Linux命令","date":"2019-07-11T11:00:03.455Z","path":"2019/07/11/Linux命令/","raw":"---\ntitle: Linux命令\ntags:\n- Linux\n- 命令\n---\n\n## mv移动文件与文件重命名\n`mv ../a.cpp ./`\n`mv a.cpp abc.cpp`    重命名的时候，如果涉及到了路径，就会被当成是移动操作，所以在重命名之前要先进入指定目录\n\n## cat查看文件\n`cat -n ../linux命令.txt |more`\n-n 显示行号，并且带上管道命令|more来分页浏览\n\n## vim编辑器\n```cpp\ntouch abc.cpp  #创建文件\nvim abc.cpp  #进入vim编辑器，默认是一般模式\ni                  #进入编辑模式\n`#include<iostream>` #编辑文件\n按键esc            #退出编辑模式，回到一般模式\n:wq                #:是进入命令模式，w保存文件，q退出文件\ng++ -o abc.exe abc.cpp #编译程序\n./abc.exe   #运行当前目录下的abc.exe这个可执行程序\n```\n## 在一般模式下可以使用的快捷键：\n```cpp\nyy 拷贝当前行\n5yy  拷贝以下5行\np  小写，在当前行的后面一行粘贴 \nP  大写，在当前行的前面一行粘贴\n:/endl  在命令行下查找关键字,输入n则继续查找下一个\n:set nu 设置文件显示行号\n:set nonu 取消显示文件行号\nu 撤销动作\n~ 改变大小写\n跳转到指定行:先设置好行号，输入16，按下shift+g，即可跳转\nG:跳转到首行\ngg:跳转到尾行\ndd  删除当前行\n5dd  删除以下5行\n保存退出：shift+zz(两个大写的z)，:wq\n不保存退出：shift+ZQ，:q!（不保存强制退出的意思）\nshift+<<和shift+>>   向前向后缩进\n:%s/x/y/g  全局将x用y替换掉\n```\n\n## 获取帮助命令：\n```\nman ls\nhelp ls\n```\n## pwd:获取当前目录的绝对路径\n\n## ls\n`ls -a(all)`查看当前目录下的所有文件和目录，包括.当前目录和..上一级目录\n`ls -l`以列表的形式显示出来(可以简写为 `ll`)\n\n## cd\n`cd  cd~  `返回家目录\n`cd ..    `返回上一级目录\n`cd /home/xtncsg/桌面 ` 进入一个绝对路径\n\n\n## 创建\n创建文件:`touch abc.cpp`\n创建目录:`mkdir ./hello`\n创建多级目录: `mkdir -p ./hello/nm/tmd`\n\n## 删除\n删除文件:`rm abc.txt`\n删除空目录：`rmdir hello`\n删除非空目录: `rm -rf abc`\n删不掉的话，试试加一个 -f 选项\n-r表示递归删除，删除该目录下的所有文件以及目录，-f表示强制删除\n\n\n## cp\ncp 原文件或目录 目的文件或目录   拷贝文件（Copy）\n-r 递归拷贝整个目录\n\n\n## 标准的Linux流\n一般情况下，每个linux程序运行都会创建三个文件流（三个文件）\n标准输入流:文件描述符为0，linux程序默认从stdin读取数据\n标准输出流:文件描述符为1，linux程序默认向stdout输出数据\n标准错误流:文件描述符为2，linux程序会向stderr写入错误信息\n这三个流都是文件，都有各自不同的文件描述符。\n\n## 终端\n按下 `ctrl+alt+t`进入终端（Ubuntu虚拟机终端）\n`exit `退出终端\n上下方向键可以回到之前输入过的命令\n\n## 清空\n`clear`终端内容向下翻开新的一页，终端内容并不消失\n`reset`清空终端的内容\n\n## 日期\n`date`获取当前日期以及时间\n`date +\"格式字符串\"`   以特定格式输出时间\n%Y:四位数的年份   %y:两位数的年份  \n%D:含有年月日的日期  %d:仅仅含有日期\n%H:小时   %M:分钟   %S:秒钟  %m:月份\n\n## 重复执行某个指令：\n`watch -n 3 -d -t '需要重复的命令'`\n3秒运行一次，不写则默认2秒。n是interval间隔时间，d是difference，将每一次显示的内容中出现变化的部分高亮显示，t是去除最顶端显示的时间。\n比如， `watch -n 10 -d -t 'date +\"%H:%M:%S\"'`\n[Linux系统中重复执行命令的方法](http://m.xuexila.com/diannao/xitong/linux/2865556.html)\n\n## 用户登录相关\n`passwd`更改密码\n`whoami`查看用户id\n## 日历\n`cal`查看日历\n\n##wc\n`wc filename1 filename2`\n显示当前文件的总行数，单词数，字节数，文件名\n可以一次统计多个文件的信息\n单纯的`wc`命令会显示文件的行数，单词数，字节数。使用`wc -l `命令则只显示文件的行数。\n\n# &  &&  |   ||命令中的特殊符号\n& 表示任务后台执行，后台进程。\n&& 连接两个命令，前一个命令执行成功后才会执行后一个命令。\n|  管道，前一个命令执行的结果作为后一个命令的输入。\n||  连接两个命令，前一个命令执行失败后才会执行后一个命令。\n\n<blockquote>> 重定向写，覆盖写</blockquote>\n<blockquote>>>重定向写，追加写</blockquote>\n\n&> 表示stderr标准错误输出信息重定向输出，覆盖写。同样也有追加写。\n`lll&>test.c`\n\n[Linux中&&、&、|、||等特殊符号](https://blog.csdn.net/bocai8058/article/details/82932397)\n\n# 压缩解压缩\n## 使用tar压缩文件\n`tar -zcvf test.tar.gz ./test/`\n该命令表示压缩当前文件夹下的文件夹test，压缩后缀名为`test.tar.gz`。\n如果不需要压缩成gz，只需要后缀为tar格式的，那么输入`tar -cvf test.tar ./test/`。\n## 使用tar解压文件\n`tar -xzvf test.tar.gz  `\n该命令表示把后缀为`.tar.gz`的文件解压到当前文件夹下。如果压缩文件的后缀是.tar，没有gz，则使用`tar -xvf test.tar`。\n不管是压缩还是解压缩，处理之后的文件都是和原文件在同一个文件夹下面，原文件并不会消失。以压缩为例，A目录下有一个压缩包B，解压之后，A目录下就有了B目录和之前的B压缩包。\n[tar压缩和解压文件或文件夹](https://blog.csdn.net/stf1065716904/article/details/81909320)\n\n# tail 命令\ntail命令是用来查看文件的，查看文件末尾的若干行。-n选项用来指定行数，不加则默认10行。\n`tail -3 test.c`查看文件末尾三行。\n-f 选项后面加上文件路径，用来查看文件动态变化的内容。\n`tail -f /SPG/Tomcat-JKD/logs/catalina.out`追踪日志文件动态变化的内容。\n[Linux中的tail命令](https://blog.csdn.net/y_bccl27/article/details/86678252)\t\n","comments":true,"permalink":"http://yoursite.com/2019/07/11/Linux命令/","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}]},{"title":"XShell连接Ubuntu","date":"2019-07-10T14:01:39.323Z","path":"2019/07/10/XShell连接Ubuntu/","raw":"---\ntitle: XShell连接Ubuntu\ntags: \n- ubuntu\n- 网络\n---\n\n### 查看ubuntu的版本\n`lsb_release -a`\n[Ubuntu-查看ubuntu系统的版本信息](https://jingyan.baidu.com/article/ca41422f0ab38f1eae99edc3.html)\n\n### 设置虚拟机静态ip\n虚拟机中ubuntu的网络连接模式，我给设置成了NAT模式，之前是桥接模式。\n\n在网络适配器里面，将VMnet8这个网络的ipv4属性修改为：\nip地址：`192.168.29.1`\n子网掩码：`255.255.255.0`\n\n在虚拟机的虚拟网络编辑器，VMnet8这个网络的模式是NAT模式，选中“将主机虚拟适配器连接到此网络”，“使用本地DHCP服务将ip地址分配给虚拟机”，这两个本来就是选中状态的。\n\n可以在这个界面进入NAT设置和DHCP设置，得到`子网ip：192.168.29.0`，`掩码：255.255.255.0`，`网关ip：192.168.29.2`，`起始ip地址：192.168.29.128`，`末尾ip地址：192.168.29.254`。\n\n设置ubuntu系统的静态ip地址时，其要在这个ip地址的范围内。在这里我设置成，`192.168.29.168`。\n\n进入ubuntu系统，`cd /etc/network`，`sudo vi interfacces`。这个文件本来是只有最开始的两行的，后来给他加上：\n```\niface ens32 inet static\naddress 192.168.29.168   #静态的ip地址\nnetmask 255.255.255.0    #子网掩码\ngateway 192.168.29.2     #网关地址\ndns-nameservers 192.168.29.2   #dns地址\nauto ens32\n```\n在相对较早的版本中，你需要设置/etc下的`resolv.conf`文件，并加入nameserver，这样才可以连接互联网。但在Ubuntu 12.04之后，已经不推荐这种方式了，因为无论你想该配置文件中设置什么值，重新启动之后都会被还原为初始状态。推荐的做法是直接在interfaces配置文件中加入dns-nameserver <网关IP>这一行。\n\n确实是这样，在`sudo vi /etc/resolv.conf`里面加上 `nameserver 192.168.29.2`这一行，可以ping的通域名以及ip地址，但是一重启之后就会回复成`127.0.0.53`。\n\n在interfaces里面改，只能ping的到8.8.8.8这样的ip地址，但是ping不通`www.baidu.com`这样的域名。在`resolv.conf`里面改，都可以ping得通，但是一重启就会恢复成原来的数据。\n\n在修改文件的指令前加上sudo ，是因为这些文件默认是只读（readonly)，要不然修改过后不让保存。\n[用vi编辑 /etc/inittab 为readonly应怎样改设置](https://zhidao.baidu.com/question/1239262216463248139.html?word=%E5%B7%B2%E8%AE%BE%E5%AE%9A%E9%80%89%E9%A1%B9readonly)\n[设置ubuntu的静态Ip](https://www.cnblogs.com/alummox/articles/7040408.html)\n[ping: www.baidu.com: 未知的名称或服务（亲测有效](https://blog.csdn.net/weixin_42859280/article/details/89281862)\n这里dns的地址不写114.114.114.114，而是写网关地址，因为这里的dns地址必须要和ip地址在同一网段内。\n[Ubuntu下不能解析域名（ ping：unknown host ）](https://blog.csdn.net/Heimerdinger_Feng/article/details/55099635)\n[ubuntu永久设置静态ip地址方法](https://jingyan.baidu.com/article/7f41ecec5d6014593d095ce0.html)\n\n关于这个恢复的问题，在`/etc/dhcp/dhclient.conf`中找到`prepend domain-name-servers 127.0.0.53;`并修改为`prepend domain-name-servers 192.168.29.2;`。但是可惜并不管用。\n[ubuntu重启后DNS恢复问题](https://holmesian.org/amp/ubuntu-dns-resolv-dhclient)\n\n### openssh-server\n最初安装的 Ubuntu 主机是没有开启 SSH 服务的，需要开启 openssh-server。`ps -e|grep ssh`查看进程， 如果只有 `sshd-agent `，需要`sudo apt-get install openssh-server`进行安装，安装之后再查看进程，就会有`ssh-agent`和`sshd`这么两个进程。\n`sudo /etc/init.d/ssh restart`重启`ssh-server`。\n`vim /etc/ssh/sshd_config`，将 PermitRootLogin 改为 yes 。\n[使用 Xshell 连接 Ubuntu 详解](https://blog.csdn.net/qq_40606798/article/details/82622376)\n\n[最初的参考文献---用xshell连接VMware中的Linux](https://blog.csdn.net/n950814abc/article/details/79512834)\n\n整个过程中成功了那么一两次，开机后修改/etc/resolv.conf里面的dns地址，使得ubuntu能够ping域名和ip地址，这时基本上就能够成功了。但是用XShell连接之后，如果将虚拟机关闭掉了，连接也就会断掉，这个连接必须要虚拟机开着才能连接好像？？？？","comments":true,"permalink":"http://yoursite.com/2019/07/10/XShell连接Ubuntu/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"ubuntu","slug":"ubuntu","permalink":"http://yoursite.com/tags/ubuntu/"}]},{"title":"视频核心网关设备调试","date":"2019-07-10T02:27:56.647Z","path":"2019/07/10/视频核心网关设备调试/","raw":"---\ntitle: 视频核心网关设备调试\ntags:\n- 网络\n- TCP/IP\n- 设备调试\n---\n\n### 设备调试\n今天早上拿来的视频核心网关设备，这台设备里面存储有代码，我们需要将笔记本电脑与它连接起来。\n\n将设备插上电源，用网线将它的MGT口和显示器连接起来，获取DHCP自动为它分配的IP地址，一大波操作之后，得到是`192.168.2.138`。网线直连SPG6300设备的MGT口，开机启动后DHCP分配的ip地址在0-150，这里是138。\n\n获得了之后，就不需要显示器了，可以在自己的笔记本上面调试。用网线将它（MGT）和笔记本连接起来，在XShell里面输入`ssh 192.168.2.138`登陆远程主机（该设备），让输入用户名，这里输入`root`，然后输入密码，这里是`Smartsecuri@6300`，这样就登陆上了这台设备。\n\n输入命令`vi /etc/sysconfig/network-scripts/ifcfg-MGT`，可以查看MGT口的配置。\n```\ndefroute = yes\ndns = 114.114.114.114   //dns地址\ngateway = 192.168.2.1   //默认网关\nonboot = yes            //自启动允许\nipaddr = 192.168.2.138  //设备的ip地址\nbootproto = static      //这里好像是说静态ip的意思\ntype = ethernet         //连接方式为以太网\n```\n### ip地址，子网掩码，网关，默认网关\n用网线将笔记本与设备连接起来之后，会多出一个以太网的连接。在更改网络适配器的界面点击这个以太网的属性，查看ipv4这个项目的属性，将ip地址改为`192.168.2.110`，子网掩码改为`255.255.255.0`,默认网关改为`192.168.2.1`。\n\nip地址在设计时就分割成网络号与主机号两部分，这是方便ip地址的寻址。通过指定子网掩码，就可以指定哪些位是网络号，哪些位是主机号。这里使用的是C类ip地址的默认的子网掩码`255.255.255.0`，即`192.162.2`表示网络号，`138`表示主机号。之前在一篇文章里看到用XShell连接windows与虚拟机里面的linux时说到，主机的ip地址要有虚拟机的ip不同（两个不同的主机，ip地址肯定是不同的），这里远程主机是`192.168.2.138`，本地主机设置成`192.168.2.110`，二者不同且要在同一网段内，这样才可以实现交互。\n\n[子网掩码](https://baike.baidu.com/item/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81/100207?fr=aladdin)\n\nC类IP地址(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类IP地址的最前面为“110”，所以地址的网络号取值于192~223之间。一般用于小型网络。A,B,C三类ip地址都各自保留有一个区域用作私有ip地址（用于NAT地址转换），其中C类ip地址保留的私有ip地址范围是`192.168.0.0～192.168.255.255`，也就是说这里的两台主机的ip地址都是私有ip地址。\n\n[IP地址分类（A类 B类 C类 D类 E类）](https://www.cnblogs.com/tunian/p/9632893.html)\n\n网关(Gateway)在传输层上以实现网络互连，仅用于两个高层协议不同的网络互连。 网关是一种充当转换重任的计算机系统或设备。在使用不同的通信协议、数据格式或语言，甚至体系结构完全不同的两种系统之间，网关是一个翻译器。与网桥只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。大多数网关运行在OSI 7层协议的顶层–应用层。\n\n有网络A和网络B，网络A的IP地址范围为`192.168.1.1~192. 168.1.254`，子网掩码为`255.255.255.0`；网络B的IP地址范围为`192.168.2.1~192.168.2.254`，子网掩码为`255.255.255.0`。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(`255.255.255.0`)判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。\n\n因此，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。所以，这里的`192.168.2.1`应该是公司里某一台电脑或者设备的IP地址 。\n\n一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。一台电脑的默认网关必须正确地指定，否则一台电脑就会将数据包发给不是网关的电脑，从而无法与其他网络的电脑通信。默认网关必须是电脑自己所在的网段中的IP地址，而不能填写其他网段中的IP地址。 这里在子网掩码`255.255.255.0`下，ip地址`192.168.2.110`和默认网关`192.168.2.1`确实在同一网段下。\n\n默认网关的设置有两种方式：\n1. 如上文所述，手动更改。\n2. 自动设置就是利用DHCP（Dynamic Host Configuration Protocol, 动态主机配置协议）服务器来自动给网络中的电脑分配IP地址、子网掩码和默认网关 。这样做的好处是一旦网络的默认网关发生了变化时，只要更改了DHCP服务器中默认网关的设置，那么网络中所有的电脑均获得了新的默认网关的IP地址。\n\n[IP地址、子网掩码、默认网关是什么意思？](https://www.cnblogs.com/santiaoa/p/5706465.html)\n\n### winSCP\n打开winSCP客户端，这是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。输入主机名（192.168.2.138，即我想登录的那台远程主机的ip地址），用户名（root）和密码（Smartsecuri@6300）就能实现远程连接了，可以在winSCP里面显式地查看该设备里面的文件目录。\n\n之前那个大箱子里面保存代码的文件夹，`SmartSecuri-IoT`和`SmartSecuri-Platform`，将它拷贝到小箱子（拿过来的这台设备）里面，使`opt/iot/SmartSecuri-IoT/trunk/gateway/build`这个路径能够进入。\n\n进入路径，在XShell里面输入`cd /opt/iot/SmartSecuri-IoT/trunk/gateway/build`，执行里面的`quick.sh`文件，即在XShell里面输入`./quick.sh`。\n\n杀死进程/部署安装：`pkill fwd; cp fwd/release/G2030_e1000e/fwd_G2030_e1000e  /SPG/bin/fwd/pkg/G2030_e1000e/ &&  /SPG/bin/fwd/start_fwd.sh G2030_e1000e`\n","comments":true,"permalink":"http://yoursite.com/2019/07/10/视频核心网关设备调试/","categories":[],"tags":[{"name":"网络","slug":"网络","permalink":"http://yoursite.com/tags/网络/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"},{"name":"设备调试","slug":"设备调试","permalink":"http://yoursite.com/tags/设备调试/"}]},{"title":"字节对齐","date":"2019-07-08T01:54:11.031Z","path":"2019/07/08/字节对齐/","raw":"---\ntitle: 字节对齐\ntags:\n- C++\n- 编程\n---\n\n计算机中内存大小的基本单位是字节（byte），理论上来讲，可以从任意地址访问某种基本数据类型，但是实际上，计算机并非逐字节大小读写内存，而是以2,4,或8的 倍数的字节块来读写内存。\n\n若结构体首地址为0，那么每个成员的首地址应该是成员大小的整数倍。如不满足，对前一个成员填充字节以满足。结构体的总大小应该是其最大的那个成员大小的整数倍，如不满足，最后填充字节以满足。这个主要是考虑到结构体数组的情况，比如struct A[2],若是A[0]后面不填充，那么A[1]的首地址是14，不满足要求。\n\n计算机每次读写一个字节块，例如，假设计算机总是从内存中取8个字节，如果一个double数据的地址对齐成8的倍数，那么一个内存操作就可以读或者写，但是如果这个double数据的地址没有对齐，数据就可能被放在两个8字节块中，那么我们可能需要执行两次内存访问，才能读写完成。显然在这样的情况下，是低效的。所以需要字节对齐来提高内存系统性能。\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n    struct A{\n        int a;  //0 1 2 3\n        char b; //4\n        int c;  //8 9 10 11\n        short d;//12 13\n    };\n    cout<<sizeof(struct A)<<endl;\n\n    struct B{   //设计结构的时候，合理调整成员的位置，可以大大节省存储空间。\n        int a;\n        char b;\n        short c;\n        int d;\n    };\n    cout<<sizeof(struct B)<<endl;\n\n    class C{\n        int a;\n        char b;\n        int c;\n        short d;\n    };\n    cout<<sizeof(C)<<endl;\n\n    /*由于不同平台对齐方式可能不同，如此一来，同样的结构在不同的平台其大小可能不同,在无意识的情况下，互相发送的数据可能出现错乱，甚至引发严重的问题。因此，为了不同处理器之间能够正确的处理消息，我们有两种可选的处理方法。*/\n\n\n    //使用伪指令#pragma pack(n)（n为字节对齐数）来使得结构间一字节对齐。\n    //这样做能够保证跨平台的结构大小一致，同时还节省了空间，但不幸的是，降低了效率。\n    #pragma pack(1)\n    struct D{\n        int a;\n        char b;\n        int c;\n        short d;\n    };\n    cout<<sizeof(struct D)<<endl;\n    #pragma pack()  //还原默认对齐\n\n    //除了前面的1字节对齐，还可以进行人为的填充，访问效率高，但并不节省空间\n    struct E{\n        int a;\n        char b;\n        char reserve1[3];\n        int c;\n        short d;\n        char reserve2[2];\n    };\n    cout<<sizeof(struct E)<<endl;\n\n    #pragma pack(2)\n    struct F{\n        int a;\n        char b;\n        int c;\n        short d;\n    };\n    cout<<sizeof(struct F)<<endl;\n    #pragma pack()\n\n    struct G{\n        int a;\n        char b;\n        double c;\n        int d;\n    };\n    cout<<sizeof(struct G)<<endl;\n\n    return 0;\n}\n```\n程序输出如下：\n```C++\n16\n12\n16\n11\n16\n12\n24\n```","comments":true,"permalink":"http://yoursite.com/2019/07/08/字节对齐/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"入职软件安装","date":"2019-07-06T10:13:53.930Z","path":"2019/07/06/入职软件安装/","raw":"---\ntitle: 入职软件安装\ntags:\n- 电脑\n- 软件使用\n- 骚操作\n- 版本控制\n---\n## Source Insight 4.0 \n[Source Insight 4.0 最简单的破解安装](https://blog.csdn.net/biubiuibiu/article/details/78044232)\n[Source Insight 4使用技巧整理](https://blog.csdn.net/superhcq/article/details/79279385)\n\n## TeamViewer\n[TeamViewer介绍及安装使用教程](https://baijiahao.baidu.com/s?id=1627671320261184995&wfr=spider&for=pc)\n\n## TortoiseSVN\n[如何关闭win10驱动程序强制签名](https://blog.csdn.net/loongsking/article/details/80036974)\n[Win10怎么关闭UAC控制?win10关闭uac方法](https://jingyan.baidu.com/article/fc07f9897fd90712fee51976.html)\n[win10怎么关闭防火墙](https://jingyan.baidu.com/article/17bd8e52083ce685ab2bb839.html)\n[TortoiseSVN 使用教程](https://www.runoob.com/svn/tortoisesvn-intro.html)\n\n\n[windows资源管理器任务结束了怎么办？](https://zhidao.baidu.com/question/1732358143096700827/answer/2893530991.html?fr=index_ans&word=%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%BB%93%E6%9D%9F%E4%BB%BB%E5%8A%A1)\n\n[SVN与Git的区别](https://www.jianshu.com/p/ba82b28b82f7)\n\n[TortoiseSVN使用方法](https://blog.csdn.net/dily3825002/article/details/6717076)","comments":true,"permalink":"http://yoursite.com/2019/07/06/入职软件安装/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"},{"name":"骚操作","slug":"骚操作","permalink":"http://yoursite.com/tags/骚操作/"},{"name":"软件使用","slug":"软件使用","permalink":"http://yoursite.com/tags/软件使用/"},{"name":"版本控制","slug":"版本控制","permalink":"http://yoursite.com/tags/版本控制/"}]},{"title":"FTP文件传输协议","date":"2019-07-06T10:13:50.993Z","path":"2019/07/06/FTP文件传输协议/","raw":"---\ntitle: FTP文件传输协议\ntags:\n- 网络协议\n---\nFTP（File Transfer Protocol）是TCP/IP网络上两台计算机传送文件的协议，属于应用层。FTP客户机可以给服务器发出命令来下载文件，上载文件，创建或改变服务器上的目录。相比于HTTP，FTP协议要复杂得多。复杂的原因，是因为FTP协议要用到两个TCP连接，一个是命令链路，用来在FTP客户端与服务器之间传递命令，服务器使用21号端口；另一个是数据链路，用来上传或下载数据，服务器使用端口号20。FTP是基于TCP协议的，因此iptables防火墙设置中只需要放开指定端口（21 + PASV端口范围）的TCP协议即可。\n \n**FTP的两种工作模式：**\n==PORT（主动）方式==\n客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，客户端在命令链路上用PORT命令告诉服务器：“我打开了一个1024+的随机端口，你过来连接我”。于是服务器从20端口向客户端的1024+随机端口发送连接请求，建立一条数据链路来传送数据。\n\n==PASV（Passive被动）方式==\n客户端向服务器的FTP端口（默认是21）发送连接请求，服务器接受连接，建立一条命令链路。当需要传送数据时，服务器在命令链路上用PASV命令告诉客户端：“我打开了一个1024+的随机端口，你过来连接我”。于是客户端向服务器的指定端口发送连接请求，建立一条数据链路来传送数据。\n\nPORT方式，服务器会主动连接客户端的指定端口，那么如果客户端通过代理服务器链接到internet上的网络的话，服务器端可能会连接不到客户端本机指定的端口，或者被客户端、代理服务器防火墙阻塞了连接，导致连接失败。PASV方式，服务器端防火墙除了要放开21端口外，还要放开PASV配置指定的端口范围。","comments":true,"permalink":"http://yoursite.com/2019/07/06/FTP文件传输协议/","categories":[],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"http://yoursite.com/tags/网络协议/"}]},{"title":"STL","date":"2019-07-06T09:35:32.585Z","path":"2019/07/06/STL总述/","raw":"---\ntitle: STL\ntags:\n- C++\n---\nC++的核心优势在于，便于软件的重用。主要从：\n- 面向对象的思想，继承和多态\n- 泛型程序设计，STL\n两方面实现。\n\n容器都是类模板，分为三类：\n- 顺序容器：vector，deque（双向队列）,list（双向链表）\n- 关联容器（内部元素有序）：set，multiset，map，multimap\n- 容器适配器：stack，queue，priority_queue\n\n关联容器一般通过平衡二叉树的方式实现，因为有序，所以可以通过类似折半查找的方法来查找，因此查找和插入都是`O(log n)`。\n","comments":true,"permalink":"http://yoursite.com/2019/07/06/STL总述/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Deque","date":"2019-07-06T09:34:29.735Z","path":"2019/07/06/Deque/","raw":"---\ntitle: Deque\ntags:\n- C++\n- STL\n---\n\n双端队列，内存连续存放，随机存取任何元素都能在常数时间内完成（但次于vector）。\n![enter image description here](https://img-blog.csdnimg.cn/20190623200402653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n在这张图里，随机存取一个元素，地址可能会超出右边界，此时回过头从左边继续查找，这里需要做取余的操作。而Vector存取元素没有这一步。\n在两端增删元素，大部分时候，可以在常数时间内完成（除非此时需要重新分配内存）。","comments":true,"permalink":"http://yoursite.com/2019/07/06/Deque/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"迭代器","date":"2019-07-06T09:32:37.433Z","path":"2019/07/06/迭代器/","raw":"---\ntitle: 迭代器\ntags:\n- C++\n- STL\n---\n\n```c++\nvector<int>::iterator it1;  \nvector<int>::reverse_iterator it2;  //反向迭代器\nvector<int>::const_iterator it3;   //常量迭代器\n```\n不能通过常量迭代器修改元素内容，`*it2=20;`这是错误的。\n双向迭代器：\n`++p,--p,*p,p=p1(赋值),p==p1,p!=p1(判断是否相等)`\n随机访问迭代器：\n除了双向迭代器的所有功能之外，还有\n`p+i,p-i,p+=i,p-=i（迭代器前后移动）,p[i]（迭代器p后面第i个元素的引用）,p>(>=,<,<=)p1`\n\nvector和deque是随机迭代器\nlist和set/multiset，map/multimap是双向迭代器\n容器适配器（queue，priority_queue，stack）只能访问栈顶，队首之类的元素，不能访问队列中间的元素，因此不需要迭代器。\n\nvector是随机迭代器，两个随机迭代器之间可以比较大小，因此还可以这样遍历：\n```c++\nfor(vector<int>::iterator it=v.begin();it<v.end();it++)\n\tcout<<*it;\n```\n双向迭代器不能比较大小，因此只能写`it!=v.end()`。\n","comments":true,"permalink":"http://yoursite.com/2019/07/06/迭代器/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"Priority_Queue","date":"2019-07-06T09:29:17.402Z","path":"2019/07/06/Priority_Queue/","raw":"---\ntitle: Priority_Queue\ntags:\n- C++\n- STL\n---\n\n底层用堆实现的优先队列，队首元素是队列中优先级最高的那个。\n基本数据类型中，即默认是数值最大的那个元素。\n优先队列的本质是堆。\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main(){\n    priority_queue<int>q;\n    q.push(2);  //入队，O(log n)\n    q.push(8);\n    q.push(1);\n    cout<<q.size()<<endl; //O(1)\n    cout<<q.top()<<endl; //访问队首元素（堆顶元素）（优先级最大的元素）,O(1)\n\n    if(q.empty()==false){  //判空，O(1)\n        q.pop();  //队首元素出队，之后堆重新调整结构，O(log n)\n    }\n    else cout<<\"队列为空\"<<endl;\n    cout<<q.top();\n\n    return 0;\n}\n```\n### 基本数据类型的优先级设置\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main(){\n    priority_queue<int>q1;\n    priority_queue<int,vector<int>,greater<int> >q2;\n    for(int i=0;i<5;i++){\n        q1.push(i);\n        q2.push(i);\n    }\n    cout<<q1.top()<<\" \"<<q2.top()<<endl;\n    return 0;\n}\n```\n对于基本数据类型，默认数值大（字典序大）的优先级高\n`less<int>`表示数值大的优先级高\n`greater<int>`表示数值小的优先级高\n### 类的优先级设置\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nclass fruit{\n    string name;\n    double price;\npublic:\n    void printInfo()const {cout<<name<<\" \"<<price<<endl;}\n    fruit(string s,double d):name(s),price(d){} //构造函数\n    //为了能够访问私有成员，声明为友元\n    //如果是引用传参的话，一定是常引用\n    friend bool operator< (const fruit& f1,const fruit& f2){  //重载小于号\n        return f1.price<f2.price;  //重载后小于号还是小于号的作用\n        //因此采用的仍然是默认的数值大的放在队首的规则\n    }\n};\n\nint main(){\n    priority_queue<fruit>q;\n    fruit apple(\"apple\",15);\n    fruit banana(\"banana\",14);\n    fruit watermelon(\"watermelon\",12);\n    q.push(apple);\n    q.push(banana);\n    q.push(watermelon);\n    q.top().printInfo();\n    return 0;\n}\n```\n`q.top()`返回的是一个常量对象，只能调用构造，析构和常量成员函数\n[passing xxx as 'this' argument of xxx discards qualifiers](https://blog.csdn.net/david_xtd/article/details/28631567)\n只能重载小于号，重载大于号会编译错误，因为`f1>f2`等价于`f2<f1`\n`f1=f2`等价于 `!(f1<f2)&&!(f1>f2)`\n如果写的是`return f1.price>f2.price;`那么就是把小于号重载为大于号的功能\n即把默认的规则反向一下，即数值小的优先级高","comments":true,"permalink":"http://yoursite.com/2019/07/06/Priority_Queue/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"Set","date":"2019-07-06T09:26:59.081Z","path":"2019/07/06/Set/","raw":"---\ntitle: Set\ntags:\n- C++\n- STL\n---\n\n内部自动递增有序且不含重复元素的容器\n```c++\n#include<iostream>\n#include<set>\nusing namespace std;\n\nint main(){\n    set<int>st;\n    for(int i=100;i<=500;i+=100)\n        st.insert(i);\n    st.insert(200);  //插入元素，O(log n)\n    st.insert(350);\n    cout<<st.size()<<endl;\n\n    //set只能通过迭代器访问\n    for(set<int>::iterator it=st.begin();it!=st.end();it++)\n        cout<<*it<<\" \";\n    cout<<\"\\n\";\n\n    //查找,st.find()是set容器的成员函数，O(log n)\n    set<int>::iterator it=st.find(200);\n    if(it!=st.end()){\n        cout<<\"找到了\"<<endl;\n        st.erase(it);  //删除迭代器位置处的元素，O(1)\n    }  //set不支持 it-st.begin()这样的迭代器的增减操作\n    else cout<<\"不存在\"<<endl;\n\n    st.erase(400); //删除指定值的这个元素，O(log n)\n\n    //删除某个区域 [first,last) 的元素，O(last-first)\n    set<int>::iterator itt=st.find(350);\n    st.erase(itt,st.end());\n\n    for(set<int>::iterator it=st.begin();it!=st.end();it++)\n        cout<<*it<<\" \";\n    cout<<\"\\n\";\n\n    st.clear(); //清空，O(n)\n    return 0;\n}\n```\n```c++\n6\n100 200 300 350 400 500\n找到了\n100 300\n``` \n","comments":true,"permalink":"http://yoursite.com/2019/07/06/Set/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"Queue","date":"2019-07-06T09:25:39.772Z","path":"2019/07/06/Queue/","raw":"---\ntitle: Queue\ntags:\n- C++\n- STL\n---\n\n先进先出的限制性数据结构\n使用front()和pop()之前需要判断队列是否为空\n```c++\n#include<iostream>\n#include<queue>\nusing namespace std;\n\nint main(){\n    queue<int>q;\n    for(int i=0;i<5;i++)\n        q.push(i);  //添加队尾元素，O(1)\n    cout<<q.size()<<endl;  //O(1)\n\n    //访问队首队尾元素，O(1)\n    cout<<q.front()<<\" \"<<q.back()<<endl;\n\n    if(q.empty()==false){  //q.pop()之前要判断队列是否为空\n        q.pop(); //队首元素出队，O(1)\n    }\n\n    if(q.empty()==false){  //q.front()之前要判断队列是否为空\n        cout<<q.front()<<\" \"<<q.back()<<endl;\n    }\n    else cout<<\"队列为空\"<<endl;\n    return 0;\n}\n```\n```c++\n5\n0 4\n1 4\n```","comments":true,"permalink":"http://yoursite.com/2019/07/06/Queue/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"Stack","date":"2019-07-06T09:23:54.383Z","path":"2019/07/06/Stack/","raw":"---\ntitle: Stack\ntags:\n- C++\n- STL\n---\n```c++\n#include<iostream>\n#include<stack>\nusing namespace std;\n\nint main(){\n    stack<int>s;\n    for(int i=0;i<5;i++)\n        s.push(i);  //入栈，O(1)\n    cout<<s.size()<<endl; //获取元素个数，O(1)\n    for(int i=0;i<3;i++){\n        if(s.empty()==false)  //判空，O(1)\n            s.pop();  //弹出栈顶元素，O(1)\n        else break;\n    }\n    cout<<s.top()<<endl; //获取栈顶元素，O(1)\n    return 0;\n}\n```\n```c++\n5\n1\n```","comments":true,"permalink":"http://yoursite.com/2019/07/06/Stack/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"String","date":"2019-07-06T09:20:38.697Z","path":"2019/07/06/String/","raw":"---\ntitle: String\ntags:\n- C++\n- STL\n---\n### 访问\n```c++\n#include<iostream>\n#include<string>\n#include<typeinfo>\nusing namespace std;\n\nint main(){\n    string name=\"shen cheng yu\";\n    printf(\"%c\\n\",name[5]); //printf对单个字符进行操作\n    // printf(\"%s\\n\",name); 读入或者输出整个字符串，只能用cin和cout，printf输出会乱码\n    printf(\"%s\\n\",name.c_str());\n\n    //不论是否初始化了，转换后的类型都是const char*，且以'\\0'结尾\n    if(typeid(name.c_str())==typeid(const char*))  cout<<\"yes\\n\";\n    else cout<<\"no\\n\";\n\n    string::iterator it=name.begin();  //通过迭代器增减访问\n    for(int i=0;i<name.size();i++){\n        printf(\"%c\",*(it+i));\n    }\n    printf(\"\\n\");\n\n    for(;it!=name.end();it++){  //通过迭代器访问\n        printf(\"%c\",*it);\n    }\n    printf(\"\\n\");\n\n     //下标运算符不做范围检查\n    for(int i=0;i<15;i++)\n        cout<<name[i];\n    printf(\"\\n\");\n\n    //成员函数str.at[i]会做范围检查，超出范围会抛出out_of_range异常\n    for(int i=0;i<15;i++)\n        cout<<name.at(i);\n    printf(\"\\n\");\n\n    return 0;\n}\n```\n```c++\nc\nshen cheng yu\nyes\nshen cheng yu\nshen cheng yu\nshen cheng yu m\nshen cheng yuterminate called after throwing an instance of 'std::out_of_range'\n```\n[C/C++中检查变量类型函数typeid()](https://blog.csdn.net/haohaibo031113/article/details/72860567)\n### 增加\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    string name=\"shen cheng yu\";\n    string cuteName=\"xtncsg\";\n    string longName=name+\" \"+cuteName; //字符串拼接\n    cout<<longName<<endl;\n\n    //通过成员函数append()进行连接\n    string s(\"abc\");\n    string s1=s.append(cuteName); //s字符串已经被修改了\n    string s2=s.append(cuteName,1,3); //str.append(str2,pos,len)\n    cout<<s1<<\" \"<<s2<<endl;\n\n    //str.insert(pos,str2)，这里不能用迭代器作为插入位置，O(n)\n    name.insert(3,cuteName);\n    //name.insert(3,\"xtncsg\"); 也可\n    cout<<name<<endl;\n\n    //str.insert(it,it1,it2)\n    //将待插入字符串的[it1,it2)之间的内容插入到原字符串的迭代器位置，三个位置都是用迭代器表示，O(n)\n    name.insert(name.begin()+12,cuteName.begin()+1,cuteName.end());\n    cout<<name<<endl;\n\n    return 0;\n\n}\n```\n```c++\nshen cheng yu xtncsg\nabcxtncsg abcxtncsgtnc\nshextncsgn cheng yu\nshextncsgn ctncsgheng yu\n```\n### 截取子串与比较大小\n需要表示字符串的一段区间时，常用的函数参数表示方式有(pos,len)和(it1,it2)两种\n```c++\n#include<iostream>\n#include<string>\n#include<typeinfo>\nusing namespace std;\n\nint main(){\n    string name=\"shen cheng yu\";\n\n    if(name>\"shen cheng ran\") cout<<\"我的名字更大\"<<endl;\n    else cout<<\"他的名字更大\"<<endl;\n\n    //这里不能用(it1,it2)这种形式\n    string subName=name.substr(5,5); //str.substr(pos,len)\n    cout<<subName<<endl;\n\n    return 0;\n}\n```\n```c++\n我的名字更大\ncheng\n```\n### 查找\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    string name=\"shen cheng yu\";\n\n    //find()函数失配时的返回值，常数，其值为-1，类型为unsigned int\n    //因此其值也可以认为是unsigned int的最大值，即4294967295\n    //O(mn)，原字符串与待查找字符串的长度乘积\n    if(string::npos==-1) cout<<\"true\"<<endl;\n    if(string::npos==4294967295)  cout<<\"true\"<<endl;\n\n    if(name.find(\"cheng\")!=string::npos){\n        cout<<\"这个子串第一次出现的位置是\"<<name.find(\"cheng\")<<endl;\n    }\n    else cout<<\"找不到\"<<endl;\n\n    if(name.find(\"cheng\",6)!=string::npos){  //从指定的位置开始查找\n        cout<<\"这个子串第一次出现的位置是\"<<name.find(\"cheng\")<<endl;\n    }\n    else cout<<\"找不到\"<<endl;\n\n    //从后往前找，查找的结果与find()相同\n    if(name.rfind(\"cheng\")!=string::npos){\n        cout<<\"这个子串第一次出现的位置是\"<<name.rfind(\"cheng\")<<endl;\n    }\n    else cout<<\"找不到\"<<endl;\n\n    return 0;\n}\n```\n```c++\ntrue\ntrue\n这个子串第一次出现的位置是5\n找不到\n这个子串第一次出现的位置是5\n```\n### 替换\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    string name=\"shen cheng yu\";\n\n    //O(str.length())\n    name.replace(0,4,\"wei\");  //str.replace(pos,len,str2)\n    name.replace(name.begin()+4,name.begin()+9,\"yuan\"); //str.replace(it1,it2,str2)\n    name.replace(9,2,\"changan\",3,2); //str.replace(pos,len,str2,str2.pos,str2.len)\n    cout<<name<<endl;\n\n    return 0;\n}\n```\n```c++\nwei yuan ng\n```\n### 删除\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nint main(){\n    string name=\"shen cheng yu\";\n    name.erase(name.begin()+3); //str.erase(it)，O(n)\n    cout<<name<<endl;\n\n    name.erase(name.begin()+4,name.end()-2);  //str.erase(it1,it2)，O(n)\n    cout<<name<<endl;\n\n    name.erase(2,3);  //从str.erase(pos,len)，O(n)\n    cout<<name<<endl;\n\n    name.erase(1); //str.erase(pos)，将pos及其之后的下标字符全都删除掉\n    cout<<name<<endl;\n\n    name.clear();  //清空，O(1)\n    cout<<name.length()<<endl;  //获取长度，O(1)\n\n    return 0;\n}\n```\n```c++\nshe cheng yu\nshe yu\nshu\ns\n0\n```\n### 初始化与赋值\n三种初始化方式`,string s=\"abc\"`和`string s(\"abc\")`这两种必须是字符串，不能是字符。`string s(n,'c')`这种情况下又必须是字符，不能是字符串。\n字符与字符串的区别就在于字符串有结束符，实际占用字节数会多一个字节。\n```c++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    //三种初始化方式\n    string s1(\"u\");\n    string s2(3,'abc');  //编译器取这里的最后一个字符，该字符出现的次数\n    string s3(8,'t');\n    string s4=\"name\";\n    //string s5('u');\n    //string s6='6';\n    cout<<s1<<\" \"<<s2<<\" \"<<s3<<\" \"<<s4<<endl;\n    cout<<sizeof('u')<<\" \"<<sizeof(\"u\")<<endl; //字符串有结束符\n\n    string s5;  //字符不能用来初始化string对象，但可以赋值\n    s5='u';\n    cout<<s5<<endl;\n\n    string s6;\n    getline(cin,s6); //实现一整行输入\n    cout<<s6<<endl;\n\n    string s7,s8;\n    s7.assign(s6); //str.assign()成员函数赋值\n    cout<<s7<<endl;\n    s8.assign(s6,1,4); //str.assign(str2,pos,len)成员函数部分赋值\n    cout<<s8<<endl;\n\n    return 0;\n}\n```\n```c++\nu ccc tttttttt name\n1 2\nu\nshen cheng yu\nshen cheng yu\nshen cheng yu\nhen\n```","comments":true,"permalink":"http://yoursite.com/2019/07/06/String/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"Algorithm头文件里的算法","date":"2019-07-06T09:19:23.311Z","path":"2019/07/06/Algorithm头文件里的算法/","raw":"---\ntitle: Algorithm头文件里的算法\ntags:\n- C++\n---\n## find()\n利用find()查找vector中的元素见STL中相关部分。\n### find()查找普通数组\n```c++\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n    int array[10]={1,2,3,4,5,6,7,8,9,10};\n    //find()返回值是迭代器，int*类型的迭代器\n    int* p=find(array,array+10,6); //数组名作迭代器用\n    if(p==array+10)\n        cout<<\"找不到\"<<endl;\n    else cout<<\"找到了\"<<endl;\n    return 0;\n}\n```","comments":true,"permalink":"http://yoursite.com/2019/07/06/Algorithm头文件里的算法/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++判断变量类型","date":"2019-07-06T09:18:25.564Z","path":"2019/07/06/C++判断变量类型/","raw":"---\ntitle: C++判断变量类型\ntags:\n- C++\n---\nstring类型的变量，经过str.c_str()这个函数转换之后是什么类型的变量呢？\n```C++\nstring name=\"shen cheng yu\";\nprintf(\"%s\\n\",name.c_str());\n\n//不论是否初始化了，转换后的类型都是const char*\nif(typeid(name.c_str())==typeid(const char*))  cout<<\"yes\\n\";\nelse cout<<\"no\\n\";\n```\n不论这个string变量是否有过初始化，转换后的类型都是const char*。\n\n用typeid()函数获取变量的类型。\n需要添加头文件：\n```c++\n#include<typeinfo>\n```\n\n[C/C++中检查变量类型函数typeid()](https://blog.csdn.net/haohaibo031113/article/details/72860567)","comments":true,"permalink":"http://yoursite.com/2019/07/06/C++判断变量类型/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Vector","date":"2019-07-06T09:17:10.478Z","path":"2019/07/06/Vector/","raw":"---\ntitle: Vector\ntags:\n- C++\n- STL\n---\n\n对vector使用的建议是：先创建一个空的vector对象，然后再运行时再利用vector的成员函数push_back向其中添加元素。\nvector在尾部增删元素时，大所数情况下可以在常数时间内完成（除非此时需要重新分配内存）。\n### 添加\n```C++\nint main(){\n    vector<int>v;\n    for(int i=0;i<10;i++){\n        v.push_back(i);\n    }\n\n    v.insert(v.begin()+1,9); //在指定的迭代器位置处插入元素,O(n)\n    //将该位置的元素替换为这个元素，并且后面的元素向后顺移\n\n    for(int i=0;i<v.size();i++){\n        cout<<v[i]<<\" \";\n    }\n    return 0;\n}\n```\n```c++\n0 9 1 2 3 4 5 6 7 8 9\n```\n### 删除\n```C++\nint main(){\n    vector<int>v;\n    for(int i=0;i<10;i++){\n        v.push_back(i);\n    }\n    for(int i=0;i<v.size();i++){\n        cout<<v[i]<<\" \";\n    }\n    cout<<\"\\n\";\n\n    v.erase(v.end()-4);  //删除该迭代器位置的元素,O(n)\n    v.pop_back();   //删除末尾元素，O(1)\n    for(int i=0;i<v.size();i++){\n        cout<<v[i]<<\" \";\n    }\n    cout<<\"\\n\";\n\n    v.erase(v.begin()+2,v.begin()+5);  //删除指定区域的元素,O(n)\n    for(int i=0;i<v.size();i++){\n        cout<<v[i]<<\" \";\n    }\n    cout<<\"\\n\";\n\n    v.clear();  //清空数组，O(n)\n    cout<<v.size()<<endl;\n\n    return 0;\n}\n```\n```c++\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 7 8\n0 1 5 7 8\n0\n```\n### 迭代器\n只有vector和string两种容器支持这种写法：*(it+i)，即对迭代器加上一个常数处理。\n```C++\nint main(){\n    vector<int>v;\n    for(int i=0;i<10;i++){\n        v.push_back(i);\n    }\n    vector<int>::iterator it=v.begin(); //通过迭代器访问\n    for(int i=0;i<v.size();i++){\n        cout<<*(it+i)<<\" \";\n    }\n    cout<<\"\\n\";\n\n    for(;it!=v.end();it++){  //迭代器自增自减访问\n        cout<<*it<<\" \";\n    }\n    cout<<\"\\n\";\n\n    vector<int>::reverse_iterator it1=v.rbegin();  //反向迭代器逆序输出\n    for(;it1!=v.rend();it1++){\n        cout<<*it1<<\" \";\n    }\n    cout<<\"\\n\";\n\n    vector<int>::reverse_iterator it2=v.rend()-1;  //用反向迭代器顺序输出\n    for(;it2!=v.rbegin()-1;it2--){\n        cout<<*it2<<\" \";\n    }\n    cout<<\"\\n\";\n    return 0;\n}\n```\n```c++\n0 1 2 3 4 5 6 7 8 9\n0 1 2 3 4 5 6 7 8 9\n9 8 7 6 5 4 3 2 1 0\n0 1 2 3 4 5 6 7 8 9\n```\n### 尺寸\nsize可以增大或者缩小，但是capacity扩大之后是不能缩小回去的。\n自动增长包括重新分配内存空间、拷贝原空间、释放原空间三个过程，具体策略为当添加元素时，如果vector空间大小不足，则会以原大小的1.5倍另外配置一块较大的新空间，然后将原空间内容拷贝过来，在新空间的内容末尾添加元素，并释放原空间。也就是说vector的空间动态增加大小，并不是在原空间之后的相邻地址增加新空间，因为vector的空间是线性连续分配的，不能保证原空间之后有可供配置的空间。\n```C++\nint main(){\n    vector<int>v;\n\n    //2倍速度增长\n    for(int i=0;i<7;i++){\n        v.push_back(i);\n        cout<<v.size()<<\" \"<<v.capacity()<<endl;\n    }\n\n    v.resize(15); //扩张尺寸，就是往里面填0\n    cout<<v.size()<<\" \"<<v.capacity()<<endl;\n    for(int i=0;i<v.size();i++)\n        cout<<v[i]<<\" \";\n    cout<<endl;\n\n    v.resize(5); //缩小尺寸，截断输出\n    cout<<v.size()<<\" \"<<v.capacity()<<endl;\n    for(int i=0;i<v.size();i++)\n        cout<<v[i]<<\" \";\n    cout<<endl;\n\n    v.reserve(10); //缩小容量，没有作用的语句\n    cout<<v.size()<<\" \"<<v.capacity()<<endl;\n\n    v.reserve(20); //扩大容量\n    cout<<v.size()<<\" \"<<v.capacity()<<endl;\n\n    v.clear();\n    cout<<v.size()<<\" \"<<v.capacity()<<endl;\n\n    vector<int>v1(5);  //有5个值为0的元素\n    cout<<v1.size()<<\" \"<<v1.capacity()<<endl;\n    return 0;\n}\n```\n```c++\n1 1\n2 2\n3 4\n4 4\n5 8\n6 8\n7 8\n15 15\n0 1 2 3 4 5 6 0 0 0 0 0 0 0 0\n5 15\n0 1 2 3 4\n5 15\n5 20\n0 20\n5 5\n```\n### 查找\nfind()是algorithm头文件里面的函数，而不是vector的成员函数\n```C++\nint main(){\n    vector<int>v;\n    for(int i=0;i<5;i++){ \n        v.push_back(i);\n    }\n    int n;\n    cout<<\"请输入待查找的元素：\";\n    cin>>n;\n    \n    //在指定范围内查找元素，返回值是一个迭代器\n    vector<int>::iterator it=find(v.begin(),v.end(),n);\n    if(it!=v.end()){\n        cout<<\"这是第\";\n        cout<<it-v.begin()+1;\n        cout<<\"个元素\"<<endl;\n    }\n    else  cout<<\"不存在\"<<endl;\n    return 0;\n}\n```\n### 二维\n```C++\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nint main(){\n    //注意空格，防止被视为移位操作了\n    vector<vector<int> >v(3);\n    for(int i=0;i<v.size();i++){\n        v[i].resize(3);\n        for(int j=0;j<v[i].size();j++){\n            cin>>v[i][j];\n        }\n    }\n\n    int a=0,b=0;\n    for(int i=0;i<v.size();i++){\n        for(int j=0;j<v[i].size();j++){\n            if(i==j)\n                a+=v[i][j];\n            if(i+j==2)\n                b+=v[i][j];\n        }\n    }\n\n    cout<<a<<\" \"<<b<<endl;\n    return 0;\n}\n```\n注意：`vector<int>a[5] ` 与 `vector<vector<int> >v(5)`的区别\n前者是一个普通数组，每个元素都是一个vector\n后者是一个vector数组，里面的每个元素都是一个vector\n后者有v.size()这个成员变量，而前者没有\n\n### 其他\nC++ 11以后新增了大括号{}的初始化方式，需要注意与()的区别,如：\n \nvector<int> vecTest1(5);         //初始化5个元素，每个都是0\nvector<int> vecTest2{ 5 };       //初始化1个元素，值是5\n","comments":true,"permalink":"http://yoursite.com/2019/07/06/Vector/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"Map","date":"2019-07-06T09:16:01.106Z","path":"2019/07/06/Map/","raw":"---\ntitle: Map\ntags:\n- C++\n- STL\n---\n\n```c++\n#include<iostream>\n#include<map>\nusing namespace std;\n\nint main(){\n    map<char,int>mp; //构造从char到int的映射\n    //键或值的类型为字符数组时，只能用string，不能用char[]数组。\n    mp['a']=20;  //键所对应的值是唯一的\n    mp['a']=30;\n    printf(\"%d\\n\",mp['a']);  //通过下标访问\n    mp['b']=10;\n    mp['c']=50;\n\n    map<char,int>::iterator it=mp.find('b'); //find(key),O(log n)\n    if(it!=mp.end()){\n        cout<<\"找到了并且删除了\"<<endl;\n        //mp.erase(it);  //通过迭代器删除,O(1)\n    }\n    else cout<<\"不存在\"<<endl;\n    //mp.erase('c');  //通过键删除,O(log n)\n\n    mp.erase(it,mp.end());  //mp.erase(first,last); O(last-first)\n\n    //map只能用pair对来插入数据\n    mp.insert(make_pair('t',25));\n    mp.insert(pair<char,int>('x',18));\n\n    //会自动按照键大小，从小到大排序\n    //通过迭代器访问\n    for(map<char,int>::iterator it=mp.begin();it!=mp.end();it++){\n        cout<<it->first<<\" \"<<it->second<<endl;\n    }\n\n    mp.clear(); //O(n)\n    cout<<mp.size()<<endl; //获取映射的对数，O(1)\n    return 0;\n}\n```\n```c++\n30\n找到了并且删除了\na 30\nt 25\nx 18\n0\n```\n\n```C++\n#include<iostream>\n#include<map>\nusing namespace std;\n\nint main(){\n    map<int,char>mp;\n    mp[1]='a';\n    mp[2]='b';\n    mp[3]='c';\n\n    mp[2]='g';\n    mp.insert(make_pair(3,'o'));\n    mp.insert(pair<int,char>(1,'t'));\n\n    for(map<int,char>::iterator it=mp.begin();it!=mp.end();it++)\n        cout<<it->first<<\" \"<<it->second<<endl;\n    return 0;\n}\n```\n```C++\n1 a\n2 g\n3 c\n```\n下标方式是通过重载[]操作符来实现的，它直接进行插入或覆盖\ninsert方法会判断是否存在相同的key，如果存在则直接返回，放弃插入操作。如果不存在才进行插入","comments":true,"permalink":"http://yoursite.com/2019/07/06/Map/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"STL","slug":"STL","permalink":"http://yoursite.com/tags/STL/"}]},{"title":"MyQR生成二维码","date":"2019-06-21T22:39:27.383Z","path":"2019/06/22/myqr生成二维码/","raw":"---\ntitle:  MyQR生成二维码\ntags:\n- python\n---\nMyQR模块可以生成以指定图片为背景的二维码，可以是`.jpg`，也可以是`.gif`。\n首先用pip安装好MyQR模块。\n实验代码：\n```python\nfrom MyQR import myqr\nmyqr.run(words='https://space.bilibili.com/227516618',\n         version=20,\n         picture=r'C:\\Users\\14311\\Desktop\\梦幻.gif',\n         colorized=True,\n         save_dir='C:\\\\Users\\\\14311\\\\Desktop\\\\')\n```\nwords是二维码链接的url，这里是我的bilibili首页的地址。version是二维码图片的边长控制，picture是本地图片地址，这里只能是本地路径，不能是网络地址。使用彩色，save_dir是二维码本地保存的目录，注意其写的格式。\nurl直接从网上复制，本地路径注意写法即可。\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/22/myqr生成二维码/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python词频统计","date":"2019-06-21T08:54:35.824Z","path":"2019/06/21/python词频统计/","raw":"---\ntitle: Python词频统计\ntags:\n- python\n- 数据分析\n---\n首先，直接用jieba进行分词，和用jieba,posseg进行分词得到的结果是不一样的。以下面这段话为示例：\n<blockquote>刘备、关羽与张飞在长安结拜为异姓兄弟。一瞬间大雪纷飞，诸葛亮横空出世，荡平寰宇，延续汉家天下。</blockquote>\n\n用jieba进行分词\n```python\nimport jieba \nif __name__==\"__main__\":\n    file_path = \"C:/Users/14311/Desktop/test.txt\"\n    with open(file_path,'r',encoding=\"utf-8\") as f:\n        content = f.read()\n        f.close\n    print(type(content))\n    print(content)\n    for x in jieba.cut(content):\n        print(type(x))\n        print(x)\n        # print(x.flag)\n        # print(x.word)\n```\n这样得到的content以及jieba.cut()后得到的每个词语都是str类型的，可以直接打印出来。这时因为是str类型，所以这些词语没有flag与word这两个属性。\n\n用jieba.posseg进行分词\n```python\nimport jieba.posseg as psg\n\nif __name__==\"__main__\":\n    file_path = \"C:/Users/14311/Desktop/test.txt\"\n    with open(file_path,'r',encoding=\"utf-8\") as f:\n        content = f.read()\n        f.close\n    print(type(content))\n    print(content)\n    for x in psg.cut(content):\n        print(type(x))\n        print(x.flag)\n        print(type(x.flag))\n        print(x.word)\n        print(type(x.word)\n```\n这时得到的每个词语的类型都是`<class 'jieba.posseg.pair'>`，每个词语都有一个flag词性属性，和一个word词语内容属性。这两个属性的类型都是str，可以直接打印出来。\n比如人名的词性是nr，地名的词性是ns，标点符号是x，介词是p等等。\n```python\n<class 'jieba.posseg.pair'>\nnrfg\n<class 'str'>\n刘备\n<class 'str'>\n<class 'jieba.posseg.pair'>\nx\n<class 'str'>\n、\n<class 'str'>\n<class 'jieba.posseg.pair'>\nnr\n<class 'str'>\n关羽\n<class 'str'>\n<class 'jieba.posseg.pair'>\np\n<class 'str'>\n与\n<class 'str'>\n<class 'jieba.posseg.pair'>\nnr\n<class 'str'>\n张飞\n<class 'str'>\n<class 'jieba.posseg.pair'>\np\n<class 'str'>\n在\n<class 'str'>\n<class 'jieba.posseg.pair'>\nns\n<class 'str'>\n长安\n<class 'str'>\n```\n[汉语词性对照表[北大标准/中科院标准]](https://blog.csdn.net/kevin_darkelf/article/details/39520881)\n\n这里面导入模块的方法有以下三种：\n```python\nimport jieba.posseg as psg\nfor x in psg.cut(content):\n```\n```python\nimport jieba.posseg \nfor x in jieba.posseg.cut(content):\n```\n```python\nfrom jieba import posseg \nfor x in posseg.cut(content):\n```\n下面的代码是对小说中词频较高的人名和地名做统计：\n```python\nimport jieba.posseg as psg\n\nif __name__==\"__main__\":\n    file_path = \"C:/Users/14311/Desktop/三国演义.txt\"\n    with open(file_path,'r',encoding=\"utf-8\") as f:\n        content = f.read()\n        f.close\n    # 设置两个空列表接收人名和地名\n    names = []\n    cities =[]\n    for x in psg.cut(content):\n        # 将人名填充到列表中\n        if x.flag == 'nr' and len(x.word)<4:\n            names.append(x.word)\n        # 将地名填充到列表中\n        if x.flag == 'ns' and len(x.word)<4:\n            cities.append(x.word)\n    # print(names)\n    # print(cities)\n\n    # 建立两个空字典保存词语和这个词语出现的次数\n    # 字典里的key是人名或者地名，value值是出现的次数\n    names_frenquency = {}\n    for name in names:\n        if name in names_frenquency:\n            names_frenquency[name] +=1\n        else:\n            names_frenquency[name] = 1\n    \n    cities_frenquency = {}\n    for city in cities:\n        if city in cities_frenquency:\n            cities_frenquency[city] +=1\n        else:\n            cities_frenquency[city] = 1\n\n    # print(names_frenquency)\n    # print(cities_frenquency)\n\n    # 对字典按照value值从大到小排序，保存排序后的副本，原字典的内容并没有改变\n    name_sorted = sorted(names_frenquency.items(),key=lambda item:item[1],reverse=True)\n    city_sorted = sorted(cities_frenquency.items(),key=lambda item:item[1],reverse=True)\n\n    # 读取前20项字典元素的key 和value\n    for i in range(20):\n        print('{}\\t{}'.format(name_sorted[i][0],name_sorted[i][1]))\n    print('\\n\\n\\n')\n    for i in range(20):\n        print('{}\\t{}'.format(city_sorted[i][0],city_sorted[i][1]))\n```\n对《三国演义》进行词频分析：\n```python\n曹操\t934\n孔明\t831\n玄德\t685\n关公\t508\n孔明曰\t385\n玄德曰\t383\n张飞\t348\n汝\t328\n吕布\t299\n瑜\t287\n孙权\t264\n耶\t255\n赵云\t254\n吴\t223\n魏兵\t223\n司马懿\t221\n周瑜\t217\n魏延\t211\n魏\t205\n肃\t203\n```\n人名这里，诸葛亮，刘备，曹操位居前三，遥遥领先后面的人。\n```python\n荆州\t420\n东吴\t251\n汉中\t212\n上马\t179\n江东\t143\n徐州\t141\n成都\t136\n夏侯惇\t115\n许都\t111\n云\t110\n洛阳\t107\n关兴\t97\n祁山\t92\n西川\t89\n襄阳\t89\n朝廷\t88\n长安\t85\n英雄\t83\n甘宁\t82\n江南\t81\n```\n地名这里，是荆州一家独大。\n\n再试试《东汉末年枭雄志》：\n```python\n郭鹏\t5398\n董卓\t1027\n卢植\t853\n蔡邕\t584\n雒阳\t545\n曹操\t465\n黄巾军\t415\n袁术\t331\n汉军\t289\n袁绍\t276\n袁隗\t250\n郭单\t249\n灵帝\t248\n程立\t246\n曹嵩\t245\n曹氏\t234\n丘力居\t216\n张角\t205\n黄巾\t197\n袁氏\t192\n```\n只能说，主角不愧是主角。\n```python\n朝廷\t222\n上谷\t155\n东西\t151\n青州\t134\n大汉\t108\n颍川\t105\n凉州\t86\n徐州\t72\n夏侯惇\t69\n关东\t69\n江东\t63\n屯田\t63\n河北\t56\n太平道\t55\n北疆\t53\n冀州\t53\n并州\t50\n蓟县\t42\n京城\t41\n南阳\t39\n```\n我是真的服了这个夏侯惇。。。\n[python 对字典分别按照key值、value值进行排序](https://blog.csdn.net/laobai1015/article/details/85114570)\n","comments":true,"permalink":"http://yoursite.com/2019/06/21/python词频统计/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"三门问题","date":"2019-06-20T12:40:12.064Z","path":"2019/06/20/三门问题/","raw":"---\ntitle: 三门问题\ntags:\n- 数学\n- 模拟\n---\n有三扇门，一扇门后面有汽车，另外两扇门后面是山羊。玩家先选择一扇门，这时主持人打开一扇山羊们（主持人事先知道每扇门后面都是什么）。那么这时候玩家是应该坚持自己原来的选择不换呢？还是应该换成另外一扇门呢？\n\n其实道理很简单。当主持人的行为完成之后，场下还剩下一扇汽车门，还有一扇山羊们可以让玩家选择。玩家事先选择的时候，有1/3的概率选到的是汽车门，这时应该坚持自己的选择。但是也有2/3的概率选到的是山羊门，这时候应该换成另外一扇门。也就是换成另外一扇门的胜率会大一些。\n\n[反直觉的三门问题](https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650746156&idx=3&sn=a1b824ce8c3326a222888fde7c2061ae&chksm=befeb862898931746a8486f9e71685698b85244182fc3bcb903e2f2d87f90e7ea4491e307924&xtrack=1&scene=0&subscene=131&clicktime=1561029975&ascene=7&devicetype=android-25&version=2700033c&nettype=WIFI&abtest_cookie=BQABAAoACwASABMAFQAGACOXHgBWmR4Av5keANyZHgD4mR4ADJoeAAAA&lang=zh_CN&pass_ticket=Of3WZZPeBKVwP5kE9QxwMPbIynqV1YZgzNsDPoI4UrfceyHOSEKP5vDOBR0%2BAx0X&wx_header=1)\n\n```C++\n#include<iostream>\n#include<ctime>\n#include<cstring>\nusing namespace std;\n\nclass Door{\npublic:\n    char award[10];   //门后的奖品\n    Door(const char* award_){  //构造函数\n        strcpy(award,award_);\n    }\n};\n\nint main(){\n    srand((unsigned int)time(0));\n    clock_t startTime,endTime;\n    double num;       //试验次数\n    cout<<\"请输入试验次数：\";\n    while(cin>>num){\n        startTime=clock();\n        //对象数组的构造函数，假定第一扇门是汽车门\n        Door doors[3]={\"car\",\"goat\",Door(\"goat\")}; \n        int winStay=0,winTurn=0;  //不换而胜利的场数和换门而胜利的场数\n        for(int i=0;i<num;i++){\n            int choice=rand()%3;  //玩家先随机选择一扇门\n            if(choice==0)  //如果选的是汽车门，就保持选择\n                winStay++;\n            else           //否则换成另外一扇门\n                winTurn++;  \n        }\n        cout<<\"换的胜率是：\"<<winTurn/num<<endl;\n        //cout<<\"保持的胜率是：\"<<winStay/num<<endl;\n        endTime=clock();\n        cout<<\"程序运行时间是：\"<<(double)(endTime-startTime)/CLOCKS_PER_SEC<<endl<<endl;\n        cout<<\"请输入试验次数：\";\n    }\n    return 0;\n}\n```\n这个代码好鸡贼啊！\n实验结果如下：\n```\n请输入试验次数：1000\n换的胜率是：0.657\n程序运行时间是：0\n\n请输入试验次数：10000\n换的胜率是：0.6665\n程序运行时间是：0\n\n请输入试验次数：100000\n换的胜率是：0.66588\n程序运行时间是：0\n\n请输入试验次数：1000000\n换的胜率是：0.666556\n程序运行时间是：0.016\n\n请输入试验次数：10000000\n换的胜率是：0.666622\n程序运行时间是：0.171\n\n请输入试验次数：100000000\n换的胜率是：0.666635\n程序运行时间是：1.812\n\n请输入试验次数：1000000000\n换的胜率是：0.666645\n程序运行时间是：18.033\n\n请输入试验次数：\n```","comments":true,"permalink":"http://yoursite.com/2019/06/20/三门问题/","categories":[],"tags":[{"name":"数学","slug":"数学","permalink":"http://yoursite.com/tags/数学/"},{"name":"模拟","slug":"模拟","permalink":"http://yoursite.com/tags/模拟/"}]},{"title":"char* 到 char[]的转换问题","date":"2019-06-20T12:40:12.025Z","path":"2019/06/20/char 到 char[]的转换问题/","raw":"---\ntitle: char* 到 char[]的转换问题\ntags:\n- C++\n- 编程\n---\n```C++\n#include<iostream>\nusing namespace std;\n\nvoid fun(const char*);\n\nint main(){\n    char s[10]=\"apple\";\n    fun(s);\n    return 0;\n}\n\nvoid fun(const char* str){\n    char t[10];\n    t=str;\n    cout<<t<<endl;\n}\n```\n这里将一个char*的字符串转换成char []这样的，就会报错：\n```C++\nerror: incompatible types in assignment of 'const char*' to 'char [10]'|\n```\n\n以下几种方法可以修正：\n```\tC++\n#include<iostream>\n#include<cstring>\nusing namespace std;\n\nvoid fun(const char*);\n\nint main(){\n    char s[10]=\"apple\";\n    fun(s);\n    return 0;\n}\n\nvoid fun(const char* str){\n    char t[10];\n    strcpy(t,str);\n    //t=str;\n    cout<<t<<endl;\n}\n```\n```C++\n#include<iostream>\nusing namespace std;\n\nvoid fun(const char*);\n\nint main(){\n    char s[10]=\"apple\";\n    fun(s);\n    return 0;\n}\n\nvoid fun(const char* str){\n    const char* t;\n    t=str;\n    cout<<t<<endl;\n}\n```\n```C++\n#include<iostream>\nusing namespace std;\n\nvoid fun(char*);\n\nint main(){\n    char s[10]=\"apple\";\n    fun(s);\n    return 0;\n}\n\nvoid fun(char* str){\n    const char* t;\n    t=str;\n    cout<<t<<endl;\n}\n```\n不能由const char\\*转换成char\\*，但是可以由char\\*转换成const char\\*。\n[error: incompatible types in assignment of ‘char*’ to ‘char [19]’](http://x.wolfmark.org/x-select_2017-08-09_396.html)","comments":true,"permalink":"http://yoursite.com/2019/06/20/char 到 char[]的转换问题/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"switch...case结构中变量的作用域","date":"2019-06-20T12:40:12.019Z","path":"2019/06/20/switch...case结构中变量的作用域/","raw":"---\ntitle: switch...case结构中变量的作用域\ntags:\n- C++\n- 编程\n---\n实验代码：\n```C++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    int i=2;\n    switch(i){\n    case 1:\n        i=5;\n        int j=4;\n        break;\n    case 2:\n        cout<<i<<j<<endl;\n        break;\n    default:\n        cout<<3;\n    }\n    return 0;\n}\n```\n在switch...case结构中，若是在某一个case分支中初始化了变量，则会报错：\n```C++\nerror: jump to case label [-fpermissive]|\n```\n因为switch中没有单独的花括号{}来限定变量的生命周期，所以变量的作用域就是初始化点到switch的结尾处。\n\n在实验代码里面，变量i的声明是在switch之外，它的作用域在声明之后就是确定的。因此在case分支里面对i进行操作是没有问题的。\n\n但是在case 1这个分支里面定义了变量j，由于我们无法确定其他case中是否会使用到变量j，使用之前变量j是否被初始化，所以编译器会报错。\n\n解决方法有下面两个：\n- 【缩小作用域】将涉及到变量j的部分代码用{ }括起来，设定清楚变量j的作用域，避免其他case访问。\n- 【扩大作用域】将变量j放到switch外部，switch中的每个case都可以访问，就像变量i一样。\n\n```C++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    int i=2;\n    switch(i){\n    case 1:\n        i=5;\n        {\n            int j=4;\n        }\n        break;\n    case 2:\n        cout<<i<<endl;\n        break;\n    default:\n        cout<<3;\n    }\n    return 0;\n}\n```\n这个时候就只能在case 1分支中使用变量j，case 2 分支中就不能再对j进行操作了。\n[【C++ 异常】error: jump to case label [-fpermissive]](https://www.jianshu.com/p/254abfa7caed)","comments":true,"permalink":"http://yoursite.com/2019/06/20/switch...case结构中变量的作用域/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"Python生成词云","date":"2019-06-17T14:53:12.318Z","path":"2019/06/17/python生成词云/","raw":"---\ntitle:  Python生成词云\ntags:\n- python\n- 数据分析\n---\n生成词云的方式有很多，有很多这样的网站，软件，微信小程序等等，这里采用python里面wordcloud模块来完成，给定一段文字，用jieba模块分词，得到很多词语，分析这些词的出现频率，将出现频率高的词语整合成词云的形式。\n\n先上代码吧。\n```python\nfrom wordcloud import WordCloud,STOPWORDS  //词云模块\nimport matplotlib.pyplot as plt  # 画图模块\nimport jieba   # ieba分词  \nfrom PIL import Image  # 加载图片\nimport numpy\n\nfile_path=r'C:\\Users\\14311\\Desktop\\东汉末年枭雄志.txt'  \nfile = open(file_path,'r',encoding='gbk').read()  \ncut_file = jieba.cut(file) \njoin_file = \" \".join(cut_file)\n\n# 设置停用词\nsw = set(STOPWORDS)\nsw.add('的')\nsw.add('你')\nsw.add('我')\nsw.add('他')\nsw.add('因此')\nsw.add('所以')\nsw.add('这样')\nsw.add('那样')\nsw.add('会')\nsw.add('不会')\nsw.add('自己')\nsw.add('那么')\nsw.add('然后')\nsw.add('事情')\nsw.add('可以')\nsw.add('得到')\nsw.add('在')\nsw.add('就是')\nsw.add('它们')\nsw.add('不过')\nsw.add('但是')\nsw.add('还是')\nsw.add('一些')\nsw.add('一样')\nsw.add('时候')\nsw.add('已经')\nsw.add('明白')\nsw.add('知道')\n\n\n# 设置字体和图片模板\nfont = r\"C:\\Windows\\Fonts\\XJLbold_1.ttf\"\n# image_file = Image.open(r'C:\\Users\\14311\\Desktop\\轮廓.jpg')\n# image = numpy.array(image_file)\n\n# 生成词云\nwordcloud = WordCloud(font_path=font,background_color=\"#ffffff\",width=1000,height=880).generate(join_file)\n# wordcloud = WordCloud(font_path=font,background_color=\"#ffffff\",mask=image,width=1000,height=880).generate(join_file)                  \nplt.imshow(wordcloud, interpolation=\"bilinear\")\nplt.title(\"Chapter 1-229\")\n# plt.axis(\"off\") 不知道干什么用的\nplt.show()\n\n```\n打印一些中间变量的结果如下：\n打印`cut_file`得到下面这行语句：\n```python\n<generator object Tokenizer.cut at 0x0A3E6530>\n```\n打印`join_file`得到下面这行语句：\n```python\n　 “ 刘备 ， 刘玄德 ， 涿郡 涿县 人 ， 我 的 老师 ， 卢公在 涿县 学宫 教书 时 ， 门下 的 弟子 之一 。 ” \n \n 　 　 “ 竟有 这种 事 ？ ” \n \n 　 　 程立 愣 了 一下 ， 而后 笑 道 ： “ 看来 主公 名望 大增 ， 些许 故旧 前来 拜访 也 是 理所应当 的 事情 ， 这个 刘备 ， 应该 是 想 靠 这份 关系 在 军中 某个 职位 吧 ？ 主公 如何 看待 ？ ” \n \n 　 　 郭鹏 放下 了 拜帖 ， 笑 道 ： “ 同门 师兄 来 拜访 ， 如何 能 不 以礼相待 呢 ？ 仲德 ， 帮 我 安排 一下 ， 我 在 县城 里 迎接 我 的 师兄 。 ” \n```\n可以看到，这时候已经将文章分词分好了。\n打印`wordcloud`变量得到下面这行语句：\n```python\n<wordcloud.wordcloud.WordCloud object at 0x09BBDCF0>\n```\n最大的问题出现在wordcloud这个模块的安装上面。\n[pip安装wordcloud模块](https://shen-cheng-yu.github.io/2019/06/17/pip%E6%A8%A1%E5%9D%97/)\n文件路径那里，路径的写法要注意。\n[文件路径的写法](https://shen-cheng-yu.github.io/2019/06/17/%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%9A%84%E5%86%99%E6%B3%95/)\n生成词云时，可以指定词云图片的背景颜色与图片的尺寸。\n表示颜色时，除了`background_color=\"white\"`这种方式之外，还可以`background_color=\"#ffffff\"`这样子，注意外面需要加上引号。\n设置标题时，不支持中文字符。\n\n打开`.txt`文档的时候，有的需要是`gbk`，有的又需要是`utf-8`，为啥嘞？\n[UnicodeDecodeError: 'utf-8' codec can't decode byte 0xc0 in position 0: invalid start byte](https://blog.csdn.net/qq_40883132/article/details/83280191)\n\n为什么设置了停用词之后，还是会出现这些词语呢？\n\n加载词云的图片模板，只需要在WordCloud()函数里面，添加上一个mask的关键字参数即可。\n\n在这个过程中，出现了一大堆问题。\n[SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \\UXXXXXXXX escape](https://blog.csdn.net/u011242657/article/details/64437612)\n\n[ModuleNotFoundError: No module named 'query_integral_image'](http://tieba.baidu.com/p/5784733299)\n\n参考链接：\n[pyton生成词云](https://www.cnblogs.com/tiandsp/p/8636826.html)\n[详解Python如何生成词云的方法](https://www.jb51.net/article/141320.htm)\n\n选取了《东汉末年枭雄志》这本小说的前面1-229章节进行实验，得到的结果如下图：\n![enter image description here](https://img-blog.csdnimg.cn/20190621154932650.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n\n再选取三国演义这本小说\n![enter image description here](https://img-blog.csdnimg.cn/20190621155228960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/17/python生成词云/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"数据分析","slug":"数据分析","permalink":"http://yoursite.com/tags/数据分析/"}]},{"title":"文件路径的写法","date":"2019-06-17T14:44:10.896Z","path":"2019/06/17/文件路径的写法/","raw":"---\ntitle:  文件路径的写法\ntags:\n- python\n- 编程\n---\nwindows里面的文件路径，它的斜杠符号是这样`\\`。但是编程的时候，如果涉及到文件路径，就不能这么写了，会被当作是转义字符给转义掉的。\n比如这么写就是错的：`path_txt='C:\\Users\\14311\\Desktop\\1-100.txt'`\n\n有以下三种方法：\n1. 两个斜杠，表示第二个斜杠只是一个普通字符，不是转义的意思。\n`path_txt='C:\\\\Users\\\\14311\\\\Desktop\\\\1-100.txt'`\n2. 原始字符串，显示地声明这里的斜杠不用转义。\n`path_txt=r'C:\\Users\\14311\\Desktop\\1-100.txt'`\n3. 使用linux里面文件路径的表达方式，即用左斜杠。\n`path_txt='C:/Users/14311/Desktop/1-100.txt'`\n\n[Python 中 ‘unicodeescape’ codec can’t decode bytes in position XXX: trun错误解决方案](https://blog.csdn.net/u011242657/article/details/64437612)","comments":true,"permalink":"http://yoursite.com/2019/06/17/文件路径的写法/","categories":[],"tags":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"pip模块","date":"2019-06-17T14:44:10.864Z","path":"2019/06/17/pip模块/","raw":"---\ntitle:  pip模块\ntags:\n- python\n- 模块与包\n---\n这是python安装模块的一个模块（用来安装别的模块，它自己也是一个模块）。\n## 命令\n### `pip freeze`\n在cmd窗口，可以通过`pip freeze`查看目前已经安装了哪些包。\n![enter image description here](https://img-blog.csdnimg.cn/20190617215048909.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n### `pip show numpy`\n通过类似这样的命令，查看已经安装的包的一些具体信息。\n![enter image description here](https://img-blog.csdnimg.cn/20190617215234559.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n这时候还没有安装好wordcloud模块，因此查询时没有反应。\n安装好了之后可以看到：\n```\nC:\\WINDOWS\\system32>pip show wordcloud\nName: wordcloud\nVersion: 1.5.0\nSummary: A little word cloud generator\nHome-page: https://github.com/amueller/word_cloud\nAuthor: Andreas Mueller\nAuthor-email: t3kcit+wordcloud@gmail.com\nLicense: MIT\nLocation: d:\\python3.7.0\\lib\\site-packages\nRequires: numpy, pillow\nRequired-by:\n```\nlocation那里是python的模块和包的默认安装路径。requires表示这个包需要两个先导包。\n[手把手教你用pip查看已装包(模块)的安装路径](https://jingyan.baidu.com/article/20095761f8c09dcb0721b43c.html)\n\n## 安装wordcloud包\n如果直接使用`pip install wordcloud`的话，最终会安装错误。\n[在这个网页](https://www.lfd.uci.edu/~gohlke/pythonlibs/#wordcloud)下载包文件，需要根据自己电脑和python的版本号下载。\n![enter image description here](https://img-blog.csdnimg.cn/20190617222030671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\npython的版本是3.7.0，所以下载cp37这个。可能是因为python是32位的，所以需要下载win32这个。如果安装的是64位的，又会报错`ModuleNotFoundError: No module named 'query_integral_image'`。query_integral_image文件是被python3.x .x 32位的sdk加密成`.pyd`文件的。如果是64位的，就会少了这个文件。\n\n下载好了正确的`.whl`文件，将其改为`.rar`文件，解压后的文件夹里有两个子文件夹，移动到python模块的安装路径下（随便选一个已有的模块用`pip show xxx`命令得到安装路径) \n![enter image description here](https://img-blog.csdnimg.cn/20190617223142461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n这样就安装完成了。","comments":true,"permalink":"http://yoursite.com/2019/06/17/pip模块/","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"模块与包","slug":"模块与包","permalink":"http://yoursite.com/tags/模块与包/"}]},{"title":"Chrome离线插件安装","date":"2019-06-17T14:44:10.800Z","path":"2019/06/17/Chrome离线插件安装/","raw":"---\ntitle:  Chrome离线插件安装\ntags:\n- 骚操作\n- 软件使用\n---\n将一个`.crx`后缀的本地文件，安装到谷歌浏览器里面。\n直接拖动安装的话会出问题，会提示`crx-header-invalid`，有已下三种解决办法。\n1. 在扩展程序管理界面，选中开发者模式。以前安装油猴的时候就是这么做的。\n2. 修改参数。不太懂，安装`hacker-version`时也无法解决问题。\n3. 将`.crx`文件的后缀修改为`.rar`或者其他压缩文件的格式，解压。在Chrome浏览器的扩展程序管理界面，选中`加载已解压的扩展程序`，就能解决无法安装`hacker-version`的问题了。\n\n[chrome 67版本后无法拖拽离线安装CRX格式插件的解决方法](http://chromecj.com/utilities/2018-09/1525.html)","comments":true,"permalink":"http://yoursite.com/2019/06/17/Chrome离线插件安装/","categories":[],"tags":[{"name":"骚操作","slug":"骚操作","permalink":"http://yoursite.com/tags/骚操作/"},{"name":"软件使用","slug":"软件使用","permalink":"http://yoursite.com/tags/软件使用/"}]},{"title":"HEXO攻略(Archer)","date":"2019-06-17T09:20:13.595Z","path":"2019/06/17/hexo使用攻略/","raw":"---\ntitle:  HEXO攻略(Archer)\ntags:\n- hexo\n---\n首先，目前使用hexo时，用的主题是Archer主题，是当时搭建博客时就选定的主题。\n\n## 表格\n对齐说明行位于第二行，这一行不能少。\n表格要与最上面的文本内容空一行，否则解析不出来。\n[hexo博客搭建时遇到的一些问题](https://segmentfault.com/a/1190000003710962?_ea=336354)\n## 标签\n文章写的多了之后，给每一篇文章设置相关的标签是十分必要的，下面两篇教程的背景是NexT主题，设置标签比较复杂，事实上Archer这个主题设置标签不需要进行任何设置，直接在文章里面写上标签就行了。如下图，Archer主题写好文章就会自动有写作时间，在这里额外加上date这一项并没有什么作用。\n![enter image description here](https://img-blog.csdnimg.cn/20190617170514718.png)\n[Hexo使用攻略-添加分类及标签](https://www.jianshu.com/p/e17711e44e00)\n[hexo 添加标签和分类](https://promoon.github.io/2018/12/01/hexo_categories_tags/)","comments":true,"permalink":"http://yoursite.com/2019/06/17/hexo使用攻略/","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"指针","date":"2019-06-16T10:34:05.359Z","path":"2019/06/16/指针/","raw":"---\ntitle: 指针\ntags:\n- C/C++\n- 指针\n- 计算机组成原理\n---\n# 指针数组和数组指针\n先从概念上明确，前面一个词是修饰词，后面一个词才是本质。指针数组是一个数组，数组里的每一个元素都是一个指针。数组指针是一个指针，指向一个数组。\n```C++\nint* a[10]   //指针数组\nint (*p) a[10]  //数组指针\n```\n优先级关系是：`)>[]>*`\n因此第一行代码先形成了数组关系，每个数组元素都是int型的指针。第二行代码先形成了指针关系，指向一个数组。\n[指针数组与数组指针的区别](https://blog.csdn.net/weixin_41923658/article/details/88066916)\n\n# 指针占用字节大小\n指针存储的是内存中的一个地址。如果CPU是32位，即CPU一次能处理的数据位数是32位，也即CPU能够访问到的地址空间是2的32次方，多以指针需要占用4个字节。\n如果CPU是64位的，则地址占用64位，指针占用的空间也就是8个字节。\n[关于指针类型占用的字节数](https://www.cnblogs.com/jiayouwyhit/p/3241857.html)\n","comments":true,"permalink":"http://yoursite.com/2019/06/16/指针/","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"http://yoursite.com/tags/计算机组成原理/"}]},{"title":"文件后缀相关","date":"2019-06-16T10:34:05.358Z","path":"2019/06/16/文件后缀相关/","raw":"---\ntitle: 文件后缀相关\ntags:\n- 电脑\n---\n# chw 文件\n[如何打开chw文件](https://zhidao.baidu.com/question/197311491.html?word=chw%E6%96%87%E4%BB%B6)\n`EasyX`文件的说明文档是`.chm`类型的，本质应该是一个`msdn`查阅器，`.chw`文件就是在打开`.chm`文件时产生的索引文件，能够加快`.chm`文件的索引，是自动产生没有办法消除。","comments":true,"permalink":"http://yoursite.com/2019/06/16/文件后缀相关/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"}]},{"title":"头文件与库文件相关","date":"2019-06-16T10:34:05.356Z","path":"2019/06/16/头文件与库文件相关/","raw":"---\ntitle: 头文件与库文件相关\ntags:\n- C++\n- 编程\n---\n# conio.h\n定义了通过控制台进行数据输入和数据输出的函数，主要是一些用户通过按键盘产生的对应操作，比如`getch()`、`kbhit()`等等。","comments":true,"permalink":"http://yoursite.com/2019/06/16/头文件与库文件相关/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"记事本更改默认编码方式为UTF-8","date":"2019-06-16T10:34:05.341Z","path":"2019/06/16/记事本更改默认编码方式为UTF-8/","raw":"---\ntitle: 记事本更改默认编码方式为UTF-8\ntags:\n- 电脑\n- 骚操作\n---\n 由于之前在`Marxico`上写好的Markdown文件，导入到记事本里面，再修改记事本的后缀为`.md`，把这样的文件上传到`Hexo`上，博客上显示的文章就会乱码。为了一劳永逸的解决这个问题，就想把记事本的默认编码方式改为`utf-8`，要不然每次都要另存为才能改编码方式。\n\n[使新建windows记事本的字符集编码默认为UTF-8](https://blog.csdn.net/tangxinzhuan/article/details/52450867)\n[如何使创建记事本时的默认编码为UTF-8](https://blog.csdn.net/qq_38671360/article/details/82700646)\n[shellnew是什么程序](https://zhidao.baidu.com/question/7421669.html?word=ShellNew)\n\n最终的实现方法和百度到的有些出入。基本原理就是在`C:\\Windows\\SHELLNEW`里面，保存一个空白的`utf-8`格式的模板记事本文件，然后在注册表里面更改`.txt`文件的默认模板为刚刚保存的那个文件。\n\n我在`C盘`里面找不到`ShellNew`这个文件夹（显示隐藏的文件/文件夹也找不到），后来就自己新建了一个`SHELLNEW`文件夹，虽然名字不一样，但是注册表里面可能是不区分大小写的，因为`.txt`已经有了`ShellNew`这个项，我再新建一个`SHELLNEW`项，就会提示该项已存在。\n\n<img src=\"https://img-blog.csdnimg.cn/20190604133722103.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70\">\n\n`ShellNew`这个项下面，有三个字符串值，加上我自己新建的`FileName`，一共四个字符串值。一个字符串值由数值名称，类型，数值数据三部分构成。右键修改，将它们的数据都给修改成了`UTF-8.txt`（就是我保存的那个模板记事本文件）。一开始没有效果，后来发现是因为`UTF`和`8`之间少了一个连字符，数据输入错了，难怪没有效果。\n\n现在已经成功了，看来我的`C盘`可能根本就没有`ShellNew`这个文件夹，必须要新建一个才行。\n","comments":true,"permalink":"http://yoursite.com/2019/06/16/记事本更改默认编码方式为UTF-8/","categories":[],"tags":[{"name":"电脑","slug":"电脑","permalink":"http://yoursite.com/tags/电脑/"},{"name":"骚操作","slug":"骚操作","permalink":"http://yoursite.com/tags/骚操作/"}]},{"title":"电脑硬件","date":"2019-06-16T10:34:05.309Z","path":"2019/06/16/电脑硬件/","raw":"---\ntitle: 电脑硬件\ntags:\n- 硬件\n---\n# 鼠标工作原理\n## 定位原理\n光电鼠标内部有一个发光二极管，它发出的光线通过一个菱形镜，折射到鼠标垫或者桌面上，可以照亮光电鼠标底部表面（这是鼠标底部总会发光的原因），当然也有部分光线直接通过菱形镜笔直地向前照射。光电鼠标经底部表面反射回的一部分光线，通过一个圆形镜后，传输到一个光感应器件（微成像器）内成像。这个菱形镜和圆形镜是光电鼠标内部光学器件中很重要的一部分。当光电鼠标移动时，其移动轨迹便会被记录为一组高速拍摄的连贯图像，被光电鼠标内部的一块专用图像分析芯片（DSP，即数字微处理器）分析处理。该芯片通过对这些图像上特征点位置的变化进行分析，来判断鼠标的移动方向和移动距离，从而完成光标的定位。 \n## 滚轮原理\n应该是鼠标的滚轮通过轴插入到鼠标编码器上面的孔，这样滚轮旋转的时候，就能带动鼠标编码器的旋转运动。编码器有3个引脚，第一个引脚接电源，剩下两个是输出引脚。但是当接通电源的时候，这两个引脚的输出波形会有相位差。比如说，当顺时针旋转时，第二引脚的输出波形超前于第三引脚的输出波形，逆时针的时候就反过来，这样通过两个引脚输出波形的相位差关系，就知道滚轮的旋转方向了。\n当慢滑动时，第二引脚和第三引脚输出的波形脉宽宽（也就是高电平持续时间长）；当快滑动时，第二引脚和第三引脚输出的波形脉宽窄（也就是高电平持续时间短）。\n总结可得，鼠标编码器的接法是：第一引脚接VCC电源，第二引脚和第三引脚为输出端。编码器通过相位差来判断滑动方向，通过输出高电平持续时间来判断滑动速度，但无论滑动快慢和方向，其各引脚输出的脉冲宽度相同。\n## DPI\ndpi是它用来衡量鼠标每移动一英寸所能检测出的点数，dpi越小，用来定位的点数就越少，定位精度就低；dpi越大，用来定位点数就多，定位精度就高。通常情况下，传统机械式鼠标的扫描精度都在200dpi以下，而光电鼠标则能达到400甚至800dpi。\n[光电鼠标的工作原理](http://www.fengniao.com/pe/0_691720.html)\n[鼠标中键的工作原理](http://3g.163.com/v/video/VNOV3LM6Q.html)\n[鼠标编码器原理](https://blog.csdn.net/u011798737/article/details/70990823)\n[今天终于明白了鼠标编码器的原理](https://wenku.baidu.com/view/1dbfb38fa0116c175f0e4862.html)\n# 电脑显卡\n在我的电脑，设备管理器里面的显示适配器里面，可以看到显卡信息。我的电脑有两个显卡，`Intel(R) HD Graphics 530`和`NVIDIA GeForce GTX 950M`，可能是一个独显一个集显这样的关系，但是两个都有内存范围这个东西？？？\n[集成显卡和独立显卡的区别](https://jingyan.baidu.com/article/fec7a1e5c6b91a1191b4e76c.html?wap_detail_test=X5)\n[怎么查看电脑的显卡](https://jingyan.baidu.com/article/456c463b6971270a58314423.html)","comments":true,"permalink":"http://yoursite.com/2019/06/16/电脑硬件/","categories":[],"tags":[{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/tags/硬件/"}]},{"title":"磁盘与磁盘格式","date":"2019-06-16T10:34:05.308Z","path":"2019/06/16/磁盘与磁盘格式/","raw":"---\ntitle: 磁盘与磁盘格式\ntags:\n- 磁盘\n- 操作系统\n- 硬件\n---\n# 磁盘的结构\n[管家公众号链接](https://mp.weixin.qq.com/s/-7FRZ-vuDuX9M2cT9C0AQg)\n硬盘最基本的组成部分是由坚硬金属材料制成的涂以磁性介质的盘片，一个硬盘包括有多个盘片，每个盘片有两面，都可记录信息。总共有多少个盘面，就有多少个磁头用来独写读写信息。每个扇区可存储128×2的N次方（N＝0.1.2.3）字节信息。在DOS中每扇区是128×2的2次方＝512字节。柱面是从最外缘的“0”开始编号，磁头从0开始编号，扇区是从1开始编号。柱面、磁头、扇区构成了硬盘结构的基本参数，硬盘的CHS，即Cylinder（柱面）、Head（磁头）、Sector（扇区），只要知道了硬盘的CHS的数目，即可确定硬盘的容量，计算公式为：存储容量＝磁头数×磁道（柱面）数×每道扇区数×每扇区字节数。一张磁盘有多个分区，比如C盘这个分区在最外层的磁道上，D盘在里面的磁道。一个分区包含很多个磁道组成。\n[什么是磁道，什么是簇，分区是怎样划分的？](https://zhidao.baidu.com/question/981853326082120459.html)\n# 簇\n## 簇的概念\n“簇”是DOS进行分配的最小单位。当创建一个很小的文件时，如是一个字节，则它在磁盘上并不是只占一个字节的空间，而是占有整个一簇。不同格式的磁盘，其簇的大小是不一样的。簇的概念仅适用于数据区。\n## 查看磁盘分区簇的大小\n在Windows操作系统中，可以使用Chkdsk命令查看硬盘分区的簇大小。该命令对硬盘进行分析，得到的分配单元的值就是该分区的簇的大小，比如我的C盘格式是NTFS，簇的大小是4KB。\n![enter image description here](https://img-blog.csdnimg.cn/20190616181435760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n[怎么查看簇大小？](https://zhidao.baidu.com/question/1388505773070899180.html)\n## 取合适的簇值\n理论上簇越小越好，因为这样可以节约空间。但事实是，簇太小会使系统性能有轻微下降。当一个大文件分开存放到好几个很小的簇上时，查找文件的时候，需要把这几个簇都给找出来，会影响到速度。4K的簇是比较合理的。若是NTFS格式，簇最小可达512B。FAT32 是比较好的格式，最小簇可达4KB。\n[簇大好还是小好](https://zhidao.baidu.com/question/327243804939618685.html)\n# 磁盘格式\nwindows下主要有FAT16、FAT32、NTFS 等，最新格式为exFAT，不同的磁盘格式有不同的特性。常见的FAT格式说的应该就是FAT16这个格式。\n## U 盘格式\nU盘默认的格式是FAT32，这个格式不允许传输超过4GB的大文件，将它转换成NTFS格式就可以了。但是这种格式是很伤U盘的，因为NTFS分区是采用“日志式”的文件系统，需要记录详细的读写操作，因为要不断读写，会影响到U盘的速度和寿命。\n## 区别\nFAT就是以前学操作系统时见到的文件分配表，File Allocation Table。\nNTFS 是New Technology File System。\nFAT16最大可以管理大到2GB的分区，但每个分区最多只能有65525个簇。随着硬盘或分区容量的增大，每个簇所占的空间将越来越大，从而导致硬盘空间的浪费。\nFAT32可以支持大到2TB的分区。FAT32使用的簇比FAT16小，从而有效地节约了硬盘空间。\nNTFS中簇的大小并不依赖于磁盘或分区的大小。簇尺寸的缩小不但降低了磁盘空间的浪费，还减少了产生磁盘碎片的可能。\n<font color=\"red\">这里的簇减小和磁盘碎片有什么关系呢？</font>\n[磁盘格式——百度百科](https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E6%A0%BC%E5%BC%8F/958346)\n## 磁盘格式转换为NTFS格式\n（管理员）运行命令行，输入`convert c:/fs:ntfs`。这应该是在运行一个命令行程序`convert.exe`，后面的是命令行参数。可以通过这条命令将FAT或FAT32卷转换为NTFS格式。一旦将某个驱动器或分区转换为NTFS格式，无法将其恢复回FAT或FAT32格式。只能通过格式化磁盘或者分区的方式恢复原来的格式，格式化的方法会丢失分区内所有的数据，格式化的时候可以指定分区的格式，也可以同时指定分区中簇的大小。\n![enter image description here](https://img-blog.csdnimg.cn/20190616181220266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n![enter image description here](https://img-blog.csdnimg.cn/20190616181603242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70)\n[怎么把磁盘格式转换为NTFS格式的啊？](https://zhidao.baidu.com/question/262020022.html)\n## NTFS格式簇大小\nNTFS支持512/1024/2048/4096/8192/16K/32K/64K。在NTFS文件系统中，当分区的大小在2GB以下时，簇的大小应该比相应的FAT32簇小，即小于4KB；当分区的大小在2GB以上时（2GB~2TB），簇的大小应该都为4KB。一般情况下使用默认的分区大小即可。\n[关于ntfs格式簇大小！！！](https://zhidao.baidu.com/question/7260210.html)\n# 如何划分整G硬盘\n比如在分区的时候想得到一个2G的分区，这时候输入2000M或者2048M所分出来的区在Windows下面都不会被认成整数的2G，而是1.9G多一点。\n整数G计算公式：(X－1)×4+1024×X=Y\n其中X就是想要得到的整数分区的数值，单位是G，Y是你分区时应该输入的数字，单位是M，例如想得到3G的分区就应该输入(3－1)×4+1024×3=3080，那么在分区时就应该输入3080作为分区的大小。\n# 绝对扇区与DOS扇区 \n用柱面/磁头/扇区可以唯一地定位磁盘上的一个特定的区域，或是说柱面/磁头/扇区与磁盘上每一个扇区有一一对应关系，这就是绝对扇区的表示方法。\n但DOS不能直接使用绝对扇区进行磁盘上的信息管理，而是用所谓“相对扇区”或“DOS扇区”。“相对扇区”只是一个数字，该数字与绝对扇区“柱面/磁头/扇区”具有一一对应关系。当使用相对扇区编号时，DOS是从柱面0，磁头1，扇区1开始（柱面0，磁头0的区域不属于DOS扇区，没有DOS扇区编号，DOS下不能访问，只能调用BIOS访问），该扇区的DOS扇区编号为0，是第一个DOS扇区。依次编号该磁道上剩余的其他扇区。然后是同柱面上其他磁道上的扇区。再然后是其他柱面上的扇区。\n# DOS磁盘区域的划分\n格式化好的硬盘，整个磁盘按所记录数据的作用不同可分为主引导记录（MBR:Main Boot Record），DOS引导记录 （DBR:DOS Boot Record），文件分配表（FAT:File Allocation Table），根目录 （BD:Boot Directory）和数据区。前4个重要信息在磁盘的外磁道上，每个磁道上存储的信息总量是一样的，而外圈周长大于内圈周长，也即外圈存储密度要小些，可靠性高些。\n## MBR \nMBR 位于硬盘第一个物理扇区（绝对扇区）柱面0，磁头0，扇区1处。由于DOS是由柱面0，磁头1，扇区1开始，故MBR不属于DOS扇区，DOS不能直接访问。MBR中包含硬盘的主引导程序和硬盘分区表。硬盘分区表有4个分区记录区。记录区就是记录有关分区信息的一张表。它从主引导记录偏移地址 01BEH处连续存放，每个分区记录区占16个字节。 \n4个分区中只能有1个活跃分区，即C盘。标志符是80H在分区记录区的第一个字节处。若第一个字节是00H则表示非活跃分区。例如： \n```\n80\t01\t01\t00\t0B\tFE\t3F\t81\t3F\t00\t00\t00\tC3\tDD\t1F\t00 \n00\t00\t01\t82\t05\tFE\tBF\t0C\t02\tDE\t1F\t00\t0E\t90\t61\t00 \n00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00 \n00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00\t00 \n```\n## DBR \nDBR 位于柱面0，磁头1，扇区1，即第一个DOS扇区（DOS扇区号为0）。DBR分为两部分：DOS引导程序和BPB（BIOS parameter block）。\n## 文件分配表 \n文件分配表是反映硬盘上所有簇的使用情况，通过查文件分配表可以得知任一簇的使用情况。DOS在给一个文件分配空间时总先扫描FAT，找到第一个可用簇，将该空间分配给文件，并将该簇的簇号填到目录的相应段内。FAT就是记录文件簇号的一张表。文件第一个簇号（在目录表中）和FAT中该文件的簇号串起来形成文件的“簇号链”，恢复被破坏的文件就是根据这条链。FAT位于DBR之后，其DOS扇区号从1开始。\n## 文件目录\n文件目录分为两类：根目录，子目录。根目录有一个，子目录可以有多个。子目录下还可以有子目录，从而形成“树状”的文件目录结构。DOS为目录项分配32字节。目录项分为三类：文件，子目录（其内容是许多目录项），卷标（只能在根目录，只有一个。目录项中有文件（或子目录，或卷标）的名字，扩展名，属性，生成或最后修改日期，时间，开始簇号，及文件大小。目录项的32个字节的分配如下：\n\n|意义|文件名|扩展名|文件属性|保留|时间|日期|开始簇号|文件长度|\n| :--: | :--:| :--: | :--: | :--: | :--: | :--: | :--: | :--: |\n|**字节数**|8B|3B|1B|10B|2B|2B|2B|4B|\n目录项文件名区域中第一个字节还有特殊的意义：00H代表未使用 ，EBH代表此文件已被删除。\nWINDOWS的长文件名使用了上表中所说的“保留”这片区域。\nDOS中DIR列出的内容是根据文件目录表得到的。 \n文件起始簇号填在文件目录中，其余簇都填在FAT中上一簇的位置上。<font color=\"red\">（上一簇是什么意思？？） </font>\n[硬盘基本知识（磁道、扇区、柱面、磁头数、簇、MBR、DBR）](http://blog.sina.com.cn/s/blog_711588b60102w464.html)\n","comments":true,"permalink":"http://yoursite.com/2019/06/16/磁盘与磁盘格式/","categories":[],"tags":[{"name":"磁盘","slug":"磁盘","permalink":"http://yoursite.com/tags/磁盘/"},{"name":"操作系统","slug":"操作系统","permalink":"http://yoursite.com/tags/操作系统/"},{"name":"硬件","slug":"硬件","permalink":"http://yoursite.com/tags/硬件/"}]},{"title":"程序运行时间","date":"2019-06-16T10:34:05.262Z","path":"2019/06/16/程序运行时间/","raw":"---\ntitle: 程序运行时间\ntags:\n- C++\n- 编程\n---\n# C++程序运行时间\n```C++\n#include<iostream>\n#include<ctime>\nusing namespace std;\nint main(){\n    clock_t startTime,endTime;\n    for(int i=0;i<123456789;i++){}\n    startTime=clock();\n    for(int i=0;i<123456789;i++){}\n    endTime=clock();\n    double time1=(double)(endTime-startTime)/CLOCKS_PER_SEC;\n    double time2=(double)endTime/CLOCKS_PER_SEC;\n    cout<<time1<<\" \"<<time2<<endl;\n    return 0;\n}\n```\n程序输出如下：\n```C++\n0.234 0.468\n```\n可以看出，两个循环的时间基本上就是一个循环的两倍。\n`<ctime>`库里面的clock()计时函数，返回的是程序从启动开始，到调用这个计时函数为止所花费的CPU时钟计时单元，在MSDN中称之为挂钟时间（wal-clock）。若挂钟时间不可取，则返回-1。其中clock_t是用来保存该计时单元的数据类型。此外还定义了一个常量CLOCKS_PER_SEC，它用来表示一秒钟会有多少个时钟计时单元。\n[C++如何记录程序运行时间](https://www.cnblogs.com/didiaodidiao/p/9194702.html)\n\n# 按值传参与引用传参的时间比较\n```C++\n#include<iostream>\n#include<ctime>\nusing namespace std;\nclass Base{\n    int n;\npublic:\n    Base(int n_):n(n_){}\n    fun1(Base t){}  //形参是对象\n    fun2(Base& t){} //形参是对象的引用\n};\nint main(){\n    clock_t startTime,endTime;\n    Base t1(4),t2(5);\n    startTime=clock();\n    for(int i=0;i<999999999;i++){t1.fun1(t2);}  //按值传参，调用复制构造函数\n    endTime=clock();\n    double time1=(double)(endTime-startTime)/CLOCKS_PER_SEC;\n    startTime=clock();\n    for(int i=0;i<999999999;i++){t1.fun2(t2);}  //引用传参\n    endTime=clock();\n    double time2=(double)(endTime-startTime)/CLOCKS_PER_SEC;\n    cout<<time1<<\" \"<<time2<<endl;\n    return 0;\n}\n```\n为什么引用传参的时间反而要多一些呢？\n```C++\n2.77 2.905\n```","comments":true,"permalink":"http://yoursite.com/2019/06/16/程序运行时间/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"编程","slug":"编程","permalink":"http://yoursite.com/tags/编程/"}]},{"title":"HTML学习笔记","date":"2019-06-16T10:34:05.240Z","path":"2019/06/16/HTML学习笔记/","raw":"---\ntitle: HTML学习笔记\ntags:\n- html\n---\n# 在Markdown中使用HTML标签\n[HTML常用标签大全](https://www.cnblogs.com/moije/articles/6751624.html)\n标签的基本使用方法，`<xx>这里是要输入的汉字</xx>`\n`<blockquote></blockquote>`块引用\n`<kbd></kbd>`键盘符号\n`<u></u>`下划线\n`<font color=\"red\"></font>`改变字体颜色\n`<font color=#ff0000></font>`改变字体颜色","comments":true,"permalink":"http://yoursite.com/2019/06/16/HTML学习笔记/","categories":[],"tags":[{"name":"html","slug":"html","permalink":"http://yoursite.com/tags/html/"}]},{"title":"C++学习笔记—类和对象提高","date":"2019-06-16T10:33:39.204Z","path":"2019/06/16/C++学习笔记——类和对象提高/","raw":"---\ntitle: C++学习笔记—类和对象提高\ntags:\n- C++\n---\n# C++程序与C语言程序的转换\n## C++版本\n```C++\n#include<iostream>\nusing namespace std;\n\nclass CCar{\n    int price;\npublic:\n    void setPrice(int p){price = p;}\n    void getPrice(){cout<<price<<endl;}\n};\n\nint main(){\n    CCar car;\n    car.setPrice(20000);\n    car.getPrice();\n    return 0;\n}\n```\n## C语言版本\n```C\n#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nstruct CCar{\n    int price;\n};\n\nvoid setPrice(struct CCar* thisss,int p){   //可能是因为this是关键字的缘故，不让用，换个名字就好了\n    thisss->price = p;\n}\n\nvoid getPrice(struct CCar* thisss){\n    cout<<thisss->price<<'\\n';\n}\n\nint main(){\n    struct CCar car;\n    setPrice(& car,20000);\n    getPrice(& car);\n    return 0;\n}\n```\n# this指针的作用\n```C++\n#include<iostream>\nusing namespace std;\n\nclass A{\n    int i;\npublic:\n    void fun(){cout<<\"Hello\"<<endl;}\n    //这一句在C语言里面是：  void fun(A* this){cout<<\"Hello\"<<endl;}\n\n    // void fun1(){cout<<i<<endl;}\n};\nint main(){\n    A* p = NULL;\n    p->fun();  //fun(p);\n    //这一句若是调用fun1() 函数就会出错\n    return 0;\n}\n```\nfun() 函数体功能的实现与形参指针是不是空指针没有关系\n类的静态成员函数不能使用this 指针，因为静态成员函数不具体作用于某一个对象\n非静态成员函数的真实参数个数等于实参个数加 1\n静态成员函数的真实参数个数就是看见的实参个数\n# this指针指向当前函数作用的对象\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Complex{\n    double real,imag;\npublic:\n    Complex(double r,double i):real(r),imag(i){}\n    void Print(){cout<<real<<\",\"<<imag<<endl;}\n    Complex addOne(){\n        this->real++;\n        this->Print();\n        return *this;\n    }\n};\nint main(){\n    Complex c1(1,1),c2(0,0);\n    c2 = c1.addOne();\n    c1.Print();\n    c2.Print();\n    return 0;\n}\n```\n非静态成员函数中，可以直接使用 this 来表示指向该函数作用的对象的指针，并用 *this 表示该函数作用的这个对象。也就是说，static函数里面，不能这么用this指针。\n程序输出：\n```C++\n2,1\n2,1\n2,1\n```\n# 静态成员\n引入静态机制，将一些和类紧密相关的全局变量或者全局函数，封装到类里面去，便于管理和维护\n```C++\n#include<iostream>\nusing namespace std;\n\n//静态成员（变量，函数）本质上是全局变量/函数\nclass Rectangle{\n    //普通成员变量每个对象都有自己的，静态成员变量只有一份，所有对象共享\n    int w;\n    int h;\n    int area;\n    static int totalNumber;\n    static int totalArea;\npublic:\n    Rectangle(int x,int y);\n    ~Rectangle();\n    //静态成员函数不作用于某个具体的对象\n    static void printTotal();\n};\n\nRectangle::Rectangle(int x,int y){\n    w = x;\n    h = y;\n    area  = x*y;\n    totalNumber ++;\n    totalArea += area;\n}\n\nRectangle::~Rectangle(){\n    totalNumber --;\n    totalArea -= area;\n}\n\n//静态成员定义的时候，就不要写static 了\nvoid Rectangle::printTotal(){\n    // cout<<w<<\" \"<<h<<\" \"<<area<<endl;\n    // 静态成员函数中，不能访问非静态成员变量，也不能调用非静态成员函数，因为不知道这个非静态作用在哪个对象上\n    cout<<totalNumber<<\" \"<<totalArea<<endl;\n}\n\n//必须在类的定义文件中，对静态成员变量进行一次说明或者初始化\n//相当于全局变量的初始化\nint Rectangle::totalNumber = 0;\nint Rectangle::totalArea = 0;\n\nint main(){\n    Rectangle r1(1,2),r2(3,3);\n    Rectangle::printTotal();  //通过类名来访问静态成员\n    r1.printTotal();    //也可以通过某个对象来访问静态成员函数\n    r2.printTotal();\n    cout<<sizeof(Rectangle);  //sizeof() 运算符不会计算静态成员\n    return 0;\n}\n```\n程序输出：\n```C++\n2 11\n2 11\n2 11\n12\n```\n# 封闭类\n成员变量中，含有成员对象的类叫做封闭类。\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Tyre{\n    int width;\n    int radius;\npublic:\n    Tyre(int w,int r):width(w),radius(r){cout<<\"Tyre constructed\"<<endl;}\n    ~Tyre(){cout<<\"Tyre destructed\"<<endl;}\n};\n\nclass Enginee{\n    int power;\npublic:\n    Enginee(int power_):power(power_){cout<<\"Enginee constructed\"<<endl;}\n    ~Enginee(){cout<<\"Enginee destructed\"<<endl;}\n};\n\nclass CCar{\n    int price;\n    Tyre tyre;\n    Enginee enginee;\npublic:\n    CCar(int p,int w,int r,int power_):enginee(power_),price(p),tyre(w,r){cout<<\"CCar constructed\"<<endl;}\n    ~CCar(){cout<<\"CCar destructed\"<<endl;}\n};\n\nint main(){\n    CCar car(20000,40,85,1000);\n    return 0;\n}\n```\n构造的时候，成员对象先构造，封闭类后构造。\n析构的时候，封闭类先析构，成员对象后析构。\n成员对象构造的时候，与封闭类中说明的顺序一致，和封闭类构造函数的初始化列表无关。如本例中，汽车类的构造函数初始化列表里面，是先初始化引擎成员，后初始化轮胎成员，但实际构造的时候，先构造轮胎对象，后构造引擎对象。\n程序输出：\n```C++\nTyre constructed\nEnginee constructed\nCCar constructed\nCCar destructed\nEnginee destructed\nTyre destructed\n```\n# 常量成员函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Sample{\n    int value;\npublic:\n    Sample(int v):value(v){}\n    void fun(){}\n    void setValue() const;  //声明一个常量成员函数\n};\n\nvoid Sample::setValue() const {  //常量成员函数的声明和定义，都要加上 const 关键字\n    cout<<value;\n    // fun();   //不能调用非常量成员函数\n    // value = 20; //常量成员函数不能改变属性的值\n}\n\nint main(){\n    const Sample obj(40);  //定义一个常量对象\n    obj.setValue();  //常量对象只能使用构造函数，析构函数，和 const 方法\n    return 0;\n}\n```\n如果一个成员函数没有修改成员变量的值，也没有调用非常量成员函数，那么最好写成常量成员函数的形式。\n虚函数和静态成员函数只在声明的时候写关键字，定义的时候可以不写。但是常量成员函数在定义和声明的时候，都要写上关键字。const是加在函数说明后面的类型修饰符，它是函数类型的一个组成部分，因此，在函数实现部分也要带const关键字。常量对象只能调用构造、析构和常量成员函数，而常量成员函数不能修改成员变量的值，也不能调用非常量成员函数（因为这可能会对成员变量的值做出修改），这就保证了常量对象的成员变量值不会被修改。\n# 常量成员函数重载\n```C++\n#include<iostream>\nusing namespace std;\nclass Test{\n    int value;\npublic:\n    Test(){value = 1;}\n    void getValue() const {cout<<value<<endl;}\n    void getValue()  {value = 2;cout<<value<<endl;}\n};\n\nint main(){\n    const Test t1;  //常量对象\n    Test t2;    //非常量对象\n    t1.getValue();  //常量对象只能调用常量成员函数\n    t2.getValue();  //非常量对象默认调用的是非常量成员函数\n    //如果没有非常量成员函数，也是可以调用常量成员函数的\n    return 0;\n}\n```\n程序输出：\n```C++\n1\n2\n```\n# mutable成员变量\n```C++\n#include<iostream>\nusing namespace std;\nclass Sample{\n    mutable int m;\n    bool n;\npublic:\n    void fun() const {\n        m++;\n        cout<<m<<endl;\n    }\n    Sample(bool flag,int value){n = flag;m = value;}\n};\nint main(){\n    Sample s(true,6);\n    s.fun();  //非常量对象调用常量成员函数\n    return 0;\n}\n```\n程序输出：\n```C++\n7\n```\n本来，常量成员函数里面是不可以调用非常量成员函数的，也不可以修改成员变量的值。但是将成员变量加上`mutable`关键字之后，就可以在常量成员函数里面修改了。\n# 友元函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Car;  //提前声明Car类，供后面的Driver类调用\n\nclass Driver{\npublic:\n    void modifyCar(Car* car); //这里是指针，如果参数是对象的话，前面的Car类就不能仅仅声明，就要完整地写完\n};\n\nclass Car{\n    int price;\npublic:\n    friend void Driver::modifyCar(Car* car);  //把Driver 的成员函数声明为友元\n    friend int mostExpensiveCar(Car car[],int totalNumber);  //把一个全局函数声明为友元\n};\n\nint mostExpensiveCar(Car car[],int totalNumber){  //找到最贵的车的编号\n    int maxPrice = -1;\n    int index = 0;\n    for(int i = 0;i < totalNumber;i++){\n        if(car[i].price>maxPrice){  //友元函数可以访问私有成员\n            maxPrice = car[i].price;\n            index = i;\n        }\n    }\n    return index;\n}\n\nvoid Driver::modifyCar(Car* car){\n    car->price += 1000;\n}\n\nint main(){\n    return 0;\n}\n```\n把一个函数声明为友元（不是该类的成员函数，这样这个函数就可以访问该类的私有成员）。可以把一个类的成员函数（包括构造，析构函数）声明为另一个类的友元函数。\n# 友元类\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Car{\n    int price;\npublic:\n    friend class Driver;\n};\n\nclass Driver{\n    Car car;\npublic:\n    void modify(){\n        car.price += 1000;\n    }\n};\n\nint main(){\n    return 0;\n}\n```\nDriver 是 Car 的友元类，所以Driver 的成员函数可以访问Car 的私有成员\n友元类之间的关系不能传递，不能继承\n若类A是类B的友元，但是类B不一定是类A的友元\n","comments":true,"permalink":"http://yoursite.com/2019/06/16/C++学习笔记——类和对象提高/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++学习笔记—类和对象基础","date":"2019-06-08T14:13:45.138Z","path":"2019/06/08/C++学习笔记——类和对象基础/","raw":"---\ntitle: C++学习笔记—类和对象基础\ntags:\n- C++\n---\n\n## 通过成员函数访问类的私有成员\n```C++\n#include<iostream>\n#include<string.h>\nusing namespace std;\n\n/*默认是私有成员\n私有成员只能在成员函数里面访问\n成员函数能够访问当前对象和同类其他对象的全部属性和函数*/\n\nclass CEmployee{\nprivate:\n    char szName[20];\npublic:\n    int salary;\n    void setName(const char name[]);\n    void getName(char* name);\n    void avgSalary(CEmployee e1,CEmployee e2);\n};\n\nvoid CEmployee::getName(char* name){  //定义成员函数的时候，不要忘了返回类型\n    strcpy(name,szName);\n}\n\nvoid CEmployee::setName(const char name[]){\n    strcpy(szName,name);\n}\n\nvoid CEmployee::avgSalary(CEmployee e1,CEmployee e2){\n    cout<<e1.szName<<\" \"<<e2.szName;  //访问同类其他对象的私有成员，ok\n    salary = (e1.salary+e2.salary)/2;\n}\n\nint main(){\n    CEmployee e;\n    e.setName(\"xtncsg\");\n    // strcpy(e.szName,\"xtncsg\"); 在成员函数以外访问私有成员，error\n    e.salary = 5000;\n    char name[20];\n    e.getName(name);\n    cout<<name<<endl;\n    return 0;\n}\n```\n设置私有成员的机制，叫做隐藏，目的是强制对成员变量的访问一定要通过成员函数进行，这样以后当成员变量修改了的时候，只要修改这些成员函数即可，要不然所有涉及到成员变量的地方都要修改。\n## 成员函数的重载与参数缺省\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Location{\nprivate:\n    int x,y;\npublic:\n    //成员函数的重载\n    int valueX() {return x;}\n    void valueX(int tmp)  {x = tmp;}\n    //成员函数的缺省值\n    int init(int a = 0,int b = 0);\n};\n//声明的时候有缺省值，定义的时候这里不要写缺省值\nint Location::init(int a,int b){\n    x = a;\n    y = b;\n}\nint main(){\n    Location a;\n    a.init(5);\n    cout<<a.valueX()<<endl;\n    a.valueX(4);\n    cout<<a.valueX()<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\n5\n4\n```\n## 构造函数\n构造函数也是成员函数，可以有参数，没有返回值，可以有多个，名字和类名相同，不写则生成\n无参构造函数，对象生成时自动被调用，对象生成以后，再也不会调用构造函数。构造函数最好是公有的，私有的构造函数不能直接初始化对象。\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Complex{\nprivate:\n    int real,imag;\npublic:\n    //void Complex(int x,int y = 0);  始终记住构造函数是没有返回值滴！！！！！\n    Complex(int x,int y = 0);\n    Complex();\n    Complex(Complex c1,Complex c2);\n    int getX();\n    int getY();\n};\n\nComplex::Complex(int x,int y){\n    real = x,imag = y;\n}\nComplex::Complex(){\n    real = 1,imag = 1;\n}\n\nComplex::Complex(Complex c1,Complex c2){\n    real = c1.real + c2.real;\n    imag = c1.imag + c2.imag;\n}\n\n/* 不是这么个用法。。。。\nint Complex::getX(Complex c){\n    return c.real;\n}\n*/\nint Complex::getX(){\n    return real;\n}\n\nint Complex::getY(){\n    return imag;\n}\n\nint main(){\n    Complex c1;  //注意，调用无参构造函数没有括号\n    Complex c2(2,3);\n    Complex* c3 = new Complex(4,5);\n    Complex c4(c1,c2);\n    // cout<<c1.real<<\" \"<<c1.imag<<endl;  不能绕过成员函数去访问私有成员\n    cout<<c1.getX()<<\" \"<<c1.getY()<<endl;\n    cout<<c2.getX()<<\" \"<<c2.getY()<<endl;\n    cout<<c3->getX()<<\" \"<<c3->getY()<<endl;  //c3不是一个对象，只是一个指向对象的指针\n    cout<<c4.getX()<<\" \"<<c4.getY()<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\n1 1\n2 3\n4 5\n3 4\n```\n[使用无参构造函数创建对象时，不应该在对象名后面加上括号](https://zhidao.baidu.com/question/1373261479925791099.html)\n## Struct定义类\n```C++\n#include<iostream>\nusing namespace std;\n\nstruct CEmployee{\n    char szName[20];\npublic:\n    void getName(char name[]);\n    void setName(char name[]);\n    int salary;\n    void avgSalary(CEmployee e1,CEmployee e2);\n};\n\nint main(){\n    return 0;\n}\n```\n如果使用 struct 关键字，则定义在第一个访问说明符之前的所有成员都默认是 public 的；\n但如果使用 class关键字，那么定义在第一个访问说明符之前的成员默认都是 private 的。\n[C++：用class和struct关键字定义类,有什么不同？](https://blog.csdn.net/growth_path_/article/details/82704949)\n## 函数重载与缺省参数\n```C++\n#include<iostream>\nusing namespace std;\n\nvoid fun(int a,int b)  {printf(\"%d\\n\",a+b);}\nvoid fun(int a,int b,int c)  {printf(\"%d\\n\",a+b+c);}\nvoid fun(double a)  {printf(\"%-6.2f\\n\",a);} //负号是左对齐\nvoid fun(char c)  {printf(\"%d\\n\",c);}\n\n//只能让最右边的若干个参数有缺省值\nvoid Fun(int a,int b=2,int c=3)  {printf(\"%d\\n\",a+b+c);}\n\nint main(){\n    /*参数列表不同就叫做重载*/\n    fun(1,2);\n    fun(1,2,3);\n    fun(3.1415926535);  //这里的参数是一个double ，而不是float\n    fun('A');\n\n    Fun(1);\n    Fun(3,5);\n    Fun(2,4,8);\n\n    return 0;\n}\n```\n程序输出结果：\n```C++\n3\n6\n3.14\n65\n6\n11\n14\n```\n## 对象数组使用构造函数初始化对象\n```C++\n#include<iostream>\nusing namespace std;\n\nclass CSample{\npublic:\n    int n;\n    CSample();\n    CSample(int x);\n};\n\nCSample::CSample(){cout<<\"Constructor 1 called\"<<endl;}\n\nCSample::CSample(int x) {n = x;cout<<\"Constructor 2 called\"<<endl;}\n\nint main(){\n    CSample a[2];\n    cout<<a[0].n<<\" \"<<a[1].n<<endl;\n    cout<<\"step 1\"<<endl;\n    //写构造函数的参数时，既可以直接写参数，也可以用类名给它括起来\n    CSample b[2] = {4,CSample(5)};\n    cout<<b[0].n<<\" \"<<b[1].n<<endl;\n    cout<<\"step 2\"<<endl;\n    CSample c[2] = {3};\n    //c[1]对象没有指定构造函数的参数，调用的是无参构造函数\n    cout<<c[0].n<<\" \"<<c[1].n<<endl;\n    cout<<\"step 3\"<<endl;\n    //new 出来的对象这样子调用构造函数\n    CSample* d = new CSample[2]{4,6};\n    cout<<d[0].n<<\" \"<<d[1].n<<endl;\n    cout<<\"step 4\"<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\nConstructor 1 called\nConstructor 1 called\n1640817921 -2\nstep 1\nConstructor 2 called\nConstructor 2 called\n4 5\nstep 2\nConstructor 2 called\nConstructor 1 called\n3 7208696\nstep 3\nConstructor 2 called\nConstructor 2 called\n4 6\nstep 4\n```\n## 缺省的复制构造函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Complex{\n    double real,imag;\npublic:\n    //Complex(Complex c){} \n    //invalid constructor; you probably meant 'Complex (const Complex&)'|\n    double getReal(){return real;}\n    double getImag(){return imag;}\n};\n\nint main(){\n    Complex c1;  //调用缺省的无参构造函数\n    cout<<c1.getReal()<<\" \"<<c1.getImag()<<endl;\n    Complex c2(c1);  //调用缺省的复制构造函数\n    cout<<c2.getReal()<<\" \"<<c2.getImag()<<endl;\n    return 0;\n}\n//形如 Complex c2(c1)这样的是复制构造函数，不允许写这样子的构造函数（只有一个同类对象作为参数）\n```\n程序输出结果：\n```C++\n2.05159e-307 2.05175e-307\n2.05159e-307 2.05175e-307\n```\n## 指针数组和数组指针的构造函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Test{\npublic:\n    Test(){cout<<\"Constructor 1 called\"<<endl;}\n    Test(int n){cout<<\"Constructor 2 called\"<<endl;}\n    Test(int m,int n){cout<<\"Constructor 3 called\"<<endl;}\n};\n\nint main(){\n    Test a[2] = {Test(4),Test(1,2)};\n    cout<<\"step 1\"<<endl;\n\n    //这一步不会造成歧义，默认每个对象分配一个构造函数的参数\n    //以逗号进行分隔，分配构造函数的参数\n    Test b[2] = {3,5};\n    cout<<\"step 2\"<<endl;\n\n    Test c[2] = {6,Test(2,2)};\n    cout<<\"step 3\"<<endl;\n    //第二个对象调用无参构造函数\n    Test d[2] = {Test(4)};\n    cout<<\"step 4\"<<endl;\n    Test e[2];\n    cout<<\"step 5\"<<endl;\n\n    //f[3]与g[3]都是空指针\n    Test* f[3] = {new Test(2),new Test}; //指针数组，多出的一个是空指针\n    cout<<\"step 6\"<<endl;\n\n    Test* g[3] = {new Test(2),new Test,NULL};\n    cout<<\"step 7\"<<endl;\n\n    Test* h = new Test[2]{4,6}; //数组指针\n    cout<<\"step 8\"<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\nConstructor 2 called\nConstructor 3 called\nstep 1\nConstructor 2 called\nConstructor 2 called\nstep 2\nConstructor 2 called\nConstructor 3 called\nstep 3\nConstructor 2 called\nConstructor 1 called\nstep 4\nConstructor 1 called\nConstructor 1 called\nstep 5\nConstructor 2 called\nConstructor 1 called\nstep 6\nConstructor 2 called\nConstructor 1 called\nstep 7\nConstructor 2 called\nConstructor 2 called\nstep 8\n```\n## 复制构造函数\n复制构造函数，只有一个参数，即对同类对象的引用，可以是常引用，不写则调用编译器自动生成的复制构造函数，完成对象的复制。\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Complex{\n    double real,imag;\npublic:\n    Complex(){real = 1,imag = 2;}\n    Complex(const Complex& c){real = c.real;imag = c.imag;}\n    //常引用，c的值不能修改\n\n    double getReal(){return real;}\n    double getImag(){return imag;}\n};\n\nint main(){\n    Complex c1;\n    cout<<c1.getReal()<<\" \"<<c1.getImag()<<endl;\n    Complex c2(c1);  //等同于 Complex c2 = c1，初始化语句，非赋值语句\n    cout<<c2.getReal()<<\" \"<<c2.getImag()<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\n1 2\n1 2\n```\n## 函数形参是对象与复制构造函数起作用\n```C++\n#include<iostream>\n#include<ctime>\nusing namespace std;\n\nclass A{\npublic:\n    A(){cout<<\"Constructor is called\"<<endl;}\n    A(A& a){cout<<\"Copy Constructor is called\"<<endl;}\n};\n\nvoid fun(A a2){cout<<\"fun() is called\"<<endl;}\n\nint main(){\n    A a1;\n    for(int i=0;i<10;i++){\n        fun(a1);\n    }\n    clock_t spendTime=clock();\n    double time=(double)spendTime/CLOCKS_PER_SEC;\n    cout<<time;\n    return 0;\n\n}\n```\n函数 fun() 有一个参数是类A的对象，当这个函数被调用时，类A的复制构造函数会被调用。这里是将 a1 对象复制给 a2 对象。先调用复制构造函数，再完成 fun() 函数自己的函数体语句。事实上，fun() 函数的参数是一个对象，生成形参时会调用复制构造函数，开销比较大，可以考虑使用引用或者 const 常引用这样就不会调用复制构造函数了。\n程序输出结果：\n```C++\nConstructor is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\nCopy Constructor is called\nfun() is called\n0.015\n```\n## 函数返回值是对象与复制构造函数起作用\n```C++\n#include<iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int v;\n    A(int n){v = n;cout<<\"Constrctor called\"<<endl;}\n    A(const A& a){v = a.v + 1;cout<<\"Copy Constructor called\"<<endl;}\n};\n\n\nA fun(){\n    A b(4);\n    cout<<\"step\"<<endl;\n    return b;\n}\n\nint main(){\n    cout<<fun().v<<endl;\n    return 0;\n}\n```\n如果函数的返回值是类A的对象，则函数返回时，A的复制构造函数会被调用。main 函数里，fun() 得到的是一个临时对象tmp,这里将b 这个对象复制给tmp，然后输出tmp.v。这个不同的编译器不一样，在codeblocks不会调用（出于优化的目的），而在 VS2012里面会调用。\n程序输出结果：\n```C++\nConstrctor called\nstep\n4\n```\n## 构造、复制与析构的调用\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Demo{\n    int n;\npublic:\n    Demo(int v){n = v;cout<<\"n=\"<<n<<\" constructed\"<<endl;}\n    ~Demo(){cout<<\"n=\"<<n<<\" destructed\"<<endl;}\n};\n\nDemo d1(1);  //先析构静态对象，后析构全局对象\n\nvoid fun(){\n    static Demo d2(2);  //静态对象的生命周期是整个程序\n    Demo d3(3);\n    cout<<\"++++++++++++++\"<<endl;\n}\n\nint main(){\n    Demo d4(4);\n    d4 = 6;  //调用类型转换构造函数生成临时对象，会调用构造函数和析构函数\n    cout<<\"--------------\"<<endl;\n    {\n        Demo d5(5);  //整个括号即是该对象的生命周期，生命周期结束会析构\n    }\n    cout<<\"%%%%%%%%%%%%%%%\"<<endl;\n    fun();\n    cout<<\"*****************\"<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\nn=1 constructed\nn=4 constructed\nn=6 constructed\nn=6 destructed\n--------------\nn=5 constructed\nn=5 destructed\n%%%%%%%%%%%%%%%\nn=2 constructed\nn=3 constructed\n++++++++++++++\nn=3 destructed\n*****************\nn=6 destructed\nn=2 destructed\nn=1 destructed\n```\n\n```C++\n#include<iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int n;\n    A(int v){n = v;cout<<\"n=\"<<n<<\" constructed\"<<endl;}\n    A(const A& a){n = a.n + 1;cout<<\"n=\"<<n<<\" copy consructed\"<<endl;}\n    ~A(){cout<<\"n=\"<<n<<\" desructed\"<<endl;}\n};\n\nA obj(2);  //全局对象会构造和析构\n\nA fun(A a){   //参数对象生成时会复制，消亡时会析构\n    return a;\n}\n\nint main(){\n    A tobj(8);\n    tobj = fun(obj);  //临时对象生成时会复制，消亡时会析构\n    tobj.n += 2;\n    return 0;\n}\n/*各个对象生成复制，析构的顺序\n全局对象生成，局部对象生成，形参对象复制生成，临时对象复制生成，临时对象消亡，形参对象消亡，局部对象消亡，全局对象消亡*/\n```\n程序输出结果：\n```C++\nn=2 constructed\nn=8 constructed\nn=3 copy consructed\nn=4 copy consructed\nn=4 desructed\nn=3 desructed\nn=6 desructed\nn=2 desructed\n```\n复制构造函数调用的两个时机：\n1.函数的形参是类的对象时\n2.函数的返回值是类的对象时\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Demo{\n    int n;\npublic:\n    //注意构造函数的另一种写法\n    Demo(int v):n(v){cout<<\"n=\"<<n<<\" constructed\"<<endl;}\n    Demo(const Demo& d){n = d.n;cout<<\"n=\"<<n<<\" copy constructed\"<<endl;}\n    ~Demo(){cout<<\"n=\"<<n<<\" destructed\"<<endl;}\n};\n\nvoid fun(Demo obj){   //这里会有 obj 对象的复制和析构\n    cout<<\"-----------\"<<endl;\n}\n\nDemo d1(1);\n\nDemo test(){\n    cout<<\"++++++++++\"<<endl;\n    return d1;\n}\n\nint main(){\n    Demo d2(2);\n    fun(d2);\n    test();  //返回值临时对象的复制和析构\n    return 0;\n}\n```\n程序输出如下：\n```C++\nn=1 constructed\nn=2 constructed\nn=2 copy constructed\n-----------\nn=2 destructed\n++++++++++\nn=1 copy constructed\nn=1 destructed\nn=2 destructed\nn=1 destructed\n```\n## delete调用析构函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Ctest{\npublic:\n    Ctest(){cout<<\"C Constructor called\"<<endl;}\n    ~Ctest(){cout<<\"C Destructor called\"<<endl;}\n};\n\nclass Ptest{\n    int k;\npublic:\n    Ptest(){cout<<\"P Constructor called\"<<endl;}\n    ~Ptest(){cout<<\"P Destructor called\"<<endl;}\n};\n\nint main(){\n    cout<<sizeof(Ctest)<<\" \"<<sizeof(Ptest)<<endl<<endl;  //空类大小一个字节\n    Ctest* c = new Ctest;\n    delete c;\n    cout<<\"------------\"<<endl<<endl;\n    Ptest* p = new Ptest[3];\n    delete []p;\n    cout<<\"---------------\"<<endl<<endl;\n    Ptest* q = new Ptest[2];\n    delete q;  //这样只会析构对象数组里的一个对象\n    return 0;\n}\n```\n程序输出结果：\n```C++\n1 4\n\nC Constructor called\nC Destructor called\n------------\n\nP Constructor called\nP Constructor called\nP Constructor called\nP Destructor called\nP Destructor called\nP Destructor called\n---------------\n\nP Constructor called\nP Constructor called\nP Destructor called\n```\n## 对象数组的析构函数\n对象数组生命周期结束时，所有对象的析构函数都会被调用。析构函数没有参数和返回值，一个类里面最多只有一个析构函数，不写则编译器生成缺省析构函数，它啥也不做。\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Ctest{\npublic:\n    ~Ctest(){cout<<\"Destructor called\"<<endl;}\n};\n\nint main(){\n    Ctest array[2];\n    cout<<\"END\"<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\nEND\nDestructor called\nDestructor called\n```\n## 类型转换构造函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Complex{\npublic:\n    double real,imag;\n    Complex(double a,double b){real = a;imag = b;cout<<\"origin constructor called\"<<endl;}  //构造函数\n    Complex(int i){   //类型转换构造函数\n        cout<<\"Converse Constructor called\"<<endl;\n        real = i;\n        imag = 0;\n    }\n    explicit Complex(double j){   //显式类型转换构造函数\n        cout<<\"Explicit Converse Constructor called\"<<endl;\n        real = j;\n        imag = 1;\n    }\n    Complex(const Complex& a){  //复制构造函数\n        real = a.real;\n        imag = a.imag;\n        cout<<\"Copy Constructor called\"<<endl;\n    }\n};\n\nint main(){\n    Complex a1(7,2);\n    cout<<a1.real<<\" \"<<a1.imag<<endl;\n    cout<<\"step 1\"<<endl;\n    Complex a2 = 6;  //虽然调用类型转换构造函数生成了一个无名的临时对象，但这里不是初始化语句，并不会调用复制构造函数\n    cout<<a2.real<<\" \"<<a2.imag<<endl;\n    cout<<\"step 2\"<<endl;\n    Complex a3 = 4.85; //虽然不能调用显式类型转换构造函数，但是可以将double转换成int,从而调用第一个类型转换构造函数\n    cout<<a3.real<<\" \"<<a3.imag<<endl;\n    cout<<\"step 3\"<<endl;\n    Complex a4 = Complex(5.56);\n    cout<<a4.real<<\" \"<<a4.imag<<endl;\n    cout<<\"step 4\"<<endl;\n    a1 = Complex(5);\n    cout<<a1.real<<\" \"<<a1.imag<<endl;\n    cout<<\"step 5\"<<endl;\n    Complex a6 = a1;  //初始化语句，调用复制构造函数\n    cout<<a6.real<<\" \"<<a6.imag<<endl;\n    cout<<\"step 6\"<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\norigin constructor called\n7 2\nstep 1\nConverse Constructor called\n6 0\nstep 2\nConverse Constructor called\n4 0\nstep 3\nExplicit Converse Constructor called\n5.56 1\nstep 4\nConverse Constructor called\n5 0\nstep 5\nCopy Constructor called\n5 0\nstep 6\n```\n## 初始化语句与赋值语句\n```C++\n#include<iostream>\nusing namespace std;\n\nclass A{\npublic:\n    int n;\n    A(){};\n    A(int v){n = v;}\n    A(const A& a){n = a.n + 1;cout<<\"Copy Constructor called\"<<endl;}\n};\n\nint main(){\n    A a1(4);\n    A a2 = a1;  //初始化语句，调用复制构造函数\n    A a3;\n    a3 = a1;    //赋值语句，不会调用复制构造函数\n    A a4(a1);   //调用复制构造函数\n    cout<<a1.n<<endl<<a2.n<<endl<<a3.n<<endl<<a4.n<<endl;\n    return 0;\n}\n```\n程序输出结果：\n```C++\nCopy Constructor called\nCopy Constructor called\n4\n5\n4\n5\n```\n\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/08/C++学习笔记——类和对象基础/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++学习笔记—从C到C++","date":"2019-06-08T14:13:43.497Z","path":"2019/06/08/C++学习笔记——从C到C++/","raw":"---\ntitle: C++学习笔记—从C到C++\ntags:\n- C/C++\n- 指针\n---\n\n## 常量指针与指针常量\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n    int n,m;\n    const int* p = &n;  //int const* p = &n;\n    //*p = 15;  //error: assignment of read-only location '* p',不能通过常量指针修改它所指向的值\n    n =20;\n    p = &m;   //常量指针的指向可以改变\n    int* q;\n    /* q = p;   //不能把常量指针赋值给非常量指针，类似于常引用与非常引用的关系，因为 *q 是可以改变的，但是 p 所指向的，我们不希望改变\n    error: invalid conversion from 'const int*' to 'int*' [-fpermissive]*/\n\n    p = q;  //但是非常赋值给常是没有问题的\n\n    int* const t=&m; //指针常量\n    //t=&n;  指针常量是一个常量，指针的指向不能更改\n    *t=100;   //指针常量的值可以改变\n\n    int a;\n    const int* const s=&a;  //指向常量的常指针\n\n    return 0;\n}\n```\n<kbd>\\*</kbd>前面的是对被指向对象的修饰，<kbd>\\*</kbd>后面的是对指针本身的修饰\n常量指针写法：`const int* p`，本质是一个指针，指向常量，因此指向可以改，但是所指向的值不可以改。因为int 和const都作为一个类型限定词，有相同的地位，所以也可以写成 `int const *p`。\n指针常量写法：`int* const p`，本质是一个常量，一个指针形式的常量，因此指向不可以改变，但是所指向的值可以修改。\n在`gcc`中，const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。\nconst是在编译器中实现的，编译时检查，并非不能骗过。所以在C语言中使用const，就好象是一种道德约束而非法律约束，所以使用const时更多是传递一种信息，就是告诉编译器、也告诉读程序的人，这个变量是不应该也不必被修改的。\n[理解指针常量与常量指针](https://www.cnblogs.com/zhangrxiang/p/8647602.html)\n## inline内联\n```C++\n#include<iostream>\nusing namespace std;\ninline max(int a,int b){return (a>b)?a:b;}\n\nint main(){\n    int a,b;\n    cin>>a>>b;\n    //将整个函数的代码插入到这里，不会产生调用函数的语句，节省了时间开销\n    cout<<max(a,b);\n    return 0;\n}\n```\n## new运算符\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n    int* p = new int;\n    *p = 15;\n    delete p;  //一片空间不能被 delete 多次，但是并不会报错\n    delete p;\n\n    char* q = new char[15];  //分配一个数组，共有15个元素，每个元素都是一个 char,并把数组首地址赋值给 char* 指针 q\n    q[0] = 'K';  //注意这里不需要 * 号\n    printf(\"%c\\n\",q[0]);\n    delete []q;\n    delete []q;\n    return 0;\n}\n```\n## 函数指针\n```C++\n// return type(* pointer name)(parameter1,parameter2,.....)\n\n#include<iostream>\nusing namespace std;\n\nvoid printMin(int a,int b){\n    cout<<(a>b?b:a);\n}\n\nint main(){\n    int x,y;\n    cin>>x>>y;\n    void (*p)(int,int);  //定义函数指针\n    p=printMin;  //函数指针赋值\n    p(x,y);    //调用函数指针指向的函数\n    return 0;\n}\n```\n## qsort()排序函数\n```C++\n// C语言库函数qsort 可以对任意类型数组排序\n// 将一个 unsigned int 的数组按照个位数从小到大排序\n#include<iostream>\nusing namespace std;\n\n//比较函数，将两个元素的地址传给它，判断谁前谁后\nint myCompare(const void* elem1,const void* elem2){\n    unsigned int* p1, *p2;\n    p1 = (unsigned int*)elem1;  //直接*elem1 非法，因为是 void* 类型的指针，无法判断多少字节，所以要强转\n    p2 = (unsigned int*)elem2;\n    return ((*p1%10)-(*p2%10));\n    //如果 elem1在前，则返回一个负整数，在后则返回一个正整数，无所谓则返回0\n}\nint main(){\n    unsigned int a[5] = {10,25,31,29,16};\n    int(*p)(const void*,const void*); //函数指针先定义后赋值\n    p = myCompare;\n    //qsort 不能写返回值，参数列表是数组起始地址，数组元素个数，每个元素的大小，指向比较函数的函数指针\n    qsort(a,5,sizeof(unsigned int),p);\n    //qsort(a,5,sizeof(unsigned int),myCompare); 或者直接写比较函数的名字也行\n    for(int i=0;i<5;i++)\n        cout<<a[i]<<\" \";\n    return 0;\n}\n```\n## 引用与常引用\n常引用也不能改变所引用的对象，引用一个对象之后不能再改成引用别的对象\n`int& `这样的引用或者` int `这样的变量可以用来初始化 `const int&`这样的引用，如本例。`const int&` 这样的引用或者` const int`这样的常变量不可以用来初始化` int& `这样的引用，除非强制类型转换。\n```C++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    int n=40;\n    const int& r=n;\n    // r=200; 不能通过常引用去修改他所引用的对象\n    n=300;\n    return 0;\n}\n```\n## 交换数据的三种方式\n```C++\n#include<iostream>\nusing namespace std;\n\nvoid swap1(int x,int y){\n    int tmp=x;\n    x=y;\n    y=tmp;\n}\nvoid swap2(int* x,int* y){\n    int tmp=*x;\n    *x=*y;\n    *y=tmp;\n}\nvoid swap3(int &x,int &y){\n    int tmp=x;\n    x=y;\n    y=tmp;\n}\n\nint main(){\n    int a,b;\n    cin>>a>>b;\n    swap1(a,b);\n    cout<<a<<\" \"<<b<<endl;\n\n    int c,d;\n    cin>>c>>d;\n    swap2(&c,&d);\n    cout<<c<<\" \"<<d<<endl;\n\n    int e,f;\n    cin>>e>>f;\n    swap3(e,f);\n    cout<<e<<\" \"<<f<<endl;\n\n    return 0;\n}\n```\n## 命令行参数\n```C++\n#include<iostream>\nusing namespace std;\n// 在命令行中打开命令行参数这个可执行程序，argc表示接收的命令行参数的数量，共3个\n// argv[]表示一个指针数组，每个元素都是一个 char* 指针，指向一个命令行参数的字符串\nint main(int argc,char* argv[]){\n    cout<<argc<<endl;\n    for(int i=0;i<argc;i++){\n        cout<<argv[i]<<endl;  //这里为什么不用*呢？\n    }\n}\n```\n命令行界面的输入输出如下：\n```C++\nMicrosoft Windows [版本 10.0.16299.15]\n(c) 2017 Microsoft Corporation。保留所有权利。\n\nC:\\Users\\14311>e:\n\nE:\\>cd 北大C++程序设计\n\nE:\\北大C++程序设计>cd 从C到C++\n\nE:\\北大C++程序设计\\从C到C++>命令行参数 100 200 300\n4\n命令行参数\n100\n200\n300\n```\n<kbd>E:</kbd>进入磁盘，<kbd>cd 文件夹名称</kbd> 进入文件夹，命令行参数包括所需要打开的应用程序名。<kbd>cd ..</kbd>返回上一级目录，<kbd>dir</kbd>查看当前目录下所有的子目录与文件\n[命令行怎么进入d盘](https://jingyan.baidu.com/article/4f7d5712f2513b1a201927a5.html?wap_detail_test=T1)\n[命令行怎么返回上一级目录](https://zhidao.baidu.com/question/167315080/answer/2366812393.html?fr=index_ans)\n## 判断第n位是0还是1\n```C++\n// 有两个 int 数据 a 和 n，判断 a 的第 n 位是 1 还是 0\n// 其中 n 是 0 <= n < 31（int型值占4个字节，32bit）\n\n\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nint main(){\n    int a,n;\n    cin>>a>>n;\n    //2^n 不能直接与，要先指明它的类型\n    int ans = a&(int)pow(2,n);\n    cout<<ans<<endl;\n    if(ans==0) cout<<\"a的第n位是0\";\n    else cout<<\"a的第n位是1\";\n\n    int b,m;\n    cin>>b>>m;\n    int tmp=(b>>m)&1;\n    cout<<tmp<<endl;\n    if(tmp==1) cout<<\"b的第n位是1\";\n    else cout<<\"b的第n位是0\";\n    return 0;\n}\n```\n程序输出结果如下：\n```C++\n15 3\n8\na的第n位是1\n24 3\n1\nb的第n位是1\n```\n方法一的原理是：\n要判断第n位是0还是1，就想办法构造一个数，它的第n位是1，其余位都是0，这就是2的n次方。将这个数与原来的数相与，结果只取决于我们所要判断的这个位。如果待判断的位上是1，那么相与之后就是1，否则就是0。\n方法二的原理是：\n`int b=24`，二进制是0001<font color=\"red\">1</font>000，现在判断第3位上是0还是1，就右移操作，把这一位移动到最右边，即右移3位，变成0000001<font color=\"red\">1</font>，这样所要判断的位在最右边，至于前面的位不用管。任何一个数与`0000....000001`这样的数按位与，得到的结果只取决于这个数的最后一位。因此，如果待判断的位上是1，那么相与之后就是1，否则就是0。\n## 位运算\n```C++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    // a 的低8位清零，其余位保持不变\n    int a=56;\n    a &= 0xffffff00;  //与1结果不变，与0则清零\n    cout<<a<<endl;\n\n    // 判断 b 的第7位是不是1，第0位在最右边\n    int b=154;\n    b &= 0x80;\n    cout<<(b==0x80?\"是\":\"不是\")<<endl;\n\n    // c 的低8位置1，其余位保持不变\n    int c=144;\n    c |= 0xff;   //或0结果不变，或1则置1\n    cout<<c<<endl;\n\n    // d 的低8位取反，其余位不变\n    int d=19;\n    d ^= 0xff;  //异或1取反，异或0结果不变\n    cout<<d<<endl;\n\n    //异或的特点：如果a^b=c,则a^c=b,b^c=a\n    int word;  //输入明文\n    cin>>word;\n    int key=0x19;  //这里不是整数19，而是0001 0011这样的二进制串\n    int password=word^key;  //得到密文\n    cout<<password<<endl;\n    int back=password^key;  //解密得到明文\n    cout<<back<<endl;\n\n    //交换两个变量的值\n    int e,f;\n    cin>>e>>f;\n    e=e^f;\n    f=e^f;\n    e=e^f;\n    cout<<e<<\" \"<<f<<endl;\n    return 0;\n}\n```\n程序输出结果如下：\n```C++\n0\n是\n255\n236\n1565\n1540\n1565\n12 15\n15 12\n```\n## 移位运算\n```C++\n#include<iostream>\nusing namespace std;\n\nint main(){\n    //左移运算符，高位丢弃，低位补0,左移相当于乘2\n    int i=((-15)<<3);\n    cout<<i<<endl;\n\n    //右移运算符，符号位一起移动，丢弃掉的位补充原符号位（无符号数补0）\n    //负数移位的时候，注意原码与补码的转换\n    //右移相当于除2，除不尽的时候，往小圆整\n    int j=((-25)>>4);\n    cout<<j<<endl;\n    return 0;\n}\n```\n程序输出结果如下：\n```C++\n-120\n-2\n```\n## 引用\n```C++\n#include<iostream>\nusing namespace std;\nint main(){\n    int a=5,b=4;\n    int& r=a;\n    r=6;\n    cout<<a<<endl;\n    r=b;  //r 引用了 a 之后，它的引用对象就不能改了，这里只是赋值语句\n    cout<<a<<\" \"<<r<<endl;\n}\n\n/*引用只能引用变量，不能引用常量或者表达式*/\n```\n程序输出结果如下：\n```C++\n6\n4 4\n```\n## 引用作为函数的返回值\n```C++\n#include<iostream>\nusing namespace std;\n\nint n=4;\nint& setValue()  {return n;}  //函数返回值是一个引用，它引用了一个全局变量\n\nint main(){\n    setValue() = 40;  //可以将一个函数放在赋值号左边赋值\n    /*相当于 int& tmp=n;  tmp40;*/\n    cout<<n;\n    return 0;\n}\n```\n程序输出结果如下：\n```C++\n40\n```","comments":true,"permalink":"http://yoursite.com/2019/06/08/C++学习笔记——从C到C++/","categories":[],"tags":[{"name":"C/C++","slug":"C-C","permalink":"http://yoursite.com/tags/C-C/"},{"name":"指针","slug":"指针","permalink":"http://yoursite.com/tags/指针/"}]},{"title":"C++学习笔记—多态和虚函数","date":"2019-06-08T14:13:41.309Z","path":"2019/06/08/C++学习笔记——多态和虚函数/","raw":"---\ntitle: C++学习笔记—多态和虚函数\ntags:\n- C++\n---\n\n## 多态的指针表现形式\nvirtual关键字只用于类定义里的函数声明中，在类的外面写函数体则不写virtual\n构造函数和静态成员函数不能是虚函数，析构函数是可以的\n```C++\n//通过基类指针调用基类和派生类的同名虚函数时，指针指向哪个类的对象，就调用哪个类的虚函数\n#include<iostream>\nusing std::cout;\nusing std::endl;\n\nclass Base{\npublic:\n    virtual void func(){cout<<\"Base virtual called\"<<endl;}\n};\n\nclass Derived:public Base{\npublic:\n    virtual void func(){cout<<\"Derived virtual called\"<<endl;} //同名虚函数\n};\n\nint main(){\n    Base b;\n    Derived d;\n    Base* p1=&b;  //指针指向基类对象\n    Base* p2=&d;  //赋值兼容规则，指针指向派生类对象\n    p1->func();\n    p2->func();\n    return 0;\n}\n\n```\n程序输出如下：\n```C++\nBase virtual called\nDerived virtual called\n```\n## 多态的引用表现形式\n```C++\n//通过基类引用调用基类和派生类的同名虚函数时，引用的是哪个类的对象，就调用哪个类的虚函数\n#include<iostream>\nusing std::cout;\nusing std::endl;\n\nclass Base{\npublic:\n    virtual void func(){cout<<\"Base virtual called\"<<endl;}\n};\n\nclass Derived:public Base{\npublic:\n    virtual void func(){cout<<\"Derived virtual called\"<<endl;} //同名虚函数\n};\n\nint main(){\n    Base b;\n    Derived d;\n    Base& p1=b;  //p1引用一个基类对象\n    Base& p2=d;  //p2引用一个派生类对象\n    p1.func();\n    p2.func();\n    return 0;\n}\n```\n程序输出如下：\n```C++\nBase virtual called\nDerived virtual called\n```\n## 多态简单实例\n```C++\n#include<iostream>\nusing std::cout;\nusing std::endl;\n\nclass A{\npublic:\n    virtual void func(){cout<<\"virtual A called\"<<endl;}\n};\n\nclass B:public A{\npublic:\n    virtual void func(){cout<<\"virtual B called\"<<endl;}\n};\n\nclass C:public A{\npublic:\n    virtual void func(){cout<<\"virtual C called\"<<endl;}\n};\n\nclass D:public B{\npublic:\n    virtual void func(){cout<<\"virtual D called\"<<endl;}\n};\n\nclass E:public C{\npublic:\n    virtual void func(){cout<<\"virtual E called\"<<endl;}\n};\n\nint main(){\n    A a;B b;C c;D d;E e;\n    A* pa=&a;B* pb=&b;C* pc=&c;D* pd=&d;E* pe=&e;\n    pa->func();\n    pc->func();\n    pa=pb;\n    pa->func();\n    pa=pe;\n    pa->func();\n    pb=pd;\n    pb->func();\n    return 0;\n}\n```\n程序输出如下：\n```C++\nvirtual A called\nvirtual C called\nvirtual B called\nvirtual E called\nvirtual D called\n```\n## 多态的游戏程序实例\n创建一个怪物基类`Creature`，并派生出各种各样的具体的怪物类。每一种怪物类包含主要三个成员函数。\n`Attack()`的参数是被攻击的对象，并调用被攻击怪物的`Hurted()`函数，被攻击者血量降低，同时调用被攻击者的`FightBack()`函数，被攻击者的反击。\n`Hurted()`函数的参数是攻击者的攻击力。\n`FightBack()`函数的参数是攻击者，由被攻击者向攻击者发起反击。\n非多态的写法如下：\n```C++\n//每个类都有n个Attack()成员函数，也有n个FightBack()成员函数\n\nclass Creature{\n    //设置成保护成员，因此派生类的成员函数可以访问当前对象的基类的保护成员\nprotected:\n    int attackValue;\n    int defendValue;\n    int lifeValue;\n};\n\nclass Dragon:public Creature{\npublic:\n    //多个重载的Attack()成员函数\n    void Attack(Ghost* pGhost){   //攻击幽灵\n        /*表现攻击动作的代码*/\n        pGhost->Hurted(int attackValue);\n        pGhost->FightBack(this);  //反击当前对象，也即Attack()作用的对象\n    }\n    void Attack(WildMan* pWildMan){  //攻击野人\n        /*表现攻击动作的代码*/\n        pWildMan->Hurted(int attackValue);\n        pWildMan->FightBack(this);  //反击当前对象，也即Attack()作用的对象\n    }\n    /* ...... */\n    void Hurted(int attackValue_){\n        if(attackValue_>defendValue)\n            lifeValue-=(attackValue_-defendValue);\n    }\n    void FightBack(Ghost* pGhost){     //反击幽灵\n        pGhost->Hurted(attackValue/2);\n    }\n    void FightBack(WildMan* pWildMan){  //反击野人\n        pWildMan->Hurted(attackValue/2);\n    }\n    /* ...... */\n};\n```\n多态写法如下：\n```C++\n#include<iostream>\n#include<string>\nusing namespace std;\n\nclass Creature{\n    //设置成保护成员，因此派生类的成员函数可以访问当前对象的基类的保护成员\nprotected:\n    int attackValue;\n    int defendValue;\n    int lifeValue;\n    string name;\npublic:\n    virtual void Attack(Creature* pCreature){}\n    virtual void Hurted(int attackValue_){}\n    virtual void FightBack(Creature* pCreature){}\n};\n\n//Dragon类\nclass Dragon:public Creature{\npublic:\n    Dragon(int attack_,int defend_,int life_,string name_);\n    //为基类和各个派生类创建同名虚函数\n    virtual void Attack(Creature* pCreature);\n    virtual void Hurted(int attackValue_);\n    virtual void FightBack(Creature* pCreature);\n    ~Dragon();\n};\n\nDragon::Dragon(int attack_,int defend_,int life_,string name_){\n    attackValue=attack_;\n    defendValue=defend_;\n    lifeValue=life_;\n    name=name_;\n}\n\nvoid Dragon::Attack(Creature* pCreature){\n    //基类指针调用基类和各个派生类的同名虚函数，多态语句\n    pCreature->Hurted(attackValue);\n    pCreature->FightBack(this);\n}\n\nDragon::~Dragon(){\n    cout<<name<<\" has been slained!\"<<endl;\n}\n\nvoid Dragon::Hurted(int attackValue_){\n    if(attackValue_>defendValue){\n        lifeValue-=(attackValue_-defendValue);\n        cout<<name<<\" has lose \"<<attackValue_-defendValue<<\" blood\"<<endl;\n        cout<<\"the remaining blood of \"<<name<<\" is \"<<lifeValue<<endl;\n    }\n    //当生命值为0时，这个对象死亡，调用这个对象的析构函数\n    if(lifeValue<=0)\n        this->~Dragon();  //注意析构函数的调用方法\n}\n\nvoid Dragon::FightBack(Creature* pCreature){\n    pCreature->Hurted(attackValue/2);  //以一半的攻击力进行反击\n}\n\n/* 其余的Ghost类和WildMan类写法同上，这里略去 */\nint main(){\n    Dragon dragon(60,95,60,\"dragon\");\n    Ghost ghost(99,50,66,\"ghost\");\n    WildMan wildMan(45,80,90,\"wildMan\");\n    dragon.Attack(&ghost);\n    getchar();\n    ghost.Attack(&wildMan);\n    getchar();\n    //数据设置问题，这里的野人对龙造不成伤害\n    wildMan.Attack(&dragon);\n    return 0;\n}\n```\n程序输出如下：\n```C++\nghost has lose 10 blood\nthe remaining blood of ghost is 56\n\nwildMan has lose 19 blood\nthe remaining blood of wildMan is 71\n\nwildMan has been slained!\nghost has been slained!\ndragon has been slained!\n```\n[成员函数里调用析构函数](https://bbs.csdn.net/topics/200085778)\n## 几何形体处理程序\n```C++\n#include<iostream>\n#include<cmath>\nusing namespace std;\n\nclass Shape{  //基类\npublic:\n    virtual double Area()=0;  //没有函数体的纯虚函数\n    virtual void PrintInfo()=0;\n};\n\nclass Rectangle:public Shape{ //长方形类\npublic: //同名虚函数\n    double w,h;\n    virtual double Area(){return w*h;}\n    virtual void PrintInfo(){cout<<\"Rectangle: \"<<Area()<<endl;}\n};\n\nclass Circle:public Shape{  //圆类\npublic: //同名虚函数\n    double r;\n    virtual double Area(){return 3.14*r*r;}\n    virtual void PrintInfo(){cout<<\"Circle: \"<<Area()<<endl;}\n};\n\nclass Triangle:public Shape{  //三角形类\npublic: //同名虚函数\n    double a,b,c;\n    virtual double Area();\n    virtual void PrintInfo(){cout<<\"Triangle: \"<<Area()<<endl;}\n};\n\ndouble Triangle::Area(){\n    double p=(a+b+c)/2;\n    double s=sqrt(p*(p-a)*(p-b)*(p-c));  //海伦公式\n    return s;\n}\n\nShape* pShapes[100];  //基类指针数组，每个数组元素都是基类指针,指向派生类对象\nint MyCompare(const void*,const void*);\n\nint main(){\n    int n;\n    cin>>n;\n    char c;\n    Rectangle* pr;  //在case外面定义变量\n    Circle* pc;\n    Triangle* pt;\n    for(int i=0;i<n;i++){\n        cin>>c;\n        switch(c){\n            case 'R':\n                //不能在case里面定义指针，拿出去单独定义\n                pr=new Rectangle();  //创建长方形对象\n                cin>>pr->w>>pr->h;\n                pShapes[i]=pr;   //基类指针指向派生类对象\n                break;\n            case 'C':\n                pc=new Circle();  //创建圆对象\n                cin>>pc->r;\n                pShapes[i]=pc;\n                break;\n            case 'T':\n                pt=new Triangle();  //创建三角形对象\n                cin>>pt->a>>pt->b>>pt->c;\n                pShapes[i]=pt;\n        }\n    }\n    qsort(pShapes,n,sizeof(Shape*),MyCompare);\n    for(int i=0;i<n;i++){\n        pShapes[i]->PrintInfo();  //多态语句\n    }\n    return 0;\n}\n\nint MyCompare(const void* s1,const void* s2){\n    //数组pShapes[100]的元素类型是Shape*，定义两个指向数组元素的指针，该指针类型是Shape**\n    Shape** p1=(Shape**)s1;\n    Shape** p2=(Shape**)s2;\n    //*p1是基类指针，通过基类指针调用同名虚函数，多态语句\n    return ((*p1)->Area()-(*p2)->Area());   //按照面积从小到大的顺序排序，返回负值则s1元素在前\n}\n```\n[case里面定义变量会出错](https://zhidao.baidu.com/question/69203440.html?word=jump+to+case+Label)\n程序输出如下：\n```C++\n5\nR 3 5\nT 3 4 5\nC 9\nC 6\nT 3 3 4\nTriangle: 4.47214\nTriangle: 6\nRectangle: 15\nCircle: 113.04\nCircle: 254.34\n```\n如果增加新的几何形体，只需要多派生出来一个子类，其余已经存在的派生类不需要改变\n建立一个基类指针数组，存放各种派生类对象的指针，遍历该数组，就能对各个派生类对象进行操作\n## 在成员函数里调用虚函数\n在除了构造函数和析构函数之外的成员函数里调用虚函数，都是多态语句。\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Base{\npublic:\n    void fun1(){fun2();}\n    virtual void fun2(){cout<<\"Base::fun2() is called\"<<endl;}\n};\n\n\nclass Derived:public Base{\npublic:\n    virtual void fun2(){cout<<\"Derived::fun2() is called\"<<endl;}\n};\n\nint main(){\n    Derived d;\n    Base* pBase=&d;\n    pBase->fun1();\n    return 0;\n}\n```\n程序输出如下：\n```C++\nDerived::fun2() is called\n```\n## 虚函数表\n多态的关键在于通过基类指针或者引用调用虚函数时，编译时不确定调用的到底是基类的还是派生类的函数，运行时才确定。这叫动态联编\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Base{\n    int i;\npublic:\n    void fun1(){}\n    virtual void fun(){}\n};\n\nclass Derived:public Base{\n    int j;\npublic:\n    virtual void fun(){}\n};\n\nint main(){\n    cout<<sizeof(Base)<<\" \"<<sizeof(Derived)<<endl;\n    return 0;\n}\n```\n每一个有虚函数的类（或者它的基类有虚函数）都有一个虚函数表，该类的所有对象都维护一个指向虚函数表的指针，因此存储空间会多4个字节。虚函数表指出了所有虚函数的地址。\n程序输出如下：\n```C++\n8 12\n```\n## delete基类指针删除派生类对象\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Base{\npublic:\n    ~Base(){cout<<\"Base destructor is called\"<<endl;}\n};\n\nclass Derived:public Base{\npublic:\n    ~Derived(){cout<<\"Derived destructor is called\"<<endl;}\n};\n\nint main(){\n    Base* pBase=new Derived();\n    delete pBase;\n    return 0;\n}\n```\n这种写法就只调用基类的析构函数，只删除了指针，并没有真正将派生类对象给删除掉。\n程序输出如下：\n```C++\nBase destructor is called\n```\n## 虚析构函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Base{\npublic:\n    //把基类的析构函数声明为虚函数\n    virtual ~Base(){cout<<\"Base destructor is called\"<<endl;}\n};\n\nclass Derived:public Base{\npublic:\n    //派生类的析构函数不需要声明为虚函数\n    ~Derived(){cout<<\"Derived destructor is called\"<<endl;}\n};\n\nint main(){\n    Base* pBase=new Derived();\n    delete pBase;\n    return 0;\n}\n```\n这样就真正地将基类指针和派生类对象都删除掉了。析构函数可以是虚函数，但是构造函数不能是虚函数。\n程序输出如下：\n```C++\nDerived destructor is called\nBase destructor is called\n```\n## 纯虚函数和抽象类\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Base{\npublic:\n    virtual void fun()=0;  //有纯虚函数，所以Base是抽象类\n    //普通成员函数内部，可以调用纯虚函数\n    void fun1(){fun();}  //在非构造和析构的成员函数里调用同名虚函数，是多态语句\n    A(){}  //构造函数和析构函数内部，不能调用纯虚函数\n};\n\nclass Derived:public Base{\npublic:\n    //和基类的fun()函数同名同参数表，是省略了virtual的同名虚函数\n    void fun(){cout<<\"Derived fun is called\"<<endl;}\n    //派生类实现了基类中的所有纯虚函数，成为非抽象类\n};\n\nint main(){\n    Derived d;\n    Base* pBase=&d; //抽象类的指针指向派生类的对象\n    Base& yBase=d;  //抽象类引用派生类的对象\n    d.fun1();\n    return 0;\n}\n//抽象类只能作为基类用来派生子类\n//抽象类不能创建对象，但可以定义抽象类的指针和引用\n```\n程序输出如下：\n```C++\nDerived fun is called\n```\n<blockquote>多态的时间开销：调用同名虚函数时要查虚函数表。\n多态的空间开销：虚函数表的存储</blockquote>\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/08/C++学习笔记——多态和虚函数/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"C++学习笔记—继承和派生","date":"2019-06-05T15:50:06.312Z","path":"2019/06/05/C++学习笔记——继承和派生/","raw":"---\ntitle: C++学习笔记—继承和派生\ntags:\n- C++\n---\n\n## 派生类对象的内存空间\n```C++\n#include<iostream>\nusing namespace std;\n\nclass CBase{  //基类\npublic:\n    int c1,c2;\n};\n\nclass CDriver:public CBase{  //派生类\npublic:\n    int c3;\n};\n\nint main(){\n    cout<<sizeof(CBase)<<\" \"<<sizeof(CDriver)<<endl;\n    CBase t1,t2;\n    CDriver t3,t4;\n    cout<<&t1<<\" \"<<&t2<<\" \"<<&t3<<\" \"<<&t4<<endl;\n    //低地址存放派生类对象，高地址存放基类对象。而且应该是先构造的后存储,低地址存放的是后构造的对象\n    cout<<&t3.c1<<\" \"<<&t3.c2<<\" \"<<&t3.c3<<endl;\n    //基类对象的存储位置位于派生类对象新增的成员变量之前\n    return 0;\n}\n```\n程序输出如下：\n```C++\n8 12\n0x6dfef8 0x6dfef0 0x6dfee4 0x6dfed8\n0x6dfee4 0x6dfee8 0x6dfeec\n```\n## 学籍管理\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Student{\n    string name;\n    int age;\n    string id;\n    char gender;\npublic:\n    void PrintInfo();\n    void SetInfo(const string&,int,const string&,char); //函数原型不需要写出形参的名字\n    string GetName(){return name;}\n};\n\nvoid Student::PrintInfo(){\n    cout<<name<<endl<<age<<endl<<id<<endl<<gender<<endl;\n}\n\nvoid Student::SetInfo(const string& name_,int age_,const string& id_,char gender_){\n    name = name_;\n    age = age_;\n    id = id_;\n    gender = gender_;\n}\n\nclass UndergraduateStudent:public Student{\n    string department;  //多出的成员变量\npublic:\n    void BaoYan(){cout<<\"You Can BaoYan!\"<<endl;}  //多出的成员函数\n    void PrintInfo(){ //对继承来的成员函数的修改，也叫覆盖\n        Student::PrintInfo();\n        cout<<department<<endl;\n    }\n    void SetInfo(const string&,int,const string&,char,const string&);  //覆盖\n};\n\nvoid UndergraduateStudent::SetInfo(const string& name_,int age_,const string& id_,char gender_,const string& department_){\n    Student::SetInfo(name_,age_,id_,gender_);\n    department = department_;\n}\n\nint main(){\n    Student s1;\n    UndergraduateStudent s2;\n    s2.SetInfo(\"魏原\",23,\"2015210950\",'M',\"Machanical Engineering\");\n    s2.BaoYan();\n    cout<<s2.GetName()<<endl;  //调用继承过来的成员函数\n    s2.PrintInfo();\n    s1.PrintInfo();  //自动生成的无参构造函数会给成员变量随机赋值\n    return 0;\n}\n```\n程序输出如下：\n```C++\nYou Can BaoYan!\n魏原\n魏原\n23\n2015210950\nM\nMachanical Engineering\n\n44895312\n\n\n\n```\n## 对象间的复合关系\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Point{\n    double x,y;\n    //将圆类声明为友元，这样就可以在圆类中访问圆心对象的私有成员了\n    friend class Circle;\n};\n\n//圆对象中包含着一个点对象（圆心），即两个类为复合关系\nclass Circle{\n    double r;\n    Point center;\npublic:\n    void SetRadius(double r_){r=r_;}  //设置半径\n    double Area(){return 3.14*r*r;}   //计算面积\n    void SetCoor(double x_,double y_){center.x=x_;center.y=y_;}  //设置圆心坐标\n    double Cal(){return center.x+center.y;}  //计算圆心坐标的和\n};\n\nint main(){\n    Circle c;\n    double tmp;\n    cout<<\"请输入圆的半径：\";\n    cin>>tmp;\n    c.SetRadius(tmp);\n    c.SetCoor(2.5,3.4);\n    cout<<c.Cal()<<endl;\n    cout<<\"圆的面积是：\"<<c.Area()<<endl;\n    return 0;\n}\n```\n程序输出如下：\n```C++\n请输入圆的半径：2\n5.9\n圆的面积是：12.56\n```\n## 小区养狗程序\n```C++\nclass Master;\n\nclass Dog{\n    Master* master;\n};\n\nclass Master{\n    Dog dogs[10];\n};\n\n//每个主人管理一个狗的数组，每个狗有一个指向主人的指针\n```\n\n```C++\nclass Master;\n\nclass Dog{\n    Master* master;\n};\n\nclass Master{\n    Dog* dogs[10];\n};\n\n\n//狗有一个指针指向自己的主人，主人也有很多指针指向自己养的那些狗\n```\n## 基类和派生类有同名成员\n```C++\n#include<iostream>\nusing namespace std;\n\nclass base{\n   int j;\npublic:\n    int i;\n    void func(){cout<<\"the Base Type is called\"<<endl;}\n};\n\nclass derived:public base{\npublic:\n    int i;  //和基类有同名的成员变量\n    //和基类有同名的成员函数\n    void func(){cout<<\"the Derived Type is called\"<<endl;}\n    void access();\n};\n\nvoid derived::access(){\n    //j=5;  不能访问基类的私有成员，只能通过基类的成员函数和基类的友元函数访问\n    i=4;  //访问的派生类自己的成员\n    base::i=6;  //加上域作用符之后访问的才是从基类继承来的成员\n    func();  //成员函数的访问同上\n    base::func();\n}\n\nint main(){\n    base t1;\n    derived t2;\n    t2.access();\n    cout<<t2.i<<\" \"<<t2.base::i<<\" \"<<t1.i<<endl;\n    //对继承来的成员赋值，并不改变基类该成员变量的值\n    return 0;\n}\n```\n程序输出如下：\n```C++\nthe Derived Type is called\nthe Base Type is called\n4 6 1952606858\n```\n## Protected成员\n```C++\n//基类的保护成员可以被基类的成员函数，基类的友元函数访问\n//派生类的成员函数可以访问当前对象的基类的保护成员\n#include<iostream>\nusing namespace std;\n\nclass father{\n    int i;\npublic:\n    int j;\nprotected:\n    int k;\n};\n\nclass son:public father{\npublic:\n    void access(){\n        //i=1; 继承来的并不为自己所拥有？\n        //这里不能认为是“派生类的成员函数访问派生类的私有成员”\n        j=2;\n        k=3;\n    }\n    void GetProtected(){cout<<k;} //这里输出的也是基类的保护成员\n};\n\nint main(){\n    father f;\n    son s;\n    s.access();\n    s.GetProtected();\n    //f.k=2;\n    //s.k=3;\n    return 0;\n}\n```\n程序输出如下：\n```C++\n3\n```\n## 派生类的构造函数\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Bug{\n    int legs,color;\npublic:\n    int type;\n    Bug(int legs_,int color_):legs(legs_),color(color_){\n        type=100;\n        cout<<\"Base constructed called\"<<endl;\n    }\n    void PrintBug(){cout<<\"the Legs of Bug is\"<<\" \"<<legs<<endl;}\n};\n\nclass FlyBug:public Bug{\n    int wings;\npublic:\n    FlyBug(int legs_,int color_,int wings_):Bug(legs_,color_){\n        wings=wings_;\n        cout<<\"Derived constructed called\"<<endl;\n    }\n};\n\nint main(){\n    FlyBug fb(2,3,4);\n    fb.PrintBug();\n    cout<<fb.type<<endl;\n    //fb.legs=15; 不能访问基类的私有成员\n    return 0;\n}\n```\n程序输出如下：\n```C++\nBase constructed called\nDerived constructed called\nthe Legs of Bug is 2\n100\n```\n## 派生类和基类的构造与析构\n```C++\n#include<iostream>\nusing namespace std;\n\nclass Base{\n    int n;\npublic:\n    Base(int i):n(i){\n        cout<<\"Base constructed ccalled\"<<endl;\n    }\n    ~Base(){cout<<\"Base destructed called\"<<endl;}\n};\n\nclass Derived:public Base{\n    int k;\npublic:\n    Derived(int i,int j):Base(i),k(j){\n        cout<<\"Derived constructed caalled\"<<endl;\n    }\n    ~Derived(){cout<<\"Derived destructed called\"<<endl;}\n};\n\nint main(){\n    Derived obj(3,5);\n    return 0;\n}\n```\n程序输出如下：\n```C++\nBase constructed ccalled\nDerived constructed caalled\nDerived destructed called\nBase destructed called\n```\n## 包含成员对象的构造与析构\n```C++\n//先构造基类，再按顺序构造成员对象，最后构造派生类\n//先构造的后析构\n\n#include<iostream>\nusing namespace std;\n\nclass Base{\n    int n;\npublic:\n    Base(int i):n(i){\n        cout<<\"Base constructed ccalled\"<<endl;\n    }\n    ~Base(){cout<<\"Base destructed called\"<<endl;}\n};\n\nclass A{\npublic:\n    A(){cout<<\"A constructed called\"<<endl;}\n    ~A(){cout<<\"A destructed called\"<<endl;}\n};\n\nclass B{\npublic:\n    B(){cout<<\"B constructed called\"<<endl;}\n    ~B(){cout<<\"B destructed called\"<<endl;}\n};\n\n\n\nclass Derived:public Base{\n    int k;\n    A a;\n    B b;\npublic:\n    Derived(int i,int j):Base(i),k(j){\n        cout<<\"Derived constructed caalled\"<<endl;\n    }\n    ~Derived(){cout<<\"Derived destructed called\"<<endl;}\n};\n\nint main(){\n    Derived obj(3,5);\n    return 0;\n}\n```\n程序输出如下：\n```C++\nBase constructed ccalled\nA constructed called\nB constructed called\nDerived constructed caalled\nDerived destructed called\nB destructed called\nA destructed called\nBase destructed called\n```\n## 直接基类与间接基类\n```C++\n#include<iostream>\nusing namespace std;\n//自上而下沿着派生关系进行构造\n\nclass Base{\n    int i;\npublic:\n    Base(int i_):i(i_){cout<<\"Base\"<<\" \"<<i<<\" \"<<\"constructed ccalled\"<<endl;}\n    ~Base(){cout<<\"Base\"<<\" \"<<i<<\" \"<<\"destructed called\"<<endl;}\n};\n\nclass Derived:public Base{\n    int j;\npublic:\n    Derived(int i_,int j_):Base(i_),j(j_){\n        cout<<\"Derived\"<<\" \"<<j<<\" \"<<\"constructed caalled\"<<endl;\n    }\n    ~Derived(){cout<<\"Derived\"<<\" \"<<j<<\" \"<<\"destructed called\"<<endl;}\n};\n\nclass MoreDerived:public Derived{\n    int k;\npublic:\n    MoreDerived(int i_,int j_,int k_):Derived(i_,j_),k(k_){\n        cout<<\"MoreDerived\"<<\" \"<<k<<\" \"<<\"constructed caalled\"<<endl;\n    }\n    ~MoreDerived(){cout<<\"MoreDerived\"<<\" \"<<k<<\" \"<<\"destructed called\"<<endl;}\n};\n\nint main(){\n    MoreDerived obj(2,3,4);\n    return 0;\n}\n```\n程序输出如下：\n```C++\nBase 2 constructed ccalled\nDerived 3 constructed caalled\nMoreDerived 4 constructed caalled\nMoreDerived 4 destructed called\nDerived 3 destructed called\nBase 2 destructed called\n```\n## public继承的赋值兼容规则 \n```C++\nclass Base{};\n\nclass Derived:public Base{};\n\nint main(){\n    Base b;\n    Derived d ;\n    return 0;\n}\n\n//派生类对象首先要是一个基类对象，比如大学生首先他是一个学生对象\n\n/*\n派生类对象可以赋值给基类对象，学生=大学生，b=d\n将派生类中位于最前面的属于基类的那部分，完全拷贝给所要赋值的基类对象\n*/\n\n/*\n派生类对象可以初始化基类引用\nBase& b = d，b是一个基类对象，它引用d这么一个派生类对象\n*/\n\n/*\n派生类对象的地址可以赋值给基类指针\nBase* b = &d  b是一个基类指针，它指向一个派生类对象\n*/\n```\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/05/C++学习笔记——继承和派生/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Office学习笔记","date":"2019-06-04T07:25:02.698Z","path":"2019/06/04/Office学习笔记/","raw":"---\ntitle: Office学习笔记\ntags:\n- Office\n---\n\n## 选中word文档里面全部的英文或者数字\n<kbd>查找</kbd> -> <kbd>更多</kbd> -> <kbd>使用通配符查找</kbd>\n在查找内容里输入`[0-9a-zA-Z]`\n[怎么快速的选中word文档中的全部数字和英文](https://zhidao.baidu.com/question/241724264.html)\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/04/Office学习笔记/","categories":[],"tags":[{"name":"Office","slug":"Office","permalink":"http://yoursite.com/tags/Office/"}]},{"title":"古诗词学习笔记","date":"2019-06-04T05:51:01.108Z","path":"2019/06/04/古诗词学习笔记/","raw":"---\ntitle: 古诗词学习笔记\ntags:\n- 文学\n---\n\n# <font color=\"RED\">韩愈------题榴花</font>\n2019年5月16日15点17分\n```\n五月榴花照眼明，\n枝间时见子初成。\n可怜此地无车马，\n颠倒苍苔落绛英。\n```\n诗题一作“题张十一（署）旅舍三咏·榴花”，是韩愈题写在好友张十一（名署）旅舍内的三首咏物诗之一。诗大概作于元和元年（806）韩愈和张署同赴贬所途中。\n古人常用各种花来自比，花受到美人的攀折，这花的生命历程才有意义。臣子就和花一样，只有受到皇帝的赏识，做臣子的才有意义，才有未来。古人还有很多诗人，明明是男的，却很热衷于写闺中怨妇的诗词，其实他们也是以怨妇自比，古代的女人非常依赖男人，男人不要她了，这个女人的人生基本就没有意义了，未来会受人指点，一片惨淡。臣子和怨妇相似的地方就在于，女人对于男人的依赖，就和臣子对于皇帝的依赖如出一辙。皇帝不要你了，做臣子的也就和被男人抛弃了的妇女一样。之前看到杜甫的一首怨妇诗写的真好，不过现在只记得“在山泉水清，出山泉水浊”这么一句了。\n对于这种事情，不同的诗人有不同的态度。韩愈说，“可怜此地无车马，颠倒苍苔落绛英”，张九龄在《感遇》里说“草木有本心，何求美人折”，当然张九龄也有可能是故作坚强吧！\n\n# <font color=\"RED\">卜算子</font>\n2019年5月17日13点11分\n```\n独自上层楼，\n楼外青山远。\n望到斜阳欲尽时，\n不见西飞雁。\n\n独自下层楼，\n楼下蛩声怨。\n待到黄昏月上时，\n依旧柔肠断。\n```\n一首写闺妇的诗，我觉得写的很一般。只是把上楼时的心理与下楼时的心理分成两片来写，由有所期待到失望下楼到黄昏时的柔肠寸断！\n\n# <font color=\"RED\">朱淑真------清平乐·夏日游湖</font>\n2019年5月18日12点51分\n```\n恼烟撩露，留我须臾住。\n携手藕花湖上路，一霎黄梅细雨。　\n娇痴不怕人猜，和衣睡倒人怀。\n最是分携时候，归来懒傍妆台。\n```\n\n朱淑真的诗，以前只知道“月上柳梢头，人约黄昏后”，如今又写出这样的诗，看来这个女人确实和别的女人不太一样。\n\n这首诗的背景，有说是婚后行为，对婚姻不满，回娘家暂住，期间和少女时代的初恋约会。也有说是婚前的恋爱行为。。我以为第一种说法不太像，第一种行为即便放在今天也是很过分的行为了。\n\n第一句的“露”是指黄梅雨过后，草丛上面的露珠。“猜”是指别人的闲言碎语，猜疑猜忌之类的。\n\n# <font color=\"RED\">张籍------节妇吟</font>\n2019年5月18日13点13分\n刚刚在微信里面看到《清平乐·夏日游湖》这首诗的时候，底下评论有人说了一首张籍的《节妇吟》，在古诗文网里面看到大师的赏析，觉得这首诗tql\n\n```\n君知妾有夫，赠妾双明珠。\n感君缠绵意，系在红罗襦。\n妾家高楼连苑起，良人执戟明光里。\n知君用心如日月，事夫誓拟同生死。\n还君明珠双泪垂，何不相逢未嫁时。\n```\n表面上看，这首诗意思很浅显，就是一首歌颂节妇的诗，守节的妇女。苑指的是皇家打猎的那种场所，良人是那时候妇女对于丈夫的称呼，明光指汉朝的明光殿，这里就指皇宫了。用心如日月是指光明磊落，没有什么心机，拟是打算的意思。最后一句的“何不 ”也可以说是“恨不”。\n其实这是一首政治抒情诗，用以明志的。背景应该是在唐朝中后期了。李师道是当时藩镇之一的平卢淄青节度使，又冠以检校司空、同中书门下平章事的头衔。中唐以后，藩镇割据，用各种手段，勾结、拉拢文人和中央官吏。张籍是韩门大弟子，他的主张维护国家统一、反对藩镇割据分裂的立场一如其师。\n那么这首诗里，妾指的就是作者自己，丈夫指的是唐朝皇帝，君指的就是李师道了。明珠就是李师道用以拉拢张籍的荣华富贵了。张籍采用这种婉拒的方式，可是也是因为不想得罪李师道吧。\n古诗文网里面的其他一些解析：\n一二句的“知”有明知的意思，语气中带微辞，含有谴责之意。\n五六句以夫妇比喻君臣，表明自己唐朝官员的这个身份和立场。\n张籍的乐府诗与王建齐名，并称“张王乐府”。tql \n\n# <font color=\"RED\">李白------清平调·其一</font>\n2019年5月18日13点36分\n之前有一些抖音的视频，街头采访问最喜欢的诗词。底下的评论，很多人说“人生若只如初见，何事秋风悲画扇”！这是纳兰性德的《饮水词》里面的一句诗，而我自己目前最喜欢的一句诗，是李白的“云想衣裳花想容，春风拂槛露华浓”。\n```\n云想衣裳花想容，春风拂槛露华浓。 \n若非群玉山头见，会向瑶台月下逢。\n```\n这是唐玄宗和杨贵妃游玩的时候，召见李白，让白哥写的一首诗。\n关于这个第一句啊，我看古诗文网里面的赏析说，看见云就想起衣裳，看见花就想起容貌，还有说法是想通像，衣裳就像云一样，容貌就像花一样。\n在这之前，我自己的理解一直都是，云想念你的衣裳，花儿想念你的容貌。连云和花都这样贪念你的姿色，可见你是有多么的美貌了，我觉得这样理解没毛病啊！\n\n槛指的是花园的栏杆，华通花，是说露珠的滋润让花更加的浓艳，说杨贵妃受到皇帝的宠幸。\n\n群玉山是神话里西王母的住所，“会向”的意思就是一定的意思了。\n\n这就是我目前最喜欢的一句诗了。\n\n# <font color=\"RED\">李白------子夜吴歌</font>\n2019年5月23日8点51分\n```\n《春歌》\n秦地罗敷女，采桑绿水边\n素手青条上，红妆白日鲜\n蚕饥妾欲去，五马莫流连\n```\n《唐书·乐志》说：“《子夜歌》者，晋曲也。晋有女子名子夜，造此声，声过哀苦。”因起于吴地，所以又名《子夜吴歌》。\n罗敷一词来自《陌上桑》。\n红妆白日鲜是说妆容在阳光下显得特别鲜艳。\n《汉官仪》记载：“四马载车，此常礼也，惟太守出，则增一马。”故称五马。这里指达官贵人。 \n```\n《夏歌》\n镜湖三百里，菡萏发荷花\n五月西施采，人看隘若耶\n回舟不带月，归去越王家\n```\n镜湖指的是绍兴的湖，我一开始还以为说的是芜湖的镜湖呢。。。西施是越女，那这个镜湖肯定是在越地哦。菡萏指的是未开的荷花，花苞。若耶指的是西施浣纱的地方。西施采莲太过美貌，前来观看的人挤满了若耶。隘，狭隘，这里用作动词了。第五句，有的地方说是回去的时候(回舟)月亮还没升起来，就被越王宫的人请走了。还有的说是回家还不到一个月。\n\n```\n《秋歌》\n长安一片月，万户捣衣声\n秋风吹不尽，总是玉关情\n何日平胡虏，良人罢远征\n```\n捣衣，将洗过一次的脏衣服放在石板上捶击，去浑水，再清洗。也可使衣服变软，方便裁缝。\n\n```\n《冬歌》\n明朝驿使发，一夜絮征袍\n素手抽针冷，哪堪把剪刀\n裁缝寄远道，几日到临姚\n```\n这里的素手，我觉得不仅是指皮肤白，更是指天气好冷，冻的发白。\n\n# <font color=\"RED\">李商隐------谒山</font>\n2019年5月23日8点51分\n```\n从来系日乏长绳，水去云回恨不胜\n欲就麻姑买沧海，一杯春露冷如冰\n```\n这是好久之前在一个综艺节目上看到的，第二句中的恨指怅恨，惆怅，表达诗人的一种心情。诗人想从麻姑那里买来沧海，因为自古“百川东到海”，沧海在手即时间在手，但是怎么买呢？买来的沧海又变成桑田怎么办呢？最后一句极大地缩短了沧海桑田的时间，倏忽之间，沧海就只剩下一杯春露了，冷冷的春露。本来豪情万丈的要买沧海，一瞬间，这个想法却又灰飞烟灭。\n\n# <font color=\"RED\">李商隐------重帏深下莫愁堂</font>\n2019年6月3日20点39分\n```\n重帏深下莫愁堂，卧后清宵细细长。\n神女生涯原是梦，小姑居处本无郎。\n风波不信菱枝弱，月露谁教桂叶香。\n直道相思了无益，未妨惆怅是清狂。\n```\n第一句写居住环境，帏应该是帷幔，门帘之类的，很多重门帘，居住环境很深幽。莫愁堂可能是卧室名字，也可能是反衬主人公的愁。躺下之后，感觉夜晚很漫长，睡不着。\n\n颔联用到了两个典故。第一个巫山神女。楚国宋玉《高唐赋》称“先王”游高唐在白天梦见女神愿荐枕，神女临去时称自己“旦为朝云，暮为行雨”，这里形成了“巫山云雨”这个成语。后宋玉《神女赋》叙楚襄王夜梦神女，神女美艳绝伦、温婉娴雅，然而神女洁身自持，拒绝了楚襄王的追求。第二个清溪小姑的典故，暂时还不太熟悉。感觉这里的神女典故，这两个故事的意思差别很大啊，我感觉这里应当是取第一个故事的意思。过去的浪漫奇遇，一夜快活，原来只是一场梦。这可能是一场纯粹的梦，是没有经历过的，是主人公的向往，也有可能是曾经的经历，在岁月的流逝中变得如梦似幻，不管怎样，现在是和清溪小姑一样，“独处无郎”，孤身一人。\n\n我的身体柔弱，就像菱枝一样，但是生活中的风波不相信，还是要摧残我。下一句的我又变成了桂叶，这一句应该是反问语气，我是桂叶，那月光与露水在哪呢？这一句体现了自己的孤苦无依。\n\n李商隐的无题诗写的都比较隐晦。这首诗应该是说，女主人公追忆往事，怀念曾经拥有过的爱情生活，颈联是她慨叹命运的坎坷，这里的生活不幸，应该主要就是说失去了自己的爱情。我都已经这么柔弱了，还要夺走我的爱情，哭唧唧。。。我知道一味地相思是没有用地，但没办法，就是非常地怀念过去。可以说我是很痴情的一个女子了。\n\n# <font color=\"RED\">杨炯------从军行</font>\n2019年6月4日23点48分\n```\n烽火照西京，心中自不平。\n牙璋辞凤阙，铁骑绕龙城。\n雪暗凋旗画，风多杂鼓声。\n宁为百夫长，胜作一书生。\n```\n公元679—681年（唐高宗调露、永隆年间），吐蕃、突厥曾多次侵扰甘肃一带，裴行俭奉命出师征讨。\n第一句交代背景，边塞的报警烽火传到了长安，说明战事紧急。心中不平，想要出征。牙璋是古代发兵所用之兵符，分为两块，相合处呈牙状，朝廷和主帅各执其半。就是虎符。汉建章宫的圆阙上有金凤，故以凤阙指皇宫。龙城就是指匈奴的王庭，塞外大本营之类的。大雪纷飞，军旗黯然失色，这里的暗，杂都是用作动词。\n\n# <font color=\"RED\">李贺------金铜仙人辞汉歌</font>\n2019年6月5日12点08分\n```\n魏明帝青龙元年八月，诏宫官牵车西取汉孝武捧露盘仙人，欲立置前殿。宫官既拆盘，仙人临载，乃潸然泪下。唐诸王孙李长吉遂作《金铜仙人辞汉歌》。\n\n茂陵刘郎秋风客，夜闻马嘶晓无迹。\n画栏桂树悬秋香，三十六宫土花碧。\n魏官牵车指千里，东关酸风射眸子。\n空将汉月出宫门，忆君清泪如铅水。\n衰兰送客咸阳道，天若有情天亦老。\n携盘独出月荒凉，渭城已远波声小。\n```\n写作背景是李贺因病辞官，由长安返回洛阳途中所作。我想，大概是因为又是生病，又是辞官，又是要远行，诗人很伤感，所以想起了当年金铜仙人从长安去洛阳的故事。魏明帝时期，将汉朝汉武帝打造的金铜仙人从汉都长安迁徙到魏都洛阳，这件事更让人感觉到汉朝确实灭亡了。孝武指武帝，汉朝皇帝的谥号前面都要加一个孝字。宫官指的是宦官。王琦注引《三辅黄图》：“神明台，武帝造，上有承露盘，有铜仙人舒掌捧铜盘玉杯以承云表之露，以露和玉屑服之，以求仙道。”李贺字长吉，是唐朝宗室之后。\n\n前四句借金铜仙人的“观感”慨叹韶华易逝，人生短暂。秋风客是指悲秋之人。汉武帝曾作《秋风辞》，有句云：“欢乐极兮哀情多，少壮几时兮奈老何？”秋风客指茂陵里的刘郎汉武帝。传说汉武帝的魂魄出入汉宫，有人曾在夜中听到他坐骑的嘶鸣。张衡《西京赋》：“离宫别馆三十六所。”土花指苔藓。三四句是说桂花树依旧枝繁叶茂，香飘十里，可是汉朝的宫殿却已经十分荒芜了，这一句有种物是人非的感觉。\n\n中间四句说铜人离去的景象。千里指长安汉宫到洛阳魏宫路途之远。东关是说车子出长安东门的方向，这时候的风让人心酸落泪。将是伴随的意思，君特指汉武帝咯。\n最后四句。咸阳道指长安城外铜人经过的道路。如果天是有感情的，也会因为看到这样令人心酸的画面而伤感到衰老。盘就是之前说到的承露盘。已经走了很远了，渭水的波声都快听不到了。\n\n\n# <font color=\"RED\">李商隐------贾生</font>\n2019年6月9日14点33分\n```\n宣室求贤访逐臣\n贾生才调更无伦\n可怜夜半虚前席\n不问苍生问鬼神\n```\n宣室是汉文帝与贾谊谈话的地点，逐臣是说贾谊曾被贬谪。第二句说贾谊很有才华。前席做动词用，汉文帝在坐席上移膝向贾谊靠近。双方谈话到很深的夜晚，皇帝向臣子靠近，以便更好地交谈，但是这是徒劳的，是虚的，是没用的，是令人可惜可叹的，因为皇帝问的居然不是苍生社稷，而是鬼神之道。\n李商隐借汉文帝与贾谊的故事讽刺晚唐的君主，我还是第一次见到有人把汉文帝作为反面教材来说话的。\n\n# <font color=\"RED\">白玉蟾------夏夜宿水馆</font>\n2019年6月18日18点45分\n```\n松脂明灭已更寒，蛙市无声万籁沉。\n千里清风孤馆梦，一轮明月故人心。\n欲眠还醒推籐枕，骤热仍寒弄楮衾。\n搔首起来顾清影，断烟低锁荻花林。\n```\n白玉蟾，南宋道士，原名葛长庚。作者夏季在外，住宿在靠水的馆舍，晚上睡不着，思念自己海南家乡。\n松脂指的是油灯，明灭指的是油灯忽明忽暗，油灯快要点完了，夜已经很深了。颈联写的很美，“千里清风”当指离家千里的清风，它横亘在家乡与孤馆之间，为诗人的梦搭建回乡的桥梁，但是诗人晚上睡不着，不能在梦里回到家乡，于是就用月亮来寄托相思，希望自己的牵挂，可以通过月亮传递给远方的亲人。\n推籐枕表示诗人睡不着，就干脆不睡了，起来算了，因为心事重重而感到燥热，但是一起来又因为深夜感到很冷，赶紧再把被子盖上。\n尾联继续写景，“断烟”即孤烟，不知打何处来的烟雾，这些孤烟并没有高高飘起，而是沉在荻花林之间，就好像把林子锁住了一般。一个“锁”字，很容易令人想起李煜的“寂寞梧桐深院锁清秋”，有种难以挣脱的压抑之感。\n\n# <font color=\"RED\">武元衡------春兴</font>\n2019年6月19日15点27分\n```\n杨柳阴阴细雨晴，残花落尽见流莺。\n春风一夜吹乡梦，又逐春风到洛城。\n```\n武元衡，武则天曾侄孙。诗人远在异乡，看到春天即将过去，所以思念自己的家乡。作者是缑氏人，地点在洛阳附近。\n阴阴指的是杨柳的茂盛，一场小雨过后，残花落尽，可以看见流莺了，流指的是莺的叫声婉转。异乡的春天已经在柳暗花残中悄然逝去，故乡的春天又是什么样子呢？这副暮春景色勾起了作者的思乡情怀。春风为自己带来了关于故乡的梦，梦中的自己又追随着这股春风回到了自己的家乡。\n诗人看到暮春景色，触动了乡思，在一夜春风的吹拂下，做了一个还乡之梦。诗人在这平常的生活中提炼出一首美好的诗来，在这里，艺术的想象起了决定性的作用。\n\n# <font color=\"RED\">张先------天仙子</font>\n2019年6月19日15点41分\n```\n水调数声持酒听，午醉醒来愁未醒。送春春去几时回？临晚镜，伤流景，往事后期空记省。\n沙上并禽池上暝，云破月来花弄影。重重帘幕密遮灯，风不定，人初静，明日落红应满径。\n```\n一边喝酒一边听《水调歌》，午睡醒来，醉意已去但愁还在，傍晚时分照照镜子，感伤逝去的岁月，往事如烟，只能徒留以后再追忆。\n晚上了，因为风很大，所以很多重帘幕遮住，防止把灯吹灭了。在人们刚刚静下来准备休息的时刻，作者想到，今天晚上才见到的“花弄影”这样的美景，明天早上，这些花恐怕就都被风吹落了，铺满了园中的小路。真是伤感。\n“云破月来花弄影”这一句是最美的。诗人整个白天又是醉酒，又是愁苦，又是对着镜子感伤岁月的，晚上或许诗人是想赏月，但是厚厚的云遮住了月，啥也看不到。在诗人以为这苦逼的一天或许就这样结束的那一刻，咦，风把云吹破了一角，这一小块的天空变得明朗，月亮也出来了，这时候连花都十分配合，在月下舞动自己的影子。夜里的凉风徐徐吹拂着，月亮散发着清辉，花在跳舞，周围的景色一下子变得十分美丽。\n此句之所以传诵千古，不仅在于修辞炼句的功夫，主要还在于词人把经过整天的忧伤苦闷之后，在一天将尽品尝到即将流逝的盎然春意这一曲折复杂的心情，通过生动妩媚的形象给曲曲传绘出来，让读者从而也分享到一点欣悦和无限美感。\n\n# <font color=\"RED\">张先------青门引.春思</font>\n2019年6月19日16点17分\n```\n乍暖还轻冷。风雨晚来方定。庭轩寂寞近清明，残花中酒，又是去年病。 \n楼头画角风吹醒。入夜重门静。那堪更被明月，隔墙送过秋千影。\n```\n在春季的某一天，白天下了一天的雨，傍晚才停，偌大的庭院就作者一个人住，显得特别孤独。中酒就是喝酒过量。诗人感叹花的残败，借酒消愁又喝过了头，想想自己去年也曾经这样过。其实每一年都是这么在孤独与感伤中过来的。\n楼头指城上的戍楼。画角指的是军用的号角。号角声与寒风把诗人吹醒。入夜万籁俱静的时刻，可恶的月亮，居然隔着墙都要让我看到隔壁荡秋千的影子。\n\n# <font color=\"RED\">杜甫------佳人</font>\n2019年6月19日18点42分\n```\n绝代有佳人，幽居在空谷。\n自云良家子，零落依草木。\n关中昔丧乱，兄弟遭杀戮。\n官高何足论，不得收骨肉。\n世情恶衰歇，万事随转烛。\n夫婿轻薄儿，新人美如玉。\n合昏尚知时，鸳鸯不独宿。\n但见新人笑，那闻旧人哭。\n在山泉水清，出山泉水浊。\n侍婢卖珠回，牵萝补茅屋。\n摘花不插发，采柏动盈掬。\n天寒翠袖薄，日暮倚修竹。\n```\n依草木是说佳人隐居在山林中。丧乱指的是安史之乱。世俗人情都厌恶衰败的人家。烛火随风转动，比喻世事变化无常。合昏指夜合花，叶子朝开夜合，所以说“知时”。侍婢卖珠回，我觉得应该是清贫的把陪嫁珠宝都给卖了。牵萝指的是一些树枝藤条之类的。采柏动盈掬，动是往往的意思。\n\n整首诗最有深意的一句就是“在山泉水清，出山泉水浊”了。\n-  待嫁闺中时是清泉，嫁人后被丈夫抛弃，自己就成了浊泉。\n-  佳人以泉水自喻，以山喻夫婿之家，妇人为夫所爱，就是清泉；为夫所弃，便是浊泉。\n-  佳人自己守贞隐居，是清泉，丈夫背叛爱情，随波逐流，就是浊泉。\n\n杜甫的《佳人》既反映客观存在的社会问题，又体现了诗人的主观寄托。诗中人物悲惨的命运与高尚的情操形成了强烈的对照，既让人同情，又令人敬佩。\n\n# <font color=\"RED\">陆游------村居书喜</font>\n2019年6月20日15点12分\n```\n红桥梅市晓山横，白塔樊江春水生。\n花气袭人知骤暖，鹊声穿树喜新晴。\n坊场酒贱贫犹醉，原野泥深老亦耕。\n最喜先期官赋足，经年无吏叩柴荆。\n```\n这首诗写的是陆游隐居山林的所见所感。首联写景，红桥白塔，晓山春水。雨后初晴，天气骤然变得暖和。在坊场里喝酒，那里的酒价格很低贱， 因此自己虽然贫穷但是也能喝醉。老人也在忙着耕种。早期把赋税交够了，一整年都没有官吏来催交赋税了。\n\n对这首诗最初的印象，就是红楼梦里袭人名字的由来。\n\n# <font color=\"RED\">苏轼------惠州一绝</font>\n2019年6月20日15点20分\n```\n罗浮山下四时春，卢橘杨梅次第新。\n日啖荔枝三百颗，不辞长作岭南人。\n```\n苏轼被贬官岭南，居住在罗浮山下，这里四季如春。枇杷和黄梅天天都有新鲜的。\n\n# <font color=\"RED\">纳兰性德------木兰花</font>\n2019年6月20日15点30分\n```\n人生若只如初见，何事秋风悲画扇。\n等闲变却故人心，却道故人心易变。\n骊山语罢清宵半，泪雨霖铃终不怨。\n何如薄幸锦衣郎，比翼连枝当日愿。\n```\n扇子是夏天用来趋走炎热，到了秋天就没人理睬了，古典诗词多用秋扇来比喻被冷落的女性。班婕妤为汉成帝妃，被赵飞燕谗害，退居冷宫，后有诗《怨歌行》，以秋扇闲置为喻抒发被弃之怨情。\n《太真外传》中记载，唐明皇与杨玉环曾于七月七日夜，在骊山华清宫长生殿里盟誓，愿世世为夫妻。这就是“骊山之语”。唐玄宗在马嵬驿赐死杨玉环之后，后来在途中听到雨声、铃声而悲伤，遂作《雨霖铃》曲以寄哀思，这是“泪雨霖铃”。杨玉环死前云：“妾诚负国恩，死无恨矣。\n自己身边这个负心人，连薄幸的唐明皇（锦衣郎）也比不上！他好歹还和杨玉环许过比翼连枝的心愿好吧！\n\n# <font color=\"RED\">班婕妤------怨歌行</font>\n2019年6月20日17点55分\n```\n新裂齐纨素，皎洁如霜雪。\n裁为合欢扇，团团似明月。\n出入君怀袖，动摇微风发。\n常恐秋节至，凉飙夺炎热。\n弃捐箧笥中，恩情中道绝。\n```\n原来班婕妤和班昭不是一个人哦。。\n裂是指布从织布机上面扯下来，纨素都是指绢布，但是纨更加精细。\n怀袖指的是胸口和袖口。\n飙指疾风，“常恐秋节至”中的“常”字，更加表现了即便得宠的时候，也是居安思危，战战兢兢，如履薄冰的样子。\n弃和捐都是指抛弃的意思，箧和笥（si四声）指的是放物品的竹箱。\n这是很有名的一首宫怨诗。\n\n# <font color=\"RED\">李山甫------代崇徽公主意</font>\n2019年6月22日15点08分\n```\n金钗坠地鬓堆云，自别朝阳帝岂闻。\n遣妾一身安社稷，不知何处用将军？\n```\n这首诗借怀古之情讽喻了唐代宗腐败软弱的外交政策。因当年唐朝借回鹘（回纥，he二声）以平定了“安史之乱”，承应了许多屈辱的条件，致使后来回鹘不断骚扰唐朝疆土，奸淫抢掳，后来又威逼与崇徽公主成亲。可代宗却怒不敢言，不得不让崇徽公主下嫁回鹘，又一次重蹈了汉唐王朝的覆辙，使一代娥眉泪洒蕃邦。\n崇徽公主，，姓仆固氏，唐朝著名将领仆固怀恩的女儿。生卒年不详。\n在这之前，仆固氏的2个姐姐就先后远嫁回纥和亲。其中一位姐姐嫁给了牟羽可汗，被册为“光亲可敦”。光亲可敦在768年病死，牟羽可汗指名要仆固怀恩的女儿做妻子，于是唐代宗又加封仆固怀恩的幼女为“崇徽公主”，于769年嫁给回纥做可敦（王后）。\n\n# <font color=\"RED\">杜牧------题木兰庙</font>\n2019年6月22日15点22分\n```\n弯弓征战作男儿，梦里曾经与画眉。\n几度思归还把酒，拂云堆上祝明妃。\n```\n多少时候，木兰竭力克制着自己想家的感情，与边关将士大碗喝酒。\n《元和郡县志》：“朔方军北与突厥以河为界，河北岸有拂云堆神祠，突厥将入寇， 必先诣祠，祭酹求福。在今内蒙古自治区的乌喇特西北，堆上有明妃祠。明妃：指王昭君。\n\n# <font color=\"RED\">张九龄------感遇（一）</font>\n2019年6月24日20点42分\n```\n兰叶春葳蕤，桂华秋皎洁。\n欣欣此生意，自尔为佳节。\n谁知林栖者，闻风坐相悦。\n草木有本心，何求美人折。\n```\n草木欣欣向荣，生机勃勃，自然地顺应了美好的季节。自尔，即自然的。\n草木自己也没有想到，自己散发出的芳香，被林中隐士闻到，他因为这香味而感到高兴。坐，因此的意思。\n但是，散发香味这是草木自己的本性，并不是为了取悦美人，并不是为了吸引美人前来攀折啊！\n\n# <font color=\"RED\">张九龄------感遇（七）</font>\n2019年6月24日20点58分\n```\n江南有丹橘，经冬犹绿林。\n岂伊地气暖，自有岁寒心。\n可以荐嘉客，奈何阻重深。\n运命唯所遇，循环不可寻。\n徒言树桃李，此木岂无阴。\n```\n诗人以丹橘自比，嘉客指皇帝。“运命唯所遇”更多的是对“阻重深”的一种自我安慰，自我释怀。但是诗人自我安慰之后，迎来的确是更加蓬勃的爆发与愤怒，即“徒言树桃李，此木岂无阴”。\n\n# <font color=\"RED\"陆游------幽居初夏</font>\n2019年7月6日13点21分\n```\n湖山胜处放翁家，槐柳阴中野径斜。\n水满有时观下鹭，草深无处不鸣蛙。\n箨龙已过头番笋，木笔犹开第一花。\n叹息老来交旧尽，睡来谁共午瓯茶。\n```\n淳熙二年（1175年），陆游几经调动，来到蜀州任职。不久，范成大西入巴蜀，统帅蜀州，举荐陆游为参议官，二人常诗酒唱和，难免放浪形骸。这时，主和派借此大做文章，称陆游“不拘礼法”、“燕饮颓放”。说来，着实让人愤怒，但凡陆游一有机会施展身手，主和派总会第一时间跳出来，为他网织罪名。迫于压力，范成大罢免了陆游。为回应主和派的污蔑，陆游干脆自号“放翁”，表现出对主和派的轻视态度。\n后来，陆游因诗名而得到宋孝宗的赏识，但不久又遭人弹劾，称他“不自检饬、所为多越于规矩”，陆游打算坐实了“放翁”的名号，于是忿然辞官，闲居山阴老家，这一呆就是五年。\n此间，陆游写了不少的田园诗，《幽居初夏》诗大概作于其间。\n\n雨后水涨时，你可以看到白鹭自高空中飞下，落到湖边觅食的情景；在湖边漫步时，你会听到草丛深处传来青蛙的鸣叫声。这里的“下”用作动词。\n\n“箨龙”即竹笋，春天长出，至初夏已成熟；“木笔”即紫玉兰花，也叫辛夷，于春天开放，但在山中因气候原因，直到初夏才刚开花。\n\n# <font color=\"RED\"陆游------病起书怀</font>\n2019年7月6日13点27分\n```\n病骨支离纱帽宽，孤臣万里客江干。\n位卑未敢忘忧国，事定犹须待阖棺。\n天地神灵扶庙社，京华父老望和銮。\n出师一表通今古，夜半挑灯更细看。\n```\n病起指的是病愈的意思，病好了写下自己的感想。\n因为生病，导致头上的帽子带起来都显得太大了。不受重用的臣子客居在万里之外的长江边上。\n我不敢忘记对国家的忧愁，只有当我的棺材合上了，我才能停止这么做。\n庙社指的是宗庙和社稷，代表着国家。京华指的是开封，和銮即“和鸾”，古代车子上面挂的铃铛。这里代指君主御驾亲征，收复失地。\n\n# <font color=\"RED\"李白------下终南山过斛斯山人宿置酒</font>\n2019年7月6日13点36分\n```\n暮从碧山下，山月随人归。\n却顾所来径，苍苍横翠微。\n相携及田家，童稚开荆扉。\n绿竹入幽径，青萝拂行衣。\n欢言得所憩，美酒聊共挥。\n长歌吟松风，曲尽河星稀。\n我醉君复乐，陶然共忘机。\n```\n题目中的“过”是拜访的意思。\n“却顾”是回头看的意思。”苍苍“指灰白色的山路。“翠微”指青翠的山坡，此处指终南山。\n青萝：攀缠在树枝上下垂的藤蔓。\n“挥”即举杯的意思。\n松风：古乐府琴曲名，即《风入松曲》，此处也有歌声随风而入松林的意思。\n\n# <font color=\"RED\"李白------月下独酌</font>\n2019年7月6日13点36分\n```\n花间一壶酒，独酌无相亲。\n举杯邀明月，对影成三人。\n月既不解饮，影徒随我身。\n暂伴月将影，行乐须及春。\n我歌月徘徊，我舞影零乱。\n醒时同交欢，醉后各分散。\n永结无情游，相期邈云汉。\n```\n及春：趁着春光明媚之时。\n无情游：月、影没有知觉，不懂感情，李白与之结交，故称“无情游”。\n邈，遥远。云汉：银河。\n\n# <font color=\"RED\"杜牧------齐安郡后池绝句</font>\n2019年7月24日9点52分\n```\n菱透浮萍绿锦池，\n夏莺千啭弄蔷薇。\n尽日无人看微雨，\n鸳鸯相对浴红衣。\n```\n齐安郡即湖北黄州，是杜牧贬官外放之地。首联用“绿”突出静态美，颈联用黄莺的“啭”与“弄”突出动态美。“尽日无人”隐含的意思就是只有作者一个人，无所事事，百无聊赖才会一个人欣赏朦胧细雨。而作者看到了什么?\"独自看微雨\"的诗人与“相对浴红衣”的鸳鸯，更突出了诗人的孤独。\n\n# <font color=\"RED\"李白------苏台览古</font>\n2019年7月24日10点13分\n```\n旧苑荒台杨柳新，菱歌清唱不胜春。 \n只今惟有西江月，曾照吴王宫里人。\n```\n第一句写吴苑的残破，苏台的荒凉，而人事的变化，兴废的无常，自在其中。后面紧接以杨柳在春天又发新芽，柳色青青，年年如旧，岁岁常新，有物是人非之感。柳岸湖中传来一曲曲悠扬悦耳的江南小调，仍不能极尽对春天美好的描绘。只有明月是永恒的，见过曾经吴宫的繁华，也见过如今苏台的破败，是历史的见证人。\n\n","comments":true,"permalink":"http://yoursite.com/2019/06/04/古诗词学习笔记/","categories":[],"tags":[{"name":"文学","slug":"文学","permalink":"http://yoursite.com/tags/文学/"}]},{"title":"Git Github Hexo","date":"2019-05-04T12:53:56.743Z","path":"2019/05/04/Git Github Hexo/","raw":"---\ntitle: Git Github Hexo\ntags:\n- 软件\n---\n\n# 下载安装Git\n\n## 生成ssh密钥\n输入`ssh-keygen`后，在指定文件`id_rsa.pub`下面得到密钥，输入到github设置里面去保存。这是为了将==git==和==github==建立连接，设置里面保存的是一个十六进制的数据，我的是`74:d1:16:d5:1a:df:d3:30:44:d9:83:9d:aa:81:a5:b7`，\n这里会得到一个密钥数据的randomart image，这好像是根据这个十六进制数据进行MD5加密后得到的一个类似于二维码的图形。具体加密原理，下面这个链接的作者介绍的非常好。\n[randomart image](https://www.jianshu.com/p/c6a7ffe01ac3)\n<img src=\"https://img-blog.csdnimg.cn/20190604145431951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70\">\n\n\n## 设置name和email\n <img src=\"https://img-blog.csdnimg.cn/2019060414545460.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70\">\n 这个是在桌面上点击设置的\n上次用码云的时候，这个已经设置过了\n\n# pull与push\n```\n$ git init\n$ git remote add origin url\n$ git pull origin master\n$ git add 文件.后缀\n$ git commit -m '注释'\n$ git push origin master\n$ git push -u origin master -f\n```\n\n各行代码意义简介：\n1. 初始化本地文件夹，之后在要上传的文件夹里面会多出来一个`.git`文件夹\n2. 将本地与仓库连接起来。这里涉及到https和ssh两种安全协议。区别可以参考链接。\n[https与ssh的区别](https://blog.csdn.net/ustbkuang/article/details/77678556)\n第一次用的是`https`，确实弹出了用户名和密码的登陆窗口，如下图。但是之后用`https`并没有再弹出登陆窗口。整个过程搞得迷迷糊糊的。并且，登陆时的用户名输入的是邮箱，输入**`xtncsg`**是没有用的！\n<img src=\"https://img-blog.csdnimg.cn/20190604145538283.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70\">\n\n3. 将要上传的文件保存到缓存区。这里如果要上传全部文件，就输入`add .`\n4. 推到**`master`**里面去，这里可以写上注释\n5. 推到远程仓库里面去\n6. 很多情况下，会出现各种各样的错误，这一句是强制推进去，不过这样远程仓库原有的内容都会丢失。慎用！！！\n\n下面是一张成功的案例图片，是推送爬取有道翻译的代码时保存的。\n<img src=\"https://img-blog.csdnimg.cn/20190604145557192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FIMjAxODAzMjQ=,size_16,color_FFFFFF,t_70\">\n\n# 搭建博客环境\n\n## 下载安装`Node.js`\n## 下载安装`Hexo`\n```\n$ npm install -g hexo-cli\n$ hexo init\n$ hexo install\n$ npm install hexo-deployer-git --save\n```\n\n1. 安装**`hexo`**，这个是在桌面上点击安装的，后面的都是在博客文件夹下面进入`Git Bash Here`\n2. 将本地文件夹初始化，之后会多出一些东西，这个就是存放博客的文件夹\n3. 安装一些依赖包\n4. 安装插件之类的\n\n## github新建仓库\n名为`shen-cheng-yu.github.io`,这是生成自己的个人主页\n\n## 配置`config.yml`\n在`Hexo`目录下的`config.yml`文件里面，进行配置\n最后一段配成这样：\n```\n# Deployment\n## Docs: https://hexo.io/docs/deployment.html\ndeploy:\n  type: git\n  repo: git@github.com:shen-cheng-yu/shen-cheng-yu.github.io.git\n  branch: master\n\n```\n这里的`repo`的地址就是刚刚新建的仓库的`ssh`地址\n后面再加上这么一段字典内容：\n```c++\n\njsonContent:\n  meta: true\n  pages: false\n  posts:\n    title: true\n    date: true\n    path: true\n    text: false\n    raw: false\n    content: false\n    slug: false\n    updated: false\n    comments: false\n    link: false\n    permalink: true\n    excerpt: false\n    categories: true\n    tags: true\n```\n## 部署\n配置完成后，回到`blog`的根目录进入`Git Bash Here`窗口，输入`hexo g -d`进行部署。对本地配置进行之后，都要进行部署，感觉跟刷新作用差不多\n回到浏览器，输入网址`shen-cheng-yu.github.io`就可以打开自己的博客网页了(Hexo网站需要多刷新几次才会显示)\n\n# 设置博客主题\n按照大佬的指示，选择了`Archer`这个主题（因为有中文安装教程），按照教程安装下去，在设置主题时，不知道怎么写QQ和微信的二维码的路径，写完之后，博客页面加载不出来图片QAQ\n对主题设置完之后，不要忘了部署！！\n\ntips: 一开始直接打开记事本，把文本输入到记事本保存。这样博客显示的就是乱码，用`pycharm`打开这个记事本文件也是乱码，应该是编码格式的问题。应该是新建一个空的记事本`.md`文件，用`pycharm`打开，在这里面复制保存，这样博客就不会乱码啦！\n\n<font color=\"red\">2019-07-24</font>\n# hexo上传图片\n以前写博客上传图片的时候，如果是网页里的图片，直接上传url，如果是本地图片的话，就先用CSDN托管一下再上传url。\n\nhexo上传本地图片需要一些操作，而上传别人网页里的图片，又太依赖于别人了。这个时候除了用CSDN托管之外，还可以用github托管。\n\n新建一个`hexo_photos`的仓库，可以直接用`upload files`来将图片上传到这个仓库里。点击图片，`download`就可以看到这张图片的url了。\n\n","comments":true,"permalink":"http://yoursite.com/2019/05/04/Git Github Hexo/","categories":[],"tags":[{"name":"软件","slug":"软件","permalink":"http://yoursite.com/tags/软件/"}]},{"title":"C++学习笔记—运算符重载","date":"2019-05-04T12:52:45.160Z","path":"2019/05/04/C++学习笔记——运算符重载/","raw":"---\ntitle: C++学习笔记—运算符重载\ntags:\n- C++\n---\n\n链接参见b站郭炜，刘家瑛老师的视频\n\n### 运算符重载为普通函数\n除了赋值运算符之外，其他的运算符可以重载为普通函数或者成员函数\n```python\n#include<iostream>\nusing namespace std;\n\nclass Complex{\npublic:\n    Complex(double r = 0,double i = 0){real = r,imag = i;}\n    double real;\n    double imag;\n};\n\nComplex operator+(const Complex &a,const Complex &b){\n    return Complex(a.real + b.real,a.imag + b.imag);\n}\n\nint main(){\n    Complex a(2,3),b(3,4),c;\n    c = a + b;\n    cout<<c.real<<\" \"<<c.imag<<endl;\n    return 0;\n}\n```\n这种重载方式的本质还是调用重载函数，函数的参数数目等于运算符的目数，将运算符两边的运算数当作实参传递给重载的函数\n\n### 运算符重载为成员函数\n```python\n#include<iostream>\nusing namespace std;\n\nclass Complex{\n    double real,imag;\npublic:\n    Complex(double r = 0.0,double i = 0.0):real(r),imag(i){}\n    Complex operator+(const Complex&);\n    Complex operator-(const Complex&);\n    double getReal(){return real;}\n    double getImag(){return imag;}\n};\n\n//x 是这个成员函数当前作用对象的其他同类对象，可以在成员函数里面直接调用它的私有成员\nComplex Complex::operator+(const Complex& x){\n    return Complex(real + x.real,imag + x.imag);\n}\n\nComplex Complex::operator-(const Complex& x){\n    return Complex(real - x.real,imag - x.imag);\n}\n\nint main(){\n    Complex a(1.1,2.2),b(0.5,1.0),c,d;\n    c = a + b;\n    d = a - b;\n    cout<<c.getReal()<<\" \"<<c.getImag()<<endl;\n    cout<<d.getReal()<<\" \"<<d.getImag()<<endl;\n    return 0;\n}\n```\n这种重载方式的原理不同于普通函数，a + b 相当于调用对象a的成员函数operator+()，参数就是对象b，即a.operator+(b)，这个成员函数的返回值在这里还是一个对象\n\n### 赋值运算符重载\n下面代码是用来设计一个长度可变的String类，包含一个 char* 成员，指向动态分配的内存空间，该存储空间用于接收以\\0结尾的字符串。程序用于实现将一个字符串赋值给一个String对象\n```python\n#include<iostream>\n#include<string.h>\nusing namespace std;\n\nclass String{\n    char* str;\npublic:\n    String():str(NULL){}\n    ~String();\n    char* operator=(const char*);\n    //这个函数用于输出str指针指向的内存空间，同时不希望这块空间的内容被修改\n    const char* printContext(){return str;}\n};\n\n//析构函数要考虑对象在生存周期内是否调用了operator=，没有调用的话，str还是指向NULL，析构函数不用进行任何处理\nString::~String(){\n    if(str){delete []str;}\n}\n\n//这个重载函数的返回值设计为void也行\nchar* String::operator=(const char* s){\n    if(str) delete []str;  //先将str指向的这块内存空间释放掉\n    if(s){  //s不为空时才进行拷贝\n        str = new char[strlen(s)+1];\n        strcpy(str,s);\n    }\n    else str = NULL;\n    return str;\n}\n\nint main(){\n    //输入一个字符串常量\n    char s1[20];\n    cin>>s1;\n    char s2[20];\n    cin>>s2;\n    //执行operator=\n    String obj1,obj2;\n    obj1 = s1;\n    obj2 = s2;\n    cout<<obj1.printContext()<<endl;\n    cout<<obj2.printContext()<<endl;\n\n    //浅拷贝\n    obj1 = obj2;\n    cout<<obj1.printContext()<<endl;\n    return 0;\n}\n```\n赋值运算符只能重载为成员函数\n构造函数里面通过初始化成员列表，将str指针置为`NULL`\n\n下面这是一个初始化语句，不会调用赋值运算符重载函数，而是调用构造函数\n `String obj = s;  //conversion from 'const char*' to non-scalar type 'String' requested`\n浅拷贝`obj1 = obj2;`的实质是逐字节的复制，将`obj2`的`str`指针赋值给`obj1`的`str`指针（这个类只有这么一个成员变量），即`obj1`的`str`指针指向`obj2`的`str`所指向的内存空间，这样`obj1`的`str`原来指向的那块内存就成为了垃圾内存，同时，`obj1`和`obj2`先后消亡的话，他们共同指向的那块空间就会`delete`两次，造成错误\n\n### 浅拷贝与深拷贝\n深拷贝的实质与浅拷贝不同，将`obj2.str`所指向的实际内容，复制给`obj1.str`所指向的内存空间\n```python\n#include<iostream>\n#include<string.h>\nusing namespace std;\n\nclass String{\n    char* str;\npublic:\n    String():str(NULL){}\n    ~String();\n    char* operator=(const char*);\n    //深拷贝时多写一个operator=，参数是某个对象的常引用，返回值也是一个对象（引用）\n    String& operator=(const String&);\n    const char* printContext(){return str;}\n};\n\nString::~String(){\n    if(str){delete []str;}\n}\n\nchar* String::operator=(const char* s){\n    if(str) delete []str;\n    if(s){\n        str = new char[strlen(s)+1];\n        strcpy(str,s);\n    }\n    else str = NULL;\n    return str;\n}\n\n//赋值运算符重载函数的参数和返回值最好都是引用，为什么？\nString& String::operator=(const String& x){\n    if(str == x.str) return *this;  //写上这句话是为了防止obj1 = obj1这样自己复制自己的情况\n    if(str)  delete []str;\n    str = new char[strlen(x.str)+1];\n    strcpy(str,x.str);\n    return *this;  //返回这个成员函数当前作用的对象\n}\n\nint main(){\n    char s1[20];\n    cin>>s1;\n    char s2[20];\n    cin>>s2;\n    char s3[20];\n    cin>>s3;\n    String obj1,obj2,obj3;\n    obj1 = s1;\n    obj2 = s2;\n    obj3 = s3;\n    cout<<obj1.printContext()<<endl;\n    cout<<obj2.printContext()<<endl;\n    cout<<obj3.printContext()<<endl;\n    //像下面这样连续赋值的时候，就说明了operator=的返回值不能是void\n    obj1 = obj2 = obj3;\n    cout<<\"---------------------------\"<<endl;\n    cout<<obj1.printContext()<<endl;\n    cout<<obj2.printContext()<<endl;\n    cout<<obj3.printContext()<<endl;\n    return 0;\n}\n```\n由最后面的例子知，赋值运算符重载时的返回值，不能是`void`，最好是引用（这是根据赋值运算符自己的特性来的）\n\n### 运算符重载函数声明为友元\n```python\n#include<iostream>\nusing namespace std;\n\nclass Complex{\n    double real,imag;\npublic:\n    Complex(double r,double i):real(r),imag(i){}\n    Complex operator+(double);  //这个用来解决 c+5\n    friend Complex operator+(double,const Complex&);  //这个用来解决 5+c\n    double getReal(){return real;}\n    double getImag(){return imag;}\n};\n\nComplex Complex::operator+(double x){\n    return Complex(real+x,imag);\n}\n\n//重载为普通函数，必须声明为友元才能访问私有成员\nComplex operator+(double x,const Complex& c){\n    return Complex(c.real+x,c.imag);\n}\n\nint main(){\n    Complex c(1,2);\n    Complex c1 = c + 5;  //会调用复制构造函数\n    Complex c2 = 5 + c;\n    cout<<c1.getReal()<<\" \"<<c1.getImag()<<endl;\n    cout<<c2.getReal()<<\" \"<<c2.getImag()<<endl;\n    return 0;\n}\n```","comments":true,"permalink":"http://yoursite.com/2019/05/04/C++学习笔记——运算符重载/","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]}]}